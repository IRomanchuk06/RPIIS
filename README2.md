<h1>ПиОИвИС - Расчётная работа</h1>
<h2>Разработка программы решения теоретико-графовой задачи</h2>
<hr/>
<h3>Задание 5.29</h3>
<em>Условие</em>: Необходимо найти дерево кратчайших путей взвешенного неориентированного графа, заданного списком смежности (инцидентности).
<hr/>
<h2>Описание алгоритма, примеры запуска и исполнения программы</h2>
<h3>Описание С++ кода и алгоритма выполнения поставленной задачи</h3>
<br>
<h4>Описание ключевых элементов кода на языке C++:</h4>
1)В начале программы подключаются все необходимые файлы из стандартной библиотеки языка C++:
<br>
iostream - для осуществления ввода данных пользователем, а также вывода информации о ходе исполнения программы и её результата в косоль;
<br>
fstream - для считывания информации о графе из txt-файла;
<br>
vector - для работы с векторами;
<br>
queue - для использования контейнера-очереди и очереди с приоритетом;
<br>
climits - для использования констант предельных значений типов данных.
<br>

![Снимок экрана (21)](https://github.com/iis-32170x/RPIIS/assets/144940569/f4377bf1-7b06-45d3-a2d3-72eb162f1737)

<hr/>
2) Подключение стандартного пространства имён.
<br>
<br>
3) Созданин структуры Vertex для хранения информации о вершинах графа.
<br>
<br>
4) Функция readGraphFromFile() для считывания информации из txt-файла о графе и последующего представления графа в виде вектора векторов структур Vertex.
 (Считывается число вершин графа и информация о смежных рёбрах).
<br>
<br>

![Снимок экрана (22)](https://github.com/iis-32170x/RPIIS/assets/144940569/1c2468a2-35d3-4ecb-b57d-245002bb4675)
<hr/>

6) Функция printShortestPathsTree() для вывода дерева кратчайших путей.
<br>
<br>
![Снимок экрана (23)](https://github.com/iis-32170x/RPIIS/assets/144940569/772aa1b4-dace-4ebe-ae7d-d653c8173300)
<hr/>
7) Функция findShortestPathsTree() для нахождения дерева кратчайших путей при помощи алгоритма Дейкстры.
<br>
<br>
![Снимок экрана (24)](https://github.com/iis-32170x/RPIIS/assets/144940569/a424f4e6-cbe0-4ac4-9cce-8b41945b24f3)
<hr/>
8) Главная функция main() для инициализации запуска программы, в которой определяется путь к нужному txt-файлу, а также используются все функции программы для вывода дерева кратчайших
путей относительно заданной вершины.
<br>

![Снимок экрана (25)](https://github.com/iis-32170x/RPIIS/assets/144940569/8447d565-628f-4a94-aa1e-d63ecc824975)
<hr/>
<h3>Структура txt-файла</h3>
<br>
txt-файл должен иметь подобную структуру:<br>
Число_Вершин<br>
Начальная_Вершина_1 Конечная_Вершина_1 Вес_Ребра_Связи_1<br>
Начальная_Вершина_2 Конечная_Вершина_2 Вес_Ребра_Связи_2<br>
...<br>
Где все значения являются целыми положительными числами.<br>
<hr/>
<h4>Пример графа и его запись в txt-файле:</h4>
<br>

![Безымянный](https://github.com/iis-32170x/RPIIS/assets/144940569/c2e321f3-ef42-49f4-a68d-c5b4c5d21318)

![Снимок экрана (27)](https://github.com/iis-32170x/RPIIS/assets/144940569/187bbc4b-2602-43bd-94a8-d470341051fb)
<hr/>
<h3>Пример запуска программы</h3>
<hr/>
Приведём запуск программы для приведённого выше как пример графа, найдя дерево кратчайших путей относительно вершины 0.
Для этого в поле string filename = "..." введём название нужного файла. В нашем случае "graph.txt". А переменную sourceVertex приравняем к нулю как к "корню" дерева.
<br>

![Снимок экрана (26)](https://github.com/iis-32170x/RPIIS/assets/144940569/557ee4a3-e9c0-4adb-bf24-2621abd946bc)
<hr/>

Инициализируем запуск программы и оцениваем результат.

![Снимок экрана (28)](https://github.com/iis-32170x/RPIIS/assets/144940569/a94968ed-db97-4b20-9ab5-5e8ce0add542)
<hr/>

В консоль программой было выведено дерево кратчайших путей из нулевой вершины, а также отображёны кратчайшие пути их веса к каждой из вершин нашего графа.
<br>
<hr/>
<br>
<bold>Вывод:</bold> В ходе данной лабораторной работы было установлено, что наиболее эффективный способ найти дерево кратчайших путей взвешенного неориентированного графа -
это воспользоваться алгоритмом Дейкстры, на основе перебора соседних вершин и запоминая уже посещённые ранее вершины. Таким образом теоретико-графовое задание
было успешно выполнено, при помощи приобретённых знаний по теории графов и более углубленного изучения языка C++.

