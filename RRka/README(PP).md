![](https://komarev.com/ghpvc/?username=Kukrynitza)
# <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=33&pause=1000&color=5B1182&random=false&width=435&lines=%D0%A0%D0%B0%D1%81%D1%87%D0%B5%D1%82%D0%BD%D0%B0%D1%8F+%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0" alt="Typing SVG" /></a>

## <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=29&pause=1000&color=7D1CA9&background=37143F16&random=false&width=435&lines=%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5" alt="Typing SVG" /></a>

### <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=24&pause=1000&color=D740F7&random=false&width=435&lines=%D0%A6%D0%B5%D0%BB%D1%8C" alt="Typing SVG" /></a>
(っ◔◡◔)っ ♥ Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графам. ♥

---
### <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=24&pause=1000&color=D740F7&random=false&width=435&lines=%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5" alt="Typing SVG" /></a>
☆🎅 １.❼определить вид графа 
 сильно-связный граф (ориентированный граф)
способ задания графа - список смежности (список инцидентности) ♪🍩 

---
### <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=24&pause=1000&color=D740F7&random=false&width=435&lines=%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5+%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F" alt="Typing SVG" /></a>
:=【`Граф`　—　математическая　абстракция　реальной　системы　любой　природы，　объекты　которой　обладают　парными　связями．】

:=【`﻿Ориентированный　граф`　—　граф，　рёбрам　которого　присвоено　направление．】

:=【﻿`Список　смежности`　—　один　из　способов　представления　графа　в　виде　коллекции　списков　вершин．　Каждой　вершине　графа　соответствует　список，　состоящий　из　«соседей»　этой　вершины．】

:=【﻿`Сильно－связный　граф`　－　граф　в　котором　существует　（ориентированный）　путь　из　любой　вершины　в　любую　другую，　или，　что　эквивалентно，　граф　содержит　ровно　одну　сильно　связную　компоненту．】
:=【`﻿Алгоритм　"поиск　в　глубину”　или　“обход　в　глубину”`　—　это　рекурсивный　алгоритм　по　поиску　всех　вершин　графа　или　дерева】
:= 【﻿`Транспонированный　граф`　－　другой　ориентированный　граф　с　тем　же　набором　вершин　и　с　теми　же　дугами，　но　ориентация　дуг　этого　графа　противоположна】

---
### <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=24&pause=1000&color=D740F7&random=false&width=435&lines=%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D1%8B+%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2+" alt="Typing SVG" /></a>
**👊🐯  ❶. сильно-связный граф  🎁🏆**
| 0 | 2 | 3 | 4 |
|---|---|---|---|
| 1 | 1 | 4 | 0 |
| 2 | 4 | 0 | 1 |
| 3 | 0 | 3 |   |
| 4 | 2 |   |   |

![image](https://github.com/iis-32170x/RPIIS/assets/144555463/fa71597a-08b6-4276-8940-9c0526e38ba1)

**🐻  🎀  𝟤.Слабо-связный граф  🎀  🐻**
| 0 | 2 | 3 | 4 |
|---|---|---|---|
| 1 | 1 | 4 | 0 |
| 2 | 4 | 0 | 1 |
| 3 | 0 | 3 |   |
| 4 | 2 |   |   |

![image](https://github.com/iis-32170x/RPIIS/assets/144555463/6ebe2cb9-e847-42a0-998c-e59828c0da34)

**😂☞  ➂. не связный граф  💔🍫**
| 0 | 2 | 3 | 4 |
|---|---|---|---|
| 1 | 1 | 4 | 0 |
| 2 | 4 | 0 | 1 |
| 3 | 0 | 3 |   |
| 4 | 2 |   |   |

![image](https://github.com/iis-32170x/RPIIS/assets/144555463/bc43380f-6de3-4e0c-bbc9-77705dbbd1a7)

---
---

## <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=29&duration=5001&pause=1000&color=7D1CA9&background=37143F16&random=false&width=435&lines=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC+%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F" alt="Typing SVG" /></a>

### <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=29&pause=1000&color=255A26&random=false&width=435&lines=%D0%A7%D0%B0%D1%81%D1%82%D1%8C+1%2C+%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C+%D0%B3%D1%80%D0%B0%D1%84%D0%B0" alt="Typing SVG" /></a>
```сpp
setlocale(LC_ALL, "RU");
string choise;
string rec;
cout << "Введите ссылку" << endl;
cin >> rec;
```
`1.1` Вводим ссылку на файл хранящий в себе список смежности 
```сpp
cout << "Будете записывать граф? Если да, напишите " << "yes" << endl;
cin >> choise;
if (choise == "yes")
    NeedsToBeWrittenInSomeoneNotebook(rec);
```
`1.2` Если задаем граф списком смежности с клавиатуры, вводим "yes",
а после переходим в функцию `NeedsToBeWrittenInSomeoneNotebook`, в которой будет происходить запись нового графа 
```сpp
void NeedsToBeWrittenInSomeoneNotebook(string rec) {
    ofstream vpis(rec, ios_base::out);
    cout << "Будет записано сюда " << rec << endl << "Чтобы завершить ввод поставьте '.' " << endl;
    char str[100];
    cin.getline(str, 100, '.');
    vpis.write(str, strlen(str) + 1);
    vpis.close();
}
```
`1.3` В функции, в которой происходит запись файла, граф будет записан в текстовый файл, созданным там, куда пользователь укажет путь в пункте `1.1`
```сpp
class Graph {
private:
    vector<vector<int>> graph;
    string rec;
}
```
`1.4` Для работы с графом создадим класс "Graph" создадим "private" поля:

`vector<vector<int>>` graph - представляющее собой сам граф

`string rec` - представляющее собой ссылку на файл с графом
```cpp
Graph(string rec = "") {
    this->rec = rec;
}
```
`1.5` Получим сслылку на файл с помощью конструктора класса( при желании можно воспользоваться им, однако в решении был использован метод `void SetRecord(string rec)`, так что это необязательный пункт и конструктор выполняет лишь номинальную функции конструктора по умолчанию)
```cpp
void SetRecord(string rec) {
    this->rec = rec;
    int leng = 0;
    int count = 0;
    vector<string> line;
    string linestr;
    ifstream record(rec);
    if (record.is_open()) {
        cout << "OK" << endl;
        while (getline(record, linestr)) {
            if (count >= 1)
                line.push_back(linestr);
            //cout << line[leng] << endl;
            leng++;
            count++;
        }
        for (auto iter = line.begin(); iter != line.end(); iter++)
        {
            RecordGraph(*iter);
        }
    }
    else {
        cout << "Not OK" << endl;
    }
    record.close();
}
```
`1.6` Получим сслылку на файл через ввод с клавиатуры. Проверим открылся ли файл. Построчно выведем строки из файла с графом в vector<string> line и циклом(разметом в колличество строк списка) пройдемся по `void RecordGraph(string line)`

```сpp
void RecordGraph(string line) {
    vector<int> rebra;
    int startPos = 2;
    int spacePos = line.find(' ', startPos);
    while (spacePos != string::npos) {
        string elstr = line.substr(startPos, spacePos - startPos);
        int el = stoi(elstr);
        startPos = spacePos + 1;
        spacePos = line.find(' ', startPos);
        rebra.push_back(el);
    }
    string elstr = line.substr(startPos, spacePos - startPos);
    int el = stoi(elstr);
    rebra.push_back(el);
    graph.push_back(rebra);

    /*for (auto i = rebra.begin(); i != rebra.end(); i++)
    {
        cout << *i << " ";
    }
    cout << endl;*/
}
```
`1.7` Из метода `void SetRecord(string rec)` перенесем строки списка смежности(vector<string> line) циклом в `vector<vector<int>> rebra`, а после присвоим их `vector<vector<int>> graph`, следовательно создадим ориентированные ребра кажной вершине, тем самым запижшем граф в программу.
```сpp
class Graph {
private:
    vector<vector<int>> graph;
    string rec;
}
```
---
### <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=29&pause=1000&color=255A26&random=false&width=435&lines=%D0%A7%D0%B0%D1%81%D1%82%D1%8C+2%2C+%D0%B2+%D1%87%D0%B5%D0%BC+%D1%81%D0%B8%D0%BB%D0%B0+%D0%B3%D1%80%D0%B0%D1%84%3F" alt="Typing SVG" /></a>

`2.1` Для проверки, является ли граф сильно связанным, можно использовать алгоритм Косарайю или алгоритм Тарьяна. 

Алгоритм Косарайю:
  * Выполните обход графа в глубину и запишите порядок обхода вершин.
  * Транспонируйте граф, т.е. поменяйте направление всех ребер.
  * Выполните обход графа в глубину, начиная с вершин в порядке, определенном на первом шаге.
  * Если при втором обходе графа в глубину все вершины достижимы из стартовой вершины, то граф сильно связанный.

Алгоритм Тарьяна:
  * Выполните обход графа в глубину и запишите порядок обхода вершин.
  * В каждой вершине запомните значение "времени выхода" (это время, когда обход достиг вершины и начал возвращаться назад).
  * Выполните обход графа в глубину, начиная с вершин в порядке, определенном на первом шаге, но выбирая следующую вершину только из непосещенных вершин с наибольшим временем выхода.
  * Если при втором обходе графа в глубину все вершины достижимы из стартовой вершины, то граф сильно связанный.

***В своем решении я воспользуюсь алгоритмом Касарайю***

---
```сpp
string StronglyСonnectivityСheck() {
    int length = graph.size();
    vector<bool> visit(length, false);
    dfs(visit, 0);
    for (int i = 0; i < length; i++)
    {
        if (!visit[i])
            return "Граф не связный";
    }
    if (TransposeTheGraph(length, visit))
        return "Граф сильно-связный";
    else return "Граф связный";
}
```
`2.2` В методе `string StronglyСonnectivityСheck()` запишем количество вершин в поле `int length` и создадим метод `vector<bool> visit(length, false)` где каждой вершине присвоено значение `false`. Циклом(разметом в колличество строк списка) 
```сpp
void dfs(vector<bool>& visit, int current_top) {
    visit[current_top] = true;
    for (int neighbour : graph[current_top])
    {
        if (!visit[neighbour])
            dfs(visit, neighbour);
    }
}
```
`2.3` методом `void dfs(vector<bool>& visit, int current_top)`, где dfs подразумевается как алгоритм "поиск в глубину”. Он работает по следуещему принципу:
* Заходим в одну из вершин
* Присваеваем `visit[current_top]` значение `true`, где `current_top` - выбранная вершина 
* Ищем соседей для вершины, тоесть те вершины к которым можно добрать по ребру от выбранной вершины
* Если `visit[current_top]` присвоено значение `false`
* Переходим в соседнюю вершину и она становиться `current_top` и возвращаемся ко второму пункту
* Если `visit[current_top]` присвоено значение `true`, ищем других соседей и проверяем какое значение `visit[current_top]` у них, где current_top` - вершина
* Если `visit[current_top]` присвоено значение `true` для всех соседних вершин, всех вершин до которых можно было добраться от начальной вершины   
```сpp
for (int i = 0; i < length; i++)
    {
        if (!visit[i])
            return "Граф не связный";
    }
```  
`2.4` Циклом(размером в количество вершин) проходимся по всем значениям `vector<bool> visit(length, false)`, если хотя бы одно из значений равно `false`, объявляем граф не связным.
```сpp
bool TransposeTheGraph(int& length, vector<bool>& visit) {
    vector<vector<int>> transosegraph(length);
    for (int i = 0; i < length; i++)
    {
        for (int neighbour : graph[i])
        {
            transosegraph[neighbour].push_back(i);
        }
    }
    fill(visit.begin(), visit.end(), false);
    dfs(visit, 0);
    for (int i = 0; i < length; i++)
    {
        if (!visit[i])
            return false;
    }
    return true;
}
```
`2.5` Транспонируем граф, присвоив каждой вершине в сторону которой ориентировано ребро, ребро направлено в сторону вершины из которого шло ребро и убрав предыдущие ребра. Тем самым мы получили новый, транспонированный граф.
Обнулим значение поля `vector<bool> visit(length, false)`, тоесть присвоим всем его элементам значение `false`  и перейдем в метод `void dfs(vector<bool>& visit, int current_top)`.
После снова циклом(размером в количество вершин) проходимся по всем значениям `vector<bool> visit(length, false)`, если хотя бы одно из значений равно `false`, объявляем граф слабо-связным( что делаем в методе `string StronglyСonnectivityСheck()`).
```сpp
string GetInfo() {
    string zapis1;
    int tryi = 0;
    for (auto it = graph.begin(); it != graph.end(); it++)
    {
        string zapis2;
        for (auto i = graph[tryi].begin(); i != graph[tryi].end(); i++)
        {
            zapis2 += " " + to_string(*i);
        }
        tryi++;
        zapis1 += to_string(tryi - 1) + " " + zapis2 + '\n';
    }
    cout << zapis1;
    return zapis1;
}
```
`2.6` Запишем список смежности в переменную `string zapis1`, состоящую из переменных `string zapis2`, в ктороные были записаны строки списка смежности. 
```сpp
Graph gr;
gr.SetRecord(rec);
gr.GetInfo();
cout << gr.StronglyСonnectivityСheck();
}
```
`2.7` Создадим переменную типа `Graph` (`Graph gr`), передадим классу сслыку и запишем граф в переменную через метод `gr.SetRecord(rec)`, выведем список смежности через метод `gr.GetInfo()`, определим вид графа через метод `gr.StronglyСonnectivityСheck()`

---
---
## TO ᗷE ᑕOᑎTIᑎᑌEᗪ...
**≋А≋ ≋с≋е≋й≋ч≋а≋с≋ ≋а≋н≋е≋к≋д≋о≋т≋**
---
---
 <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&size=35&pause=1000&color=661E1E&center=&vCenter=&multiline=true&repeat=&random=&width=435&lines=%D0%97%D0%B0%D1%81%D0%BB%D1%83%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9+%D0%B0%D0%BD%D0%B5%D0%BA%D0%B4%D0%BE%D1%82)" alt="Typing SVG" /></a>
 
<img src="https://readme-jokes.vercel.app/api" alt="Jokes Card" />
