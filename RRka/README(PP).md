![](https://komarev.com/ghpvc/?username=Kukrynitza)
# <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=33&pause=1000&color=5B1182&random=false&width=435&lines=%D0%A0%D0%B0%D1%81%D1%87%D0%B5%D1%82%D0%BD%D0%B0%D1%8F+%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0" alt="Typing SVG" /></a>

## <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=29&pause=1000&color=7D1CA9&background=37143F16&random=false&width=435&lines=%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5" alt="Typing SVG" /></a>

### <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=24&pause=1000&color=D740F7&random=false&width=435&lines=%D0%A6%D0%B5%D0%BB%D1%8C" alt="Typing SVG" /></a>
(っ◔◡◔)っ ♥ Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графам. ♥

---
### <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=24&pause=1000&color=D740F7&random=false&width=435&lines=%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5" alt="Typing SVG" /></a>
☆🎅 １.❼определить вид графа 
 сильно-связный граф (ориентированный граф)
способ задания графа - список смежности (список инцидентности) ♪🍩 

---
### <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=24&pause=1000&color=D740F7&random=false&width=435&lines=%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5+%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F" alt="Typing SVG" /></a>
【`Граф`　—　математическая　абстракция　реальной　системы　любой　природы，　объекты　которой　обладают　парными　связями．】

【`﻿Ориентированный　граф`　—　граф，　рёбрам　которого　присвоено　направление．】

【﻿`Список　смежности`　—　один　из　способов　представления　графа　в　виде　коллекции　списков　вершин．　Каждой　вершине　графа　соответствует　список，　состоящий　из　«соседей»　этой　вершины．】

【﻿`Сильно－связный　граф`　－　граф　в　котором　существует　（ориентированный）　путь　из　любой　вершины　в　любую　другую，　или，　что　эквивалентно，　граф　содержит　ровно　одну　сильно　связную　компоненту．】

---
### <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=24&pause=1000&color=D740F7&random=false&width=435&lines=%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D1%8B+%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2+" alt="Typing SVG" /></a>
**👊🐯  ❶. сильно-связный граф  🎁🏆**
| 0 | 2 | 3 | 4 |
|---|---|---|---|
| 1 | 1 | 4 | 0 |
| 2 | 4 | 0 | 1 |
| 3 | 0 | 3 |   |
| 4 | 2 |   |   |

![image](https://github.com/iis-32170x/RPIIS/assets/144555463/fa71597a-08b6-4276-8940-9c0526e38ba1)

**🐻  🎀  𝟤.Слабо-связный граф  🎀  🐻**
| 0 | 2 | 3 | 4 |
|---|---|---|---|
| 1 | 1 | 4 | 0 |
| 2 | 4 | 0 | 1 |
| 3 | 0 | 3 |   |
| 4 | 2 |   |   |

![image](https://github.com/iis-32170x/RPIIS/assets/144555463/6ebe2cb9-e847-42a0-998c-e59828c0da34)

**😂☞  ➂. не связный граф  💔🍫**
| 0 | 2 | 3 | 4 |
|---|---|---|---|
| 1 | 1 | 4 | 0 |
| 2 | 4 | 0 | 1 |
| 3 | 0 | 3 |   |
| 4 | 2 |   |   |

![image](https://github.com/iis-32170x/RPIIS/assets/144555463/bc43380f-6de3-4e0c-bbc9-77705dbbd1a7)

---
---

## <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=29&duration=5001&pause=1000&color=7D1CA9&background=37143F16&random=false&width=435&lines=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC+%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F" alt="Typing SVG" /></a>

### <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&weight=500&size=24&pause=1000&color=22973C&random=false&width=435&lines=1-%D0%B0%D1%8F+%D1%87%D0%B0%D1%81%D1%82%D1%8C%2C+%D0%B3%D1%80%D0%B0%D1%84" alt="Typing SVG" /></a>
```сpp
setlocale(LC_ALL, "RU");
string choise;
string rec;
cout << "Введите ссылку" << endl;
cin >> rec;
```
`1.1` Вводим ссылку на файл хранящий в себе список смежности 
```сpp
cout << "Будете записывать граф? Если да, напишите " << "yes" << endl;
cin >> choise;
if (choise == "yes")
    NeedsToBeWrittenInSomeoneNotebook(rec);
```
`1.2` Если задаем граф списком смежности с клавиатуры, вводим "yes",
а после переходим в функцию(NeedsToBeWrittenInSomeoneNotebook), в которой будет происходить запись нового графа 
```сpp
void NeedsToBeWrittenInSomeoneNotebook(string rec) {
    ofstream vpis(rec, ios_base::out);
    cout << "Будет записано сюда " << rec << endl << "Чтобы завершить ввод поставьте '.' " << endl;
    char str[100];
    cin.getline(str, 100, '.');
    vpis.write(str, strlen(str) + 1);
    vpis.close();
}
```
`1.3` В функции, в которой происходит запись файла, граф будет записан в текстовый файл, созданным там, куда пользователь укажет путь в пункте `1.1`
```сpp
class Graph {
private:
    vector<vector<int>> graph;
    string rec;
}
```
`1.4` Для работы с графом создадим класс "Graph" создадим "private" поля:

`vector<vector<int>>` graph - представляющее собой сам граф

`string rec` - представляющее собой ссылку на файл с графом
```cpp
Graph(string rec = "") {
    this->rec = rec;
}
```
`1.5` Получим сслылку на файл с помощью конструктора класса( при желании можно воспользоваться им, однако в решении был использован метод `void SetRecord(string rec)`, так что это необязательный пункт и конструктор выполняет лишь номинальную функции конструктора по умолчанию)
```cpp
void SetRecord(string rec) {
    this->rec = rec;
    int leng = 0;
    int count = 0;
    vector<string> line;
    string linestr;
    ifstream record(rec);
    if (record.is_open()) {
        cout << "OK" << endl;
        while (getline(record, linestr)) {
            if (count >= 1)
                line.push_back(linestr);
            //cout << line[leng] << endl;
            leng++;
            count++;
        }
        for (auto iter = line.begin(); iter != line.end(); iter++)
        {
            RecordGraph(*iter);
        }
    }
    else {
        cout << "Not OK" << endl;
    }
    record.close();
}
```
`1.6` Получим сслылку на файл через ввод с клавиатуры. Проверим открылся ли файл. Построчно выведем строки из файла с графом в vector<string> line и циклом(разметом в колличество строк списка) пройдемся по `void RecordGraph(string line)`

```сpp
void RecordGraph(string line) {
    vector<int> rebra;
    int startPos = 2;
    int spacePos = line.find(' ', startPos);
    while (spacePos != string::npos) {
        string elstr = line.substr(startPos, spacePos - startPos);
        int el = stoi(elstr);
        startPos = spacePos + 1;
        spacePos = line.find(' ', startPos);
        rebra.push_back(el);
    }
    string elstr = line.substr(startPos, spacePos - startPos);
    int el = stoi(elstr);
    rebra.push_back(el);
    graph.push_back(rebra);

    /*for (auto i = rebra.begin(); i != rebra.end(); i++)
    {
        cout << *i << " ";
    }
    cout << endl;*/
}
```
`1.7` Из метода `void SetRecord(string rec)` перенесем строки списка смежности(vector<string> line) циклом в `vector<vector<int>> rebra`, а после присвоим их `vector<vector<int>> graph`, следовательно создадим ориентированные ребра кажной вершине, тем самым запижшем граф в программу.
```сpp
class Graph {
private:
    vector<vector<int>> graph;
    string rec;
}
```
---



---
---
## TO ᗷE ᑕOᑎTIᑎᑌEᗪ...
**≋А≋ ≋с≋е≋й≋ч≋а≋с≋ ≋а≋н≋е≋к≋д≋о≋т≋**
---
---
 <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Italic&size=35&pause=1000&color=661E1E&center=&vCenter=&multiline=true&repeat=&random=&width=435&lines=%D0%97%D0%B0%D1%81%D0%BB%D1%83%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9+%D0%B0%D0%BD%D0%B5%D0%BA%D0%B4%D0%BE%D1%82)" alt="Typing SVG" /></a>
 
<img src="https://readme-jokes.vercel.app/api" alt="Jokes Card" />
