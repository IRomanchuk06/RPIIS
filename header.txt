#pragma once
#include <iostream>
#include <vector>

using namespace std;

struct Node {
    int l, r;  // Левая и правая границы отрезка
    int sum;   // Сумма чисел на отрезке
    int add;   // Значение, на которое нужно изменить элементы на отрезке
    Node* left;
    Node* right;

    Node(int left, int right) : l(left), r(right), sum(0), add(0), left(nullptr), right(nullptr) {}
};

class SumTree {
private:
    Node* root;

    void buildTree(Node* node, vector<int>& arr) {
        if (node->l == node->r) {
            node->sum = arr[node->l - 1];
            return;
        }

        int mid = (node->l + node->r) / 2;
        node->left = new Node(node->l, mid);
        node->right = new Node(mid + 1, node->r);

        buildTree(node->left, arr);
        buildTree(node->right, arr);

        node->sum = node->left->sum + node->right->sum;
    }

    void updateRange(Node* node, int left, int right, int value) {
        if (node->l > right || node->r < left) {
            // Отрезок не пересекается с запросом
            return;
        }

        if (node->l >= left && node->r <= right) {
            // Отрезок полностью содержится в запросе
            node->add += value;
            return;
        }

        propagate(node);

        updateRange(node->left, left, right, value);
        updateRange(node->right, left, right, value);

        node->sum = node->left->sum + node->right->sum;
    }

    int queryRange(Node* node, int left, int right) {
        if (node->l > right || node->r < left) {
            // Отрезок не пересекается с запросом
            return 0;
        }

        if (node->l >= left && node->r <= right) {
            // Отрезок полностью содержится в запросе
            return node->sum + (node->r - node->l + 1) * node->add;
        }

        propagate(node);

        int sumLeft = queryRange(node->left, left, right);
        int sumRight = queryRange(node->right, left, right);

        return sumLeft + sumRight;
    }

    void propagate(Node* node) {
        if (node->add != 0) {
            node->left->add += node->add;
            node->right->add += node->add;

            node->left->sum += (node->left->r - node->left->l + 1) * node->add;
            node->right->sum += (node->right->r - node->right->l + 1) * node->add;

            node->add = 0;
        }
    }

public:
    SumTree(vector<int>& arr) {
        int n = arr.size();
        root = new Node(1, n);
        buildTree(root, arr);
    }

    void modify(int left, int right, int value) {
        updateRange(root, left, right, value);
    }

    int query(int left, int right) {
        return queryRange(root, left, right);
    }
};
