# Расчетная работа 

## Введение

### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами.
### Задание
5.25 (Найти ребра с указанной степенью)

Реализовать на C++ код, который может найти ребра с укакзанной степенью.

Используется неориентированный граф.

Граф представляется в виде матрицы смежности.

### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Неориентированный граф` —  граф, рёбрам которого не присвоено направление.

`Матрица смежности(инцидентности)` - один из способов представления графа в виде матрицы, в которой — количество рёбер, соединяющих вершины и, причём при каждую петлю учитываем дважды, если граф не является ориентированным, и один раз, если граф ориентирован.

`Смежность` — понятие, используемое в отношении только двух рёбер либо только двух вершин: Два ребра, инцидентные одной вершине, называются смежными; две вершины, инцидентные одному ребру, также называются смежными. 

`Инцидентность` - вершина и ребро называются инцидентными, если вершина является для этого ребра концевой.

# Описание алгоритма

Исходный граф:

![image](https://github.com/iis-32170x/RPIIS/assets/147264756/9dde6a82-8d37-421e-b384-fbf9635d96f8)


Представим этот граф в виде списка смежности:


|   | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- |
| 1 | 0 | 0 | 1 | 0 | 1 |
| 2 | 0 | 0 | 0 | 0 | 0 |
| 3 | 1 | 0 | 0 | 1 | 0 |
| 4 | 0 | 1 | 0 | 0 | 0 |
| 5 | 1 | 0 | 0 | 0 | 0 |

Количество единиц в строке/столбце (т.к. граф неориентированный) матрицы смежности - это степень вершины.
Ищем все строки с количеством единиц равным необходимой степени.

## Реализация на C++

Код, выполняющий алгоритм находится здесь(https://github.com/iis-32170x/RPIIS/blob/%D0%9A%D0%BE%D0%B2%D0%B0%D0%BB%D0%B5%D0%B2%D0%B0_%D0%9C/%D1%80%D1%80/%D1%80%D1%80.cpp)

## Разбор кода:

- `#include <iostream>` - библиотека для ввода \ вывода

- `#include <vector>` - библиотека позволяющая использовать векторы

- `using namespace std` - подключение пространства имен `std`

- `class Graph {` - объявление класса `Graph`, при помощи которого список смежности(инцидентности), фактически в виде матрицы, будет сохраняться в памяти компьютера

    - ` int V;` - инициальзация переменной V, которая отвечает за количество вершин в графе

    - `vector<vector<pair<int, int>>> Listsmez;` - Объявляется вектор `Listsmesz`, который является вектором векторов пар целых чисел (`pair<int, int>`). Каждый элемент этого вектора представляет список смежных вершин для определенной вершины.

    - `Graph(int V) : V(V), Listsmez(V) {}` - Конструктор класса `Graph`, которому передаётся количество вершин `V` и создается `V` пустых списков смежности.

    - `void addV(int u, int v, int weight) {` - Объявление функции `addV`, которая добавляет ребра между вершинами `u` и `v` с заданным весом `weight`.

        - `Listsmesz[u].push_back(make_pair(v, weight));` - Добавляет вершину `v` в список смежности для вершины `u` с заданным весом `weight`.

        - `Listsmesz[v].push_back(make_pair(u, weight));` - Добавляет вершину `u` в список смежности для вершины `v` с заданным весом `weight`.

- `void Tree(Graph& graph) {` - Объявление функции `Tree`, которая находит дерево кратчайших путей.
    - `vector<bool> inTree(graph.V, false);` - Создается вектор `inTree` длиной `graph.V`, который инициализируется значениями `false`. В этом векторе отслеживается, является ли вершина частью дерева или нет.
      
    - `vector<int> key(graph.V, INT_MAX);` - Создается вектор `key` длиной `graph.V`, инициализированный максимальными значениями. Эти значения будут использоваться для хранения весов путей к вершинам.
      
    - `vector<int> parent(graph.V, -1);` - Создается вектор `parent` длиной `graph.V`, который хранит информацию о родительских вершинах в полученном дереве.
      
    - `key[0] = 0;` - вес пути к первой вершине.
      
    - `for (int count = 0; count < graph.V; count++) {` - "Цикл, который выполнятет итерации для каждой вершины графа.
      
        - `int minKey = INT_MAX;` - Переменная `minKey`  инициализируется максимальным значением. Эта переменная сравнивается с весом рёбер, инцидентным не включённым в дерево вершининам
          
        - `int u = -1;` - Переменная `u` инициализируется значением -1. Переменная отвечает за ту вершину, которая в даленейшем будет включена в дерево
     
        - `for (int v = 0; v < graph.V; ++v) {` - Внутренний цикл для перебора смежных вершин.
     
        - `if (!inTree[v] && key[v] < minKey) {` - Проверяется, не включена ли вершина в текущее дерево и не является ли ёё вес меньше текущего минимального веса.
     
            - `minKey = key[v]; u = v;` - Если выполнено условие, обновляются значения `minKey` и `u`.
         
            - `inTree[u] = true;` - Текущая вершина включается в дерево.
          
        - `for (auto& neighbor : graph.Listsmez[u]) {` - Внутренний цикл, который переберает все вершины смежные вершине `u`
     
        - `if (!inTree[neighbor.first] && neighbor.second < key[neighbor.first]) {` - В этой строке происходит проверка: является ли смежная вершина `neighbor.first` частью дерева мешьше ли вес ребра между вершиной `u` и `neighbor.first` чем текущий вес рёбер к вершине `neighbor.first`.
     
            - `parent[neighbor.first] = u; key[neighbor.first] = neighbor.second;` если условие выполнено, происходит обновление родительской вершины `parent[neighbor.first] = u;` и веса ребра к вершине `key[neighbor.first] = neighbor.second;`.
          
    - `for (int i = 1; i < graph.V; ++i) {
        cout << parent[i] << " - " << i << endl;
    } ` - Цикл вывода рёбер в консоль

После необходимо запросить у пользователя список смежности(инцидентности) и вывести результат в консоль
``` c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int VertexCount, EdgeCount;
    cout << "Enter the number of vertices and edges" << endl;
    cin >> VertexCount >> EdgeCount;

    vector<vector<int>> graph(VertexCount, vector<int>(VertexCount));

    cout << "Enter a and b" << endl;

    for (int i = 0; i < EdgeCount; i++)
    {
        int a, b;
        cin >> a >> b;
        a--;
        b--;
        graph[a][b] = 1;
        graph[b][a] = 1;
    }

    int degree;
    cout << "Enter the specific degree" << endl;
    cin >> degree;
    int k = 0;
    for (int i = 0; i < VertexCount; i++)

    {
        k = 0;
        for (int b = 0; b < VertexCount; b++)
        {
            if (graph[i][b] == 1) k++;
        }
         if (k == degree) cout << "Vertex " << i + 1 << " has degree " << degree << endl;
    }
    
}
```
## Тестирование
Результаты тестирования представлены тут()
