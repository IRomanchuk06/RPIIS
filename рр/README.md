# Расчетная работа 

## Введение

### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами.
### Задание
5.25 (Найти ребра с указанной степенью)

Реализовать на C++ код, который может найти ребра с укакзанной степенью.

Используется неориентированный граф.

Граф представляется в виде матрицы смежности.

### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Неориентированный граф` —  граф, рёбрам которого не присвоено направление.

`Матрица смежности(инцидентности)` - один из способов представления графа в виде матрицы, в которой — количество рёбер, соединяющих вершины и, причём при каждую петлю учитываем дважды, если граф не является ориентированным, и один раз, если граф ориентирован.

`Смежность` — понятие, используемое в отношении только двух рёбер либо только двух вершин: Два ребра, инцидентные одной вершине, называются смежными; две вершины, инцидентные одному ребру, также называются смежными. 

`Инцидентность` - вершина и ребро называются инцидентными, если вершина является для этого ребра концевой.

# Описание алгоритма

Исходный граф:

![image](https://github.com/iis-32170x/RPIIS/assets/147264756/9dde6a82-8d37-421e-b384-fbf9635d96f8)


Представим этот граф в виде списка смежности:


|   | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- |
| 1 | 0 | 0 | 1 | 0 | 1 |
| 2 | 0 | 0 | 0 | 0 | 0 |
| 3 | 1 | 0 | 0 | 1 | 0 |
| 4 | 0 | 1 | 0 | 0 | 0 |
| 5 | 1 | 0 | 0 | 0 | 0 |

Количество единиц в строке/столбце (т.к. граф неориентированный) матрицы смежности - это степень вершины.
Ищем все строки с количеством единиц равным необходимой степени.

## Реализация на C++

Код, выполняющий алгоритм находится здесь(https://github.com/iis-32170x/RPIIS/blob/%D0%94%D1%80%D0%B0%D0%BD%D1%8C%D0%BA%D0%BE_%D0%98/%D0%A0%D0%A0/Source.cpp)

## Разбор кода:
*Изначально программа была созданна для взвешенного графа, поэтому алгоритм находит дерево кратчайших путей учитывая вес рёбер. Однако при вызове функции вес рёбер задаётся константой равной 1, благодаря чему программа работает корректно.* 
- `#include <iostream>` - библиотека для ввода \ вывода

- `#include <vector>` - библиотека позволяющая использовать векторы

- `#include <utility>` - библиотека необходимая для использования пар объектов

- `using namespace std` - подключение пространства имен `std`

- `class Graph {` - объявление класса `Graph`, при помощи которого список смежности(инцидентности), фактически в виде матрицы, будет сохраняться в памяти компьютера

    - ` int V;` - инициальзация переменной V, которая отвечает за количество вершин в графе

    - `vector<vector<pair<int, int>>> Listsmez;` - Объявляется вектор `Listsmesz`, который является вектором векторов пар целых чисел (`pair<int, int>`). Каждый элемент этого вектора представляет список смежных вершин для определенной вершины.

    - `Graph(int V) : V(V), Listsmez(V) {}` - Конструктор класса `Graph`, которому передаётся количество вершин `V` и создается `V` пустых списков смежности.

    - `void addV(int u, int v, int weight) {` - Объявление функции `addV`, которая добавляет ребра между вершинами `u` и `v` с заданным весом `weight`.

        - `Listsmesz[u].push_back(make_pair(v, weight));` - Добавляет вершину `v` в список смежности для вершины `u` с заданным весом `weight`.

        - `Listsmesz[v].push_back(make_pair(u, weight));` - Добавляет вершину `u` в список смежности для вершины `v` с заданным весом `weight`.

- `void Tree(Graph& graph) {` - Объявление функции `Tree`, которая находит дерево кратчайших путей.
    - `vector<bool> inTree(graph.V, false);` - Создается вектор `inTree` длиной `graph.V`, который инициализируется значениями `false`. В этом векторе отслеживается, является ли вершина частью дерева или нет.
      
    - `vector<int> key(graph.V, INT_MAX);` - Создается вектор `key` длиной `graph.V`, инициализированный максимальными значениями. Эти значения будут использоваться для хранения весов путей к вершинам.
      
    - `vector<int> parent(graph.V, -1);` - Создается вектор `parent` длиной `graph.V`, который хранит информацию о родительских вершинах в полученном дереве.
      
    - `key[0] = 0;` - вес пути к первой вершине.
      
    - `for (int count = 0; count < graph.V; count++) {` - "Цикл, который выполнятет итерации для каждой вершины графа.
      
        - `int minKey = INT_MAX;` - Переменная `minKey`  инициализируется максимальным значением. Эта переменная сравнивается с весом рёбер, инцидентным не включённым в дерево вершининам
          
        - `int u = -1;` - Переменная `u` инициализируется значением -1. Переменная отвечает за ту вершину, которая в даленейшем будет включена в дерево
     
        - `for (int v = 0; v < graph.V; ++v) {` - Внутренний цикл для перебора смежных вершин.
     
        - `if (!inTree[v] && key[v] < minKey) {` - Проверяется, не включена ли вершина в текущее дерево и не является ли ёё вес меньше текущего минимального веса.
     
            - `minKey = key[v]; u = v;` - Если выполнено условие, обновляются значения `minKey` и `u`.
         
            - `inTree[u] = true;` - Текущая вершина включается в дерево.
          
        - `for (auto& neighbor : graph.Listsmez[u]) {` - Внутренний цикл, который переберает все вершины смежные вершине `u`
     
        - `if (!inTree[neighbor.first] && neighbor.second < key[neighbor.first]) {` - В этой строке происходит проверка: является ли смежная вершина `neighbor.first` частью дерева мешьше ли вес ребра между вершиной `u` и `neighbor.first` чем текущий вес рёбер к вершине `neighbor.first`.
     
            - `parent[neighbor.first] = u; key[neighbor.first] = neighbor.second;` если условие выполнено, происходит обновление родительской вершины `parent[neighbor.first] = u;` и веса ребра к вершине `key[neighbor.first] = neighbor.second;`.
          
    - `for (int i = 1; i < graph.V; ++i) {
        cout << parent[i] << " - " << i << endl;
    } ` - Цикл вывода рёбер в консоль

После необходимо запросить у пользователя список смежности(инцидентности) и вывести результат в консоль
``` c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int VertexCount, EdgeCount;
    cout << "Enter the number of vertices and edges" << endl;
    cin >> VertexCount >> EdgeCount;

    vector<vector<int>> graph(VertexCount, vector<int>(VertexCount));

    cout << "Enter a and b" << endl;

    for (int i = 0; i < EdgeCount; i++)
    {
        int a, b;
        cin >> a >> b;
        a--;
        b--;
        graph[a][b] = 1;
        graph[b][a] = 1;
    }

    int degree;
    cout << "Enter the specific degree" << endl;
    cin >> degree;
    int k = 0;
    for (int i = 0; i < VertexCount; i++)

    {
        k = 0;
        for (int b = 0; b < VertexCount; b++)
        {
            if (graph[i][b] == 1) k++;
        }
         if (k == degree) cout << "Vertex " << i + 1 << " has degree " << degree << endl;
    }
    
}
```
## Тестирование
Результаты тестирования представлены тут()
## Вывод
В результате я приобрёл следующие навыки:
- изучил основы теории графов
- изучил базовые алгоритмы для работы с графами
- изучил способы представления графов
- изучил базовые алгоритмы работы с векторами в C++
## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.
