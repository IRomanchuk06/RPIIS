# Работа с очередью в C++

При выполнении задания по работе с очередью вы будете использовать концепции и алгоритмы, связанные с основными операциями с очередью.

## Цель задания:
Цель задания заключается в освоении работы с очередью, включая вставку элемента в очередь и извлечение элемента из очереди.

## Концепции:
- **Очередь (Queue):**
  - Очередь представляет собой структуру данных, работающую по принципу FIFO (First In, First Out).
- **Вставка элемента (Enqueue) и извлечение элемента (Dequeue):**
  - Вставка элемента в очередь (enqueue) происходит путем добавления нового элемента в конец очереди.
  - Извлечение элемента из очереди (dequeue) осуществляется путем удаления элемента из начала очереди.

## Алгоритмы:
- **Алгоритм вставки в очередь:**
  - При использовании массива для реализации очереди, вставка элемента включает добавление элемента в конец массива.
  - При использовании связанного списка, вставка элемента подразумевает добавление нового узла в конец списка.
- **Алгоритм извлечения из очереди:**
  - Для извлечения элемента из очереди нужно удалить элемент из начала очереди и обновить указатель на начало очереди.
  - При использовании массива, извлечение может включать смещение всех элементов на одну позицию влево.
  - При использовании связанного списка, извлечение может включать удаление первого узла и обновление указателя на начало списка.

Эти концепции и алгоритмы помогут вам эффективно выполнять операции с очередью и понимать их применение в различных алгоритмах и приложениях.
## Пример работы с очередью на C++
# ([cpp](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%B4%D1%87%D0%B5%D0%BD%D0%BA%D0%BE_%D0%9D/sem%202/%D0%9F%D0%98%D0%9E%D0%98%D0%92%D0%98%D0%A1%20%D0%BB%D0%B0%D0%B11.cpp).файл)
# ([header](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%B4%D1%87%D0%B5%D0%BD%D0%BA%D0%BE_%D0%9D/sem%202/%D0%9F%D0%98%D0%9E%D0%98%D0%92%D0%98%D0%A1%20%D0%BB%D0%B0%D0%B11.h).файл)
```cpp
#include<iostream>
#include <conio.h>
#include<string>
#include "ПИОИВИС лаб1.h"
#include <vector>
using namespace std;

MyQueue::MyQueue() {
    last = begin = nullptr;
}

MyQueue::~MyQueue() {
    while (begin != nullptr) {
        QueueElement* tmp = begin;
        begin = begin->prev;
        delete tmp;
    }
}

bool MyQueue::Check() {
    return (begin == nullptr);
}

void MyQueue::Push(std::string information) {
    QueueElement* tmp = new QueueElement;
    tmp->inf = information;
    tmp->prev = nullptr;

    if (begin == nullptr) {
        begin = last = tmp;
    }
    else {
        last->prev = tmp;
        last = tmp;
    }
}

void MyQueue::View() {
    QueueElement* tmp = begin;
    while (tmp != nullptr) {
        std::cout << "(" << tmp->inf << ") ";
        tmp = tmp->prev;
    }
    if (begin != nullptr) {
        std::cout << "<- хвост очереди";
    }
    std::cout << "\nнажмите любую клавишу, чтобы выйти из просмотра : ";
    while (!_kbhit()) {
    }
    _getch();
    system("cls");
}

std::string MyQueue::Pop() {
    if (Check()) {
        std::string popinf;
        return popinf;
    }
    else {
        std::string popinf = begin->inf;
        QueueElement* tmp = begin;
        begin = begin->prev;
        delete tmp;
        return popinf;
    }
}

void MyQueue::HeadElemenetToTail() {
    std::vector <std::string> infomation = { "молоко","хлеб","мука","сырок","вода","батон" };
    for (auto& c : infomation) {
        Push(c);
    }
    std::cout << "Очередь : ";
    View();
    Push(Pop());
    std::cout << "Переделанная очередь : ";
    View();
}

int main() {
    setlocale(LC_ALL, "ru");
    MyQueue queue;
    int choice = 0, choice2 = 0, choice3 = 0, choice4 = 0;
    string elm;
    string popinf;
    do {
        cout << "Выберите действие\n"
            << "1.Перейти к обычному меню\n"
            << "2.Перейти к методу перемещающему элемент из головы очереди в хвост\n";
        getline(cin, elm);
        if (elm.size() == 1) {
            if (elm[0] == '1') {
                choice4 = 1;
            }
            else if (elm[0] == '2') {
                choice4 = 2;
            }
        }
        system("cls");
        elm.clear();
    } while (choice4 == 0);
    if (choice4 == 1) {
        // Обычное меню
        do {
            do {
                choice = 0;
                cout << "Выберите действие\n"
                    << " 1.Добавление\n"
                    << " 2.Взятие элемента\n"
                    << " 3.Просмотр очереди\n"
                    << " 4.Выйти"
                    << endl;
                getline(cin, elm);
                if (elm.size() == 1) {
                    if (isdigit(elm[0])) {
                        choice = stoi(elm);
                    }
                }
                system("cls");
                elm.clear();
            } while (choice == 0);
            switch (choice) {
            case 1:
                // Добавление элементов в очередь
                do {
                    system("cls");
                    do {
                        cout << "Введите информацию : ";
                        getline(cin, elm);
                        system("cls");
                    } while (elm.empty());
                    queue.Push(elm);
                    elm.clear();
                    do {
                        choice2 = 0;
                        cout << "Выберите действие\n"
                            << " 1.Добавить еще\n"
                            << " 2.Больше не добавлять\n"
                            << endl;
                        getline(cin, elm);
                        if (elm.size() == 1) {
                            if (elm[0] == '1') {
                                choice2 = 1;
                            }
                            else if (elm[0] == '2') {
                                choice2 = 2;
                            }
                        }
                        system("cls");
                        elm.clear();
                    } while (choice2 == 0);
                } while (choice2 != 2);
                break;
            case 2:
                // Извлечение элемента из очереди
                popinf = queue.Pop();
                if (!popinf.empty()) {
                    do {
                        choice3 = 0;
                        cout << "Выберите действие \n"
                            << "1.Добавить взятый элемент в конец очереди \n"
                            << "2.Удалить взятый элемент\n"
                            << endl;
                        getline(cin, elm);
                        if (elm.size() == 1) {
                            if (elm[0] == '1') {
                                choice3 = 1;
                            }
                            else if (elm[0] == '2') {
                                choice3 = 2;
                            }
                        }
                        system("cls");
                        elm.clear();
                    } while (choice3 == 0);
                    system("cls");
                    switch (choice3) {
                    case 1:
                        // Добавление извлеченного элемента в конец очереди
                        queue.Push(popinf);
                        cout << "Элемент добавлен в конец очереди ";
                        cout << "\nнажмите любую клавишу, чтобы продолжить : ";
                        while (!_kbhit()) {
                        }
                        _getch();
                        system("cls");
                        break;
                    case 2:
                        // Удаление извлеченного элемента
                        cout << "элемент был удален";
                        cout << "\nнажмите любую клавишу, чтобы продолжить : ";
                        while (!_kbhit()) {
                        }
                        _getch();
                        system("cls");
                        break;
                    default: cout << "Неправильный выбор \n";
                    }
                }
                else {
                    cout << "очередь пустая";
                    cout << "\nнажмите любую клавишу, чтобы продолжить : ";
                    while (!_kbhit()) {
                    }
                    _getch();
                    system("cls");
                }
                break;
            case 3:
                // Просмотр очереди
                cout << "Очередь : ";
                queue.View();
                break;
            case 4:
            {
                break;
            }
            default:cout << "Неправильный выбор\n";
            }
        } while (choice != 4);
    }
    else {
        // Вызов метода перемещения элемента из головы в хвост
        queue.HeadElemenetToTail();
    }
    return 0;
}
```
## Алгоритм работы программы

### Определение класса MyQueue:
- В классе `MyQueue` определены приватные элементы `last` и `begin`, представляющие последний и первый элементы очереди соответственно.
- В классе определена структура `QueueElement`, которая представляет собой элемент очереди.

### Конструктор и деструктор класса `MyQueue`:
- Конструктор класса `MyQueue` инициализирует указатели `last` и `begin` как `nullptr`.
- Деструктор освобождает память, выделенную для элементов очереди.

### Методы `Push`, `Pop`, `View`:
- Метод `Push` добавляет элемент в конец очереди.
- Метод `Pop` извлекает элемент из начала очереди.
- Метод `View` выводит содержимое очереди на экран.

### Функция `main()`:
- В функции `main()` создается объект класса `MyQueue`.
- В цикле `do-while` пользователю предлагается выбрать действие (добавление, извлечение, просмотр очереди или выход).
- В зависимости от выбора пользователя выполняются соответствующие операции с очередью.
- Для добавления элемента в конец очереди используется цикл `do-while`.
- После каждого действия пользователю предлагается выбрать следующее действие.
- Пользователь может выйти из программы, выбрав соответствующий пункт меню.
  # Работа с очередью,вывод

Очередь - это структура данных, в которой элементы упорядочены по принципу "первым пришел, первым вышел" (FIFO - First-In-First-Out). Это означает, что элементы добавляются в конец очереди и удаляются из ее начала.

## Операции с очередью

### Вставка элемента в очередь

Для вставки элемента в очередь вы используете операцию, которая называется "enqueue" или "встать в очередь". Элемент добавляется в конец очереди. Если очередь заполнена, то возможно ожидание, пока место в очереди не освободится.

### Взятие элемента из очереди

Для взятия элемента из очереди вы используете операцию, которая называется "dequeue" или "выйти из очереди". Элемент извлекается из начала очереди. Если очередь пуста, то операция извлечения может привести к ошибке или вернуть специальное значение, указывающее на пустую очередь.



