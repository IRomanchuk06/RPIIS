# Расчетная работа 


## Введение

### Цель

Изучить основы теории графов, определить число вершинной связности орграфа

### Задание
(2.6 Найти число вершинных связностей)

Реализовать на C++ код, который может определить число вершинной связности в графе

Графы представляются в виде матрицы инцидентности.

Поскольку по условию не сказано какой должен быть формат вывода, будет считаться, что результат работы программы будет выводится в файл output.txt.


### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Ориентированный граф (кратко орграф)` — граф, рёбрам которого присвоено направление.

 `Матрица инцидентности` - это логическая матрица, которая показывает взаимосвязь между двумя классами объектов, обычно называемую отношением инцидентности.

 `Поиск в глубину (Depth-first search, DFS)` — один из методов обхода графа.

 `Ребро` - неупорядоченная пара двух вершин, которые связаны друг с другом.

 ## Алгоритм решения

1.Запускаем поиск в глубину от любой вершины, помечаем как посещенную.

2.Идем по горизонтали матрицы и ищем ребро, связанное с этой вершиной.

3.Если не нашли, запускаем поиск от следующей вершины(если та не посещена).

4.Ищем все смежные ей вершины проходя по-вертикали матрицы. Если находим элемент, это значит, что они связаны. 

5.Запускаем поиск в глубину от найденной вершины(1). 

Так же заведем счетчик, который будет подсчитывать число вершинных связностей. Если мы обошли граф, и у нас остались непосещенные выршины, это значит, что граф состоит из нескольких компонент связности. Число этих компонентов будет равно числу запуска обходов в глубину(исключая те, что были запущены в самом обходе)

## Реализация на С++

```
#include <iostream>
#include <vector>
#include <fstream>
#include <string>
using namespace std;

void dfs(vector<vector<int>>& graph, int v, vector<int>& visited, int n, int m) {
	visited[v] = 1;
	
	for (int i = 0; i < n; i++) {
		if (graph[v][i] == 1 || graph[v][i] == -1) {
			for (int j = 0; j < m; j++) {
				if ((graph[j][i] == 1 && !visited[j]) || (graph[j][i] == -1 && !visited[j])) {
					dfs(graph, j, visited, n, m);
				}
			}
		}
	}
}


int main() {

	string line;
	cout << "Введите файл: ";
	cin >> line;
	ifstream inputFile(line);
	ofstream outputFile("output.txt");
	int vertexCount, edgeCount;
	inputFile >> vertexCount >> edgeCount;
	
	vector<vector<int>> graph(vertexCount, vector<int>(vertexCount));

	for (int i = 0; i < edgeCount; i++) {
		int a, b;
		inputFile >> a >> b;
			a--;
			b--;
			graph[a][i] = 1;
			graph[b][i] = -1;
	}
	inputFile.close();

	int numConnectedComponents = 0;	
	vector<int> visited(vertexCount, 0);
	
	for (int i = 0; i < vertexCount; i++) {
		if (!visited[i]) {
			dfs(graph, i, visited, edgeCount, vertexCount);
			numConnectedComponents++;
		}
	}

	
	outputFile << "Число компонент связности: " << numConnectedComponents << endl;
	outputFile.close();
	return 0;
}
```

## Разбор кода:
- `#include <vector>` и `#include <fstream>`: библиотеки , которые предоставляют возможность использовать вектор и файлы. 
- `void dfs(vector<vector<int>>& graph, int v, vector<int>& visited, int n, int m)` функция поиска в глубину, которая принимает граф, текущую вершину, список посещенных вершин, количество вершин, количество ребер
- `visited[v] = 1;
	for (int i = 0; i < n; i++) {
		if (graph[v][i] == 1 || graph[v][i] == -1) {
			for (int j = 0; j < m; j++) {
				if ((graph[j][i] == 1 && !visited[j]) || (graph[j][i] == -1 && !visited[j])) {
					dfs(graph, j, visited, n, m);` главный алгоритм поиска, описанный [здесь](#алгоритм-решения)

 - `string line;
	cout << "Введите файл: ";
	cin >> line;
	ifstream inputFile(line);
	ofstream outputFile("output.txt");
	int vertexCount, edgeCount;
	inputFile >> vertexCount >> edgeCount;` берём количество вершин и ребер из файла

- `for (int i = 0; i < edgeCount; i++) {
		int a, b;
		inputFile >> a >> b;
			a--;
			b--;
			graph[a][i] = 1;
			graph[b][i] = -1;
	}
	inputFile.close(); ` представляем граф в виде матрицы инцидентности

- `for (int i = 0; i < vertexCount; i++) {
		if (!visited[i]) {
			dfs(graph, i, visited, edgeCount, vertexCount);
			numConnectedComponents++;
		}
	}` цикл для перебора всех вершин, если остались непосещенные
- `outputFile << "Число компонент связности: " << numConnectedComponents << endl;` выводим результат в файл output.txt

## Примеры
Примеры выполнения программы можно посмотреть [здесь](https://github.com/iis-32170x/RPIIS/tree/Титов_А/РР/Примеры)
 ## Вывод
 
В результате выполнения расчётной работы приобрёл следующие навыки:
- изучил основы теории графов
- изучил способы представления графов
- изучил базовые алгоритмы для работы с графами
- изучил базовые алгоритмы работы с векторами и файлами в C++

## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.

[7] База знаний по теории графов OSTIS GT [Электронный ресурс] / проект OSTIS, 2012. –
Режим доступа: http://ostisgraphstheo.sourceforge.net. — Дата доступа : 11.09.2012.
