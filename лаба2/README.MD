# Лабораторная работа №2
- `Цель` - нахождение булеана любого множества
- `Задача` - реализовать алгоритм создания булеана исходного множества
- `Вариант` - $\textcolor{grey}{\textit{5}}$
## Список ключевых понятий (определения)
- `Булеан` множества, также известный как множество подмножеств или множество всех подмножеств, определяется как множество, содержащее все возможные подмножества данного исходного множества.

- `Элментом множества` может являться буквольный символ, число, кортеж, отдельное множество, пустое множество, сочетание буквы и числа.
## Алгоритм 
Данный код состоит из двух функций и основной части программы.Разберем каждую часть по отдельности
### Функция parse_set(input_set):
```python
ef parse_set(input_set):
input_set = input_set.strip()
if not input_set.startswith('{') or not input_set.endswith('}'):
raise ValueError("Множество должно быть заключено в фигурные скобки.")


input_set = input_set[1:-1]  # Удаление первой и последней скобки
elements = set()
stack = []
current_element = ""

for char in input_set:
    if char == ',' and not stack:
        elements.add(current_element.strip())
        current_element = ""
    elif char == ' ':
        raise ValueError("Между элементами множества должна быть запятая.")
    elif char == '{':
        stack.append('{')
        current_element += char
    elif char == '}':
        if not stack or stack[-1] != '{':
            raise ValueError("Некорректная закрывающая скобка '}'.")
        stack.pop()
        current_element += char
    elif char == '<':
        stack.append('<')
        current_element += char
    elif char == '>':
        if not stack or stack[-1] != '<':
            raise ValueError("Некорректная закрывающая скобка '>'.")
        stack.pop()
        current_element += char
    else:
        current_element += char

if current_element.strip():
    elements.add(current_element.strip())

if stack:
    raise ValueError("Некорректное количество открывающих и закрывающих скобок.")

return elements
```
- input_set = input_set.strip() - Удаляет пробелы с начала и конца входной строки.
- if not input_set.startswith('{') or not input_set.endswith('}'): - Проверяет, что строка начинается с символа '{' и заканчивается символом '}'. Если это не так, выбрасывается исключение ValueError с сообщением "Множество должно быть заключено в фигурные скобки."
- input_set = input_set[1:-1] - Удаляет первый и последний символ (фигурные скобки) из входной строки.
- elements = set() - Создает пустое множество для хранения элементов.
- stack = [] - Создает пустой стек для отслеживания открывающих и закрывающих скобок.
- current_element = "" - Создает пустую строку для хранения текущего элемента. 
- Затем следует цикл for char in input_set:, который перебирает каждый символ во входной строке.
- if char == ',' and not stack: - Если текущий символ является запятой (',') и стек пустой, то это значит, что мы достигли конца текущего элемента. Текущий элемент добавляется в множество elements, предварительно удалив пробелы с его начала и конца. Затем строка current_element очищается.
- elif char == ' ': - Если текущий символ является пробелом, выбрасывается исключение ValueError с сообщением "Между элементами множества должна быть запятая."
- elif char == '{': - Если текущий символ является открывающей фигурной скобкой ('{'), он добавляется в стек и в текущий элемент.
- elif char == '}': - Если текущий символ является закрывающей фигурной скобкой ('}'), проверяется, что стек не пустой и верхний элемент стека равен открывающей фигурной скобке ('{'). Если это не так, выбрасывается исключение ValueError с сообщением "Некорректная закрывающая скобка '}'."
- elif char == '<': - Если текущий символ является открывающей угловой скобкой ('<'), он добавляется в стек и в текущий элемент.
- elif char == '>': - Если текущий символ является закрывающей угловой скобкой ('>'), проверяется, что стек не пустой и верхний элемент стека равен открывающей угловой скобке ('<'). Если это не так, выбрасывается исключение ValueError с сообщением "Некорректная закрывающая скобка '>'."
- else: - В противном случае, текущий символ добавляется в текущий элемент.
### Функция powerset(s) (Формирование булеана множества):
```python
def powerset(s):
n = len(s)
masks = [1 << i for i in range(n)]
for i in range(2**n):
yield {x for mask, x in zip(masks, s) if i & mask
```
- n = len(s) - Вычисляет длину входного множества s.
- masks = [1 << i for i in range(n)] - Создает список масок, где каждая маска представляет собой число, у которого установлен только один бит в позиции i.
- for i in range(2**n): - Цикл, который перебирает все числа от 0 до 2^n - 1.
- yield {x for mask, x in zip(masks, s) if i & mask} - Генерирует подмножество x из множества s на основе текущего значения i и соответствующих масок. Каждое подмножество возвращается с помощью оператора yield, что позволяет использовать эту функцию в качестве генератора.
## Основная часть программы:
```python
filename = input("Введите имя файла: ")
with open(filename, 'r') as file:
input_set = file.read().strip()

try:
result = parse_set(input_set)
boolean_set = list(powerset(result))
print("Булеан множества:")
for i, subset in enumerate(boolean_set, start=1):
print(f"Подмножество {i}: {subset if subset else '{{}}'}")
except ValueError as e:
print(f"Ошибка: {str(e)}")
```
- filename = input("Введите имя файла: ") - Запрашивает у пользователя ввод имени файла.
- with open(filename, 'r') as file: - Открывает указанный файл в режиме чтения и присваивает его объект переменной file.
- input_set = file.read().strip() - Читает содержимое файла и удаляет пробелы с начала и конца строки.
- try: - Начало блока try-except, где обрабатывается возможное исключение.
- result = parse_set(input_set) - Вызывает функцию parse_set для обработки входного множества input_set и присваивает результат переменной result.
- boolean_set = list(powerset(result)) - Создает список boolean_set, который содержит все подмножества множества result, полученные с помощью функции powerset.
- print("Булеан множества:") - Выводит на экран сообщение "Булеан множества:".
- for i, subset in enumerate(boolean_set, start=1): - Цикл, который перебирает все подмножества в списке boolean_set с помощью функции enumerate. Каждое подмножество присваивается переменной subset, а его индекс (начиная с 1) присваивается переменной i.
- print(f"Подмножество {i}: {subset if subset else '{{}}'}") - Выводит на экран информацию о каждом подмножестве. Если подмножество пустое, выводится символ '{{}}'.
- except ValueError as e: - Если возникает исключение типа ValueError, оно перехватывается и присваивается переменной e.
- print(f"Ошибка: {str(e)}") - Выводит на экран сообщение об ошибке, полученное из исключения.
