# Лабораторная работа №1 (Вариант 28)

- `Цель` - Закодировать текст с помощью кодов Хаффмана

## Список ключевых понятий (определения) ❓
- `Алгоритм Хаффмана`  - жадный алгоритм оптимального префиксного кодирования алфавита с минимальной избыточностью.
Идея, положенная в основу кодировании Хаффмана, основана на частоте появления символа в последовательности. Символ, который встречается в последовательности чаще всего, получает новый очень маленький код, а символ, который встречается реже всего, получает, наоборот, очень длинный код. Это нужно, так как мы хотим, чтобы, когда мы обработали весь ввод, самые частотные символы заняли меньше всего места (и меньше, чем они занимали в оригинале), а самые редкие — побольше (но так как они редкие, это не имеет значения). Для нашей программы я решил, что символ будет иметь длину 8 бит, то есть, будет соответствовать печатному знаку.

# Алгоритм работы программы

1. **Пользователю предлагается ввести строку для кодировки.**
2. **Строка преобразуется в вектор частот, где каждый индекс соответствует символу ASCII, а значение - его частоте в строке.**
3. **Создаются узлы для каждого символа с ненулевой частотой.**
4. **Узлы сортируются по возрастанию частоты.**
5. **Из узлов строится бинарное дерево Хаффмана.**
6. **Происходит обход дерева и выводится код для каждого символа.**


## Код

``` C++
#include <iostream>
#include <vector>

using namespace std;

struct Node {
    char symbol;
    int count;
    Node* left;
    Node* right;
};

Node* create(char c, int n) {
    Node* newNode = new Node();
    newNode->symbol = c;
    newNode->count = n;
    newNode->left = nullptr;
    newNode->right = nullptr;
    return newNode;
}

void Chastota(const string& str, vector<int>& freq) {
    for (char c : str) {
        freq[c]++;
    }
}

void print(Node* root, string prefix) {
    if (root == nullptr) {
        return;
    }

    if (root->symbol != '\0') {
        cout << root->symbol << ": " << prefix << endl;
        return;
    }

    print(root->left, prefix + "0");
    print(root->right, prefix + "1");
}

int main() {
    string str;
    cout << "Введите строку для кодировки: ";
    getline(cin, str);

    vector<int> freq(256, 0);

    Chastota(str, freq);

    vector<Node*> nodes;

    // Создаем узлы
    for (int i = 0; i < 256; i++) {
        if (freq[i] > 0) {
            nodes.push_back(create((char)i, freq[i]));
        }
    }

    while (nodes.size() > 1) {
        int min1 = str.length(), min2 = str.length();
        int i1 = -1, i2 = -1;

        for (int i = 0; i < nodes.size(); i++) {
            if (nodes[i]->count < min1) {
                min1 = nodes[i]->count;
                i1 = i;
            } else if (nodes[i]->count < min2) {
                min2 = nodes[i]->count;
                i2 = i;
            }
        }

        // родительский узел с объединенной частотой
        Node* parent = new Node();
        parent->symbol = '\0';
        parent->count = min1 + min2;
        parent->left = nodes[i1];
        parent->right = nodes[i2];

        nodes.erase(nodes.begin() + i1);
        nodes.erase(nodes.begin() + i2 - 1);
        nodes.push_back(parent);
    }

    Node* root = nodes[0];

    print(root, "");

    return 0;
}
```

## Пример запуска
<img width="343" alt="Снимок экрана 2024-05-12 в 16 34 26" src="https://github.com/iis-32170x/RPIIS/assets/105926921/585b38da-a4fa-41e8-ad09-59ea1f7e808f">


## Вывод
Этот код реализует алгоритм кодирования Хаффмана для строки, введенной пользователем. Он подсчитывает частоту каждого символа в строке и использует ее для построения дерева Хаффмана. Затем он выводит символы и соответствующие им коды Хаффмана на экран. Код создает структуры узлов для дерева и использует вектор для их хранения и обработки. Этот алгоритм эффективно сжимает данные, присваивая более короткие коды символам с более высокой частотой встречаемости.
