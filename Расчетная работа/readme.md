# Расчетная работа

## Введение
---
### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами.
### Задание
5.2 Найти эйлеров цикл в графе 

Реализовать на C++ код, который может найти эйлеров цикл в неориентированном графе.

Граф представляется в виде матрицы смежности.

### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Неориентированный граф (кратко орграф)` — это тип графа, в котором рёбра (или связи) между вершинами не имеют направления.

`Матрица смежности` - это способ представления графа в виде квадратной матрицы, где строки и столбцы представляют вершины графа, а значения в ячейках показывают наличие или отсутствие ребра между соответствующими вершинами.

`Путь в графе` – это последовательность рёбер, в которой конец каждого ребра (кроме последнего) совпадает с началом следующего.
Замкнутый путь называется `циклом`. 

`Эйлеров цикл` — это путь в графе, который проходит через каждое ребро ровно один раз и возвращается в начальную вершину. Эйлеров цикл существует только в графах, где все вершины имеют четную степень (количество инцидентных рёбер).

`Эйлеров путь` — это путь в графе, который проходит через каждое ребро ровно один раз. Однако, в отличие от Эйлерова цикла, Эйлеров путь не обязательно начинается и заканчивается в одной и той же вершине.

`Поиск в глубину (Depth-First Search, DFS)` — это один из основных алгоритмов обхода или поиска в графе. Он работает путем последовательного исследования каждой вершины и всех её потомков, находящихся на одном уровне, перед переходом к следующему уровню.

Графический пример обхода в ширину:

![image](https://intuit.ru/EDI/28_11_18_2/1543357168-6234/tutorial/909/objects/44/files/44_05.png)

## Алгоритм решения

Получаем и преобразуем матрицу смежности неориентированного графа (2 способа задания: файлом, с клавиатуры)

Проверяем основыные требования к эйлеровому графу: связность и четные степени всех вершин. Если условия не выполняются, то и смысла продолжнать программу нет, а значит в таком случае можем ее досрочно завершить.

Запускаем поиск в глубину, который учитывает пройденные вершины, помечая их в отдельном списке, и наличие связей, сравнивая значения в матрице смежности. DFS проходит по всем вершинам, а если выхода из вершины нет, то он делает шаг назад и перемещает вершину, из которой выхода нет, в эйлеров цикл. В результате мы получаем список, в котором находится эйлеров цикл.

Если эйлеров цикл обнаружен, мы выводим его, а также его длину, на экран. В противном случае выводим сообщение "The graph does not contain an euler's cycle.".

_Приведем приме выполнения алгоритма:_

Исходный граф:

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%BE%D0%BC%D0%B0%D0%BD%D1%87%D1%83%D0%BA_%D0%98/%D0%A0%D0%B0%D1%81%D1%87%D0%B5%D1%82%D0%BD%D0%B0%D1%8F%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0/EulersGraph10.jpg?raw=true)

Исходная матрица смежности:

![image]

Теперь представим этот граф в виде списка смежности:

> - `0 -> 1`
> - `1 -> 2`
> - `1 -> 3`
> - `2 -> 3` 
> - `3 -> 0`

1. Начинаем с вершины 0:

- Добавляем вершину 0 в очередь с расстоянием 0.

- Распространяемся по смежным вершинам: добавляем вершину 1 в очередь с расстоянием 1.

2. Переходим к вершине 1:

- Распространяемся по смежным вершинам: добавляем вершины 2 и 3 в очередь с расстоянием 2.

- Обнаруживаем, что смежная вершина 3 смежна с начальной вершиной 0, обновляем минимальное расстояние до цикла = 3.

3. Переходим к вершине 2:

- Распространяемся по смежным вершинам: добавляем вершину 3 в очередь с расстоянием 3.

- Обнаруживаем, что смежная вершина 3 смежна с начальной вершиной 0, но расстояние 4 больше минимального, поэтому не обновляем минимальное расстояние.

4. Переходим к вершине 3:

- Распространяемся по смежной вершине 0, но она уже была посещена, поэтому не добавляем в очередь.

Таким образом, минимальная длина цикла в данном графе равна 3 (0 -> 1 -> 3 -> 0).

## Реализация на C++

Код, выполняющий наш алгоритм:

```c++
#include <iostream>
#include <fstream>
#include <vector>
#include <queue>
using namespace std;

int shortestCycle(vector<vector<int>>& adjList, int numberofsize) {
    int minCycle = numberofsize + 1;

    for (int i = 0; i < numberofsize; i++) {
        vector<bool> visited(numberofsize, false);
        queue<pair<int, int>> uslqueue;
        uslqueue.push({ i, 0 });

        while (!uslqueue.empty()) {
            int cur = uslqueue.front().first;
            int dist = uslqueue.front().second;
            uslqueue.pop();

            for (int neighbor : adjList[cur]) {
                if (neighbor == i) {
                    minCycle = min(minCycle, dist + 1);
                }
                else if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    uslqueue.push({ neighbor, dist + 1 });
                }
            }
        }
    }

    if (minCycle == numberofsize + 1) {
        return -1;
    }
    else {
        return minCycle;
    }
}

int main() {
    setlocale(LC_ALL, "ru");
    string line;
    cout << "Введите файл: ";
    cin >> line;
    ifstream inputFile(line);
    ofstream outputFile("obhvat.txt");
    int numberof_usl, numberof_rebr;
    inputFile >> numberof_usl >> numberof_rebr;


    vector<vector<int>> adjList(numberof_usl);
    for (int i = 0; i < numberof_rebr; i++) {
        int usl, s_usl;
        inputFile >> usl >> s_usl;
        usl--, s_usl--;
        adjList[usl].push_back(s_usl);
    }
    inputFile.close();

    int cycleLength = shortestCycle(adjList, numberof_usl);
    if (cycleLength == -1) {
        outputFile << "Обхват графа: бесконечность" << endl;
    }
    else {
        outputFile << "Обхват графа: " << cycleLength << endl;
    }

    outputFile.close();
    return 0;
}
```

## Разбор кода:

- `#include <vector>`, `#include <fstream>` и `#include <queue>`: библиотеки , которые предоставляют возможность использовать векторы, файлы и очереди.
- `int shortestCycle(vector<vector<int>>& adjList, int numberofsize)`: Объявление функции shortestCycle, которая принимает ссылку на вектор векторов adjList и целочисленное значение n, обозначающее количество вершин в графе. Функция возвращает целочисленное значение - длину кратчайшего цикла в графе, либо -1, если цикл отсутствует.
- `for (int i = 0; i < numberofsize; i++)` : Цикл, в котором происходит перебор всех вершин графа. Внутри этого цикла будет запущен поиск кратчайшего цикла из каждой вершины:
  -   `vector<bool> visited(numberofsize, false) `: Объявление вектора visited размером n, которая будет использоваться для отслеживания посещенных вершин во время обхода графа.
  - `queue<pair<int, int>> q`: Объявление очереди q с элементами типа pair<int, int>, где первый элемент - вершина графа, а второй - расстояние от начальной вершины.
  - `q.push({ i, 0 })`: Добавление начальной вершины i в очередь q с расстоянием 0.
  - `while (!q.empty())`: Цикл, который будет выполняться, пока очередь не станет пустой. Здесь происходит обход графа в ширину (BFS) из текущей вершины:
     - `int cur = q.front().first`: Извлечение текущей вершины из очереди.
     -  `int dist = q.front().second `: Извлечение расстояния от начальной вершины до текущей вершины.
     -   `q.pop()`: Очищение очереди
     -   `for (int neighbor : adjList[cur]`: Цикл, в котором происходит перебор всех смежных вершин текущей вершины.
     -   `if (neighbor == i)`: Проверка, является ли смежная вершина начальной вершиной. Если да, то обновляем значение `minCycle` с помощью строки `minCycle = min(minCycle, dist + 1)`
     -   `else if (!visited[neighbor])`: Проверка, была ли уже посещена смежная вершина. Если нет, то добавляем её в очередь c помощью строк `visited[neighbor] = true` и `q.push({ neighbor, dist + 1 })`.
- `if (minCycle == numberofsize  + 1){ return -1;} `:Проверка, был ли найден цикл во всем графе. Если нет, возвращаем -1, чтобы обозначить отсутствие цикла.
- `else { return minCycle; }`: Если же цикл был найден, возвращаем его длину.

После реализации алгоритма остаётся, лишь запросить у пользователя файл с орграфом (в виде списка смежности) и вывести обхват орграфа в новый файл.
```c++
int main() {
    setlocale(LC_ALL, "ru");
    string line;
    cout << "Введите файл: ";
    cin >> line;
    ifstream inputFile(line);
    ofstream outputFile("obhvat.txt");
    int numberof_usl, numberof_rebr;
    inputFile >> numberof_usl >> numberof_rebr;


    vector<vector<int>> adjList(numberof_usl);
    for (int i = 0; i < numberof_rebr; i++) {
        int usl, s_usl;
        inputFile >> usl >> s_usl;
        usl--, s_usl--;
        adjList[usl].push_back(s_usl);
    }
    inputFile.close();

    int cycleLength = shortestCycle(adjList, numberof_usl);
    if (cycleLength == -1) {
        outputFile << "Обхват графа: бесконечность" << endl;
    }
    else {
        outputFile << "Обхват графа: " << cycleLength << endl;
    }

    outputFile.close();
    return 0;
}
```

## Тестирование
Все тесты и наглядное изображение графов можетете посмотреть  [здесь](https://github.com/iis-32170x/RPIIS/tree/%D0%A1%D0%B5%D0%BC%D1%87%D0%B5%D0%BD%D0%BA%D0%BE_%D0%91/%D0%A0%D0%A0/%D1%82%D0%B5%D1%81%D1%82%D1%8B)

## Вывод
 
В результате выполнения расчётной работы приобрёл следующие навыки:
- изучил основы теории графов
- изучил способы представления графов
- изучил базовые алгоритмы для работы с графами
- изучил базовые алгоритмы работы с векторами, очерядими и файлами в C++

## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.

[7] База знаний по теории графов OSTIS GT [Электронный ресурс] / проект OSTIS, 2012. –
Режим доступа: http://ostisgraphstheo.sourceforge.net. — Дата доступа : 11.09.2012.
