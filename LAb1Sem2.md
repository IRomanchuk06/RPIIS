# Работа с очередью в C++

При выполнении задания по работе с очередью вы будете использовать концепции и алгоритмы, связанные с основными операциями с очередью.

## Цель задания:
Цель задания заключается в освоении работы с очередью, включая вставку элемента в очередь и извлечение элемента из очереди.

## Концепции:
- **Очередь (Queue):**
  - Очередь представляет собой структуру данных, работающую по принципу FIFO (First In, First Out).
- **Вставка элемента (Enqueue) и извлечение элемента (Dequeue):**
  - Вставка элемента в очередь (enqueue) происходит путем добавления нового элемента в конец очереди.
  - Извлечение элемента из очереди (dequeue) осуществляется путем удаления элемента из начала очереди.

## Алгоритмы:
- **Алгоритм вставки в очередь:**
  - При использовании массива для реализации очереди, вставка элемента включает добавление элемента в конец массива.
  - При использовании связанного списка, вставка элемента подразумевает добавление нового узла в конец списка.
- **Алгоритм извлечения из очереди:**
  - Для извлечения элемента из очереди нужно удалить элемент из начала очереди и обновить указатель на начало очереди.
  - При использовании массива, извлечение может включать смещение всех элементов на одну позицию влево.
  - При использовании связанного списка, извлечение может включать удаление первого узла и обновление указателя на начало списка.

Эти концепции и алгоритмы помогут вам эффективно выполнять операции с очередью и понимать их применение в различных алгоритмах и приложениях.
## Пример работы с очередью на C++

```cpp
#include<iostream>
#include <conio.h>

using namespace std;

class MyQueue {
public:
    MyQueue();
    virtual ~MyQueue();

    void    Push(int value);
    int     Pop();
    void    View();

private:
    typedef struct QueueElement {
        int             el;
        QueueElement* prev;
    } QueueElement;

    QueueElement* last;
    QueueElement* begin;
};

MyQueue::MyQueue() {
    last = begin = NULL;
}

MyQueue::~MyQueue() {
    while (begin != nullptr) {
        QueueElement* tmp = begin;
        begin = begin->prev;
        delete tmp;
    }
}

void MyQueue::Push(int value) {
    QueueElement* tmp = new QueueElement;
    tmp->el = value;
    tmp->prev = nullptr;

    if (begin == nullptr) {
        begin = last = tmp;
    }
    else {
        last->prev = tmp;
        last = tmp;
    }
}

void MyQueue::View() {
    QueueElement* tmp = begin;
    system("cls");
    cout << "Очередь : ";
    while (tmp != nullptr) {
        cout << tmp->el << " ";
        tmp = tmp->prev;
    }
}

int MyQueue::Pop() {
    setlocale(LC_ALL, "ru");
    if (begin == nullptr) {
        cout << "Очередь пустая" << endl;
        return -1; 
    }
    int popel = begin->el;
    QueueElement* tmp = begin;
    begin = begin->prev;
    delete tmp;
    return popel;
}

int main() {
    setlocale(LC_ALL, "ru");
    MyQueue queue;
    int choice, choice2, choice3, el, popel;
    do {
        cout << "выбирете действие\n"
            << " 1.Добавление\n"
            << " 2.Взятие элемента\n"
            << " 3.Просмотр очереди\n"
            << " 4.Выйти"
            << endl;
        cin >> choice;
        system("cls");
        switch (choice) {
        case 1:
            do {
                cout << "Введите элемент : ";
                cin >> el;
                system("cls");
                queue.Push(el);
                cout << "Выбирете действие\n"
                    << " 1.Добавить еще\n"
                    << " 2.Больше не добавлять\n"
                    << endl;
                cin >> choice2;
                system("cls");
            } while (choice2 != 2);
            break;
        case 2:
            popel = queue.Pop();
            cout << "Выбирете действие \n"
                << "1.Добавть взятый элемент в конец очереди \n"
                << "2.Удалить взятый элемент\n"
                << endl;
            cin >> choice3;
            system("cls");
            switch (choice3) {
            case 1:
                queue.Push(popel);
                cout << "Элемент добавлен в конец очереди ";
                break;
            case 2:
                cout << "элемент был удален";
                cout << "\nнажмите любую клавишу что бы продолжить : ";
                while (!_kbhit()) {
                }
                _getch();
                system("cls");
                break;
            default: cout << "Неправильный выбор ";
            }
            break;
        case 3:
            queue.View();
            cout << "\nнажмите любую клавишу что бы выйти из просмотра : ";
            while (!_kbhit()) {
            }
            _getch();
            system("cls");
            break;
        case 4:
            break;
        default:cout << "Неправильный выбор";
        }
    } while (choice != 4);
    return 0;
}
```
## Алгоритм работы программы

### Определение класса MyQueue:
- В классе `MyQueue` определены приватные элементы `last` и `begin`, представляющие последний и первый элементы очереди соответственно.
- В классе определена структура `QueueElement`, которая представляет собой элемент очереди.

### Конструктор и деструктор класса `MyQueue`:
- Конструктор класса `MyQueue` инициализирует указатели `last` и `begin` как `nullptr`.
- Деструктор освобождает память, выделенную для элементов очереди.

### Методы `Push`, `Pop`, `View`:
- Метод `Push` добавляет элемент в конец очереди.
- Метод `Pop` извлекает элемент из начала очереди.
- Метод `View` выводит содержимое очереди на экран.

### Функция `main()`:
- В функции `main()` создается объект класса `MyQueue`.
- В цикле `do-while` пользователю предлагается выбрать действие (добавление, извлечение, просмотр очереди или выход).
- В зависимости от выбора пользователя выполняются соответствующие операции с очередью.
- Для добавления элемента в конец очереди используется цикл `do-while`.
- После каждого действия пользователю предлагается выбрать следующее действие.
- Пользователь может выйти из программы, выбрав соответствующий пункт меню.
  # Работа с очередью,вывод

Очередь - это структура данных, в которой элементы упорядочены по принципу "первым пришел, первым вышел" (FIFO - First-In-First-Out). Это означает, что элементы добавляются в конец очереди и удаляются из ее начала.

## Операции с очередью

### Вставка элемента в очередь

Для вставки элемента в очередь вы используете операцию, которая называется "enqueue" или "встать в очередь". Элемент добавляется в конец очереди. Если очередь заполнена, то возможно ожидание, пока место в очереди не освободится.

### Взятие элемента из очереди

Для взятия элемента из очереди вы используете операцию, которая называется "dequeue" или "выйти из очереди". Элемент извлекается из начала очереди. Если очередь пуста, то операция извлечения может привести к ошибке или вернуть специальное значение, указывающее на пустую очередь.



