# Расчетная работа 

## Введение

### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами, 
### Задание
6.1 
### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Неориентированным графом`  G называется пара G=(V,E), где V— множество вершин, а E⊂{{v,u}:v,u∈V} — множество рёбер.

`Дерево` — это связный ациклический граф.[1] Связность означает наличие маршрута между любой парой вершин, ацикличность — отсутствие циклов. Отсюда, в частности, следует, что число рёбер в дереве на единицу меньше числа вершин, а между любыми парами вершин имеется один и только один путь.

`Обход в глубину` (поиск в глубину, англ. Depth-First Search, DFS) — один из основных методов обхода графа, часто используемый для проверки связности, поиска цикла и компонент сильной связности и для топологической сортировки.
## Алгоритм решение
Этот код реализует алгоритм для определения минимального количества вершин, которые нужно удалить из графа, чтобы он стал деревом. Для этого он использует несколько шагов:

1. Чтение графа из файла:

Сначала он читает данные о графе из файла. Первая строка файла содержит количество вершин, а вторая строка - количество рёбер. Последующие строки представляют собой пары чисел (u, v), обозначающих рёбра между вершинами u и v.
2. Построение графа:

Создаётся граф, используя информацию из файла, и строятся рёбра между вершинами.
3. Проверка связности графа:

Проверяется, связанный ли граф. Если есть хотя бы одна непосещённая вершина после обхода в ширину (BFS), то граф несвязный.
4. Проверка наличия циклов:

Также проверяется наличие циклов в графе с помощью обхода в глубину (DFS).
5. Определение минимального количества вершин для удаления:

Если граф несвязный или содержит циклы, начинается поиск минимального количества вершин для удаления.
Перебираются все вершины графа. Для каждой вершины удаляются все её рёбра, и затем проверяется связность и отсутствие циклов в графе.
Если граф становится связным и не содержит циклов после удаления рёбер данной вершины, возвращается количество удалённых вершин.
Если ни одна из вершин не может быть удалена, чтобы граф стал деревом, возвращается 0.
Этот алгоритм стремится минимизировать количество удаленных вершин, чтобы превратить граф в дерево (связный ациклический граф).

## Реализация на C++

```c++
#include <iostream>
#include <fstream>
#include <vector>
#include <cstring>
using namespace std;

// Хранит список смежности
vector<int> vec[100001];

// Хранит информацию о посещении вершин
bool vis[100001];
int cc = 1;

// Функция для выполнения обхода в глубину
// для подсчета количества и размера
// всех связанных компонентов
void dfs(int node) {
    // Отмечаем текущую вершину как посещенную
    vis[node] = true;

    // Обходим список смежности текущей вершины
    for (auto x : vec[node]) {
        // Для каждой непосещенной вершины
        if (!vis[x]) {
            cc++;
            // Рекурсивный вызов DFS
            dfs(x);
        }
    }
}

// Функция для добавления неориентированного
// ребра в граф
void addEdge(int u, int v) {
    vec[u].push_back(v);
    vec[v].push_back(u);
}

// Функция для вычисления минимального
// количества ребер, которые нужно удалить
void minEdgeRemoved() {
    int N, M;
    ifstream inputFile("C:\\Users\\bebra\\Desktop\\test2.txt");
    inputFile >> N >> M;

    vector<vector<int>> Edges(M, vector<int>(2));;
    for (int i = 0; i < M; i++) {
        inputFile >> Edges[i][0] >> Edges[i][1];
        addEdge(Edges[i][0], Edges[i][1]);
    }
    inputFile.close();

    memset(vis, false, sizeof(vis));
    int k = 0;

    // Перебираем все вершины
    for (int i = 1; i <= N; i++) {
        if (!vis[i]) {
            cc = 1;
            dfs(i);
            k++;
        }
    }

    // Выводим окончательный результат
    cout << "Количество ребер: " << M - N + k << endl;
}

// Основная часть программы
int main() {
    setlocale(LC_ALL, "RU");
    minEdgeRemoved();
}
```

## Вывод
 
В результате выполнения расчётной работы приобрёл следующие навыки:
- изучил основы теории графов
- изучил способы представления графов
- изучил базовые алгоритмы для работы с графами
- изучил базовые алгоритмы работы с векторами, очерядими и файлами в C++

## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.

[7] База знаний по теории графов OSTIS GT [Электронный ресурс] / проект OSTIS, 2012. –
Режим доступа: http://ostisgraphstheo.sourceforge.net. — Дата доступа : 11.09.2012.









