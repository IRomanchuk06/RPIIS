# Расчетная работа 


## Введение

### Цель

Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами, 

### Задание

Реализовать на C++ код, который находит декартову сумму двух неориентированных графов.

Графы представляются в виде матрицы смежности.

Результат так же выводится в виде матрицы смежности.


### Ключевые понятия

`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями. 


`Неориентированными графами` - называются графы , в которых все ребра являются звеньями, то есть порядок двух концов ребра графа не существенен

`Матрица смежности` - это вид представления графа в виде матрицы, когда пересечение столбцов и строк задаёт дуги. Используя матрицу смежности, можно задать вес дуг и ориентацию. Каждая строка и столбец матрицы соответствуют вершинам, номер строки соответствует вершине, из которой выходит дуга, а номер столбца - в какую входит дуга.

`Декартовая суммой` графов G1(x1) и G2(x2) G(x) = G1(x1) + G2(x2) на­зывается граф, определенный следующим образом:

а) множество вершин X является декартовым произведением X1 и X2, т.е. X = X1 ´ X2 = {(xi1, xj2) / xi1 Î X1, xj2 Î X2};

б) множество вершин, смежных с вершиной (xi1, xj2) определяется как

G(xi1, xj2) = [G1(xi1) ´ {xj2}] È [{xi1} ´ G2(xj2)] (´ - операция декартова про­изведения).
## Алгоритм решения задачи.

Рассмотрим два графа графическом представлении и в виде матрицы смежности

<table>
<tr>
  <td>
    <img src="images/graph1.png">
  </td>
  <td>
    <img src="images/graph2.png">
  </td>
</tr>
<tr>

</tr>
<tr>
  <td>
    <table>
      <tr>
        <td></td> <td>1</td> <td>2</td> <td>3</td>
      </tr>
      <tr>
        <td>1</td> <td>0</td> <td>1</td> <td>0</td> 
      </tr>
      <tr>
        <td>2</td> <td>1</td> <td>0</td> <td>1</td> 
      </tr>
      <tr>
        <td>3</td> <td>0</td> <td>1</td> <td>0</td> 
      </tr>
    </table>
  </td>
  <td>
    <table>
      <tr>
        <td></td> <td>1</td> <td>2</td> 
      </tr>
      <tr>
        <td>1</td> <td>0</td> <td>1</td> 
      </tr>
        <td>2</td> <td>1</td> <td>0</td> 
      </tr>
    </table>
  </td>
</tr>
</table>

1. Количесвто вершин из определения определяется декартовым произведением.
    
    <img src="images/graph1.png">

2. Связь между новыми ребрами определяется следующим образом в полученных вершинах(кортежах) определяется следующее:
   
   1. Если ребра между 2-мя вершинами кортежами(берем 1ый элемент из кортежа) были соединены ранее.
   2. При выполнение первого условия должно выполняться что 2 элементы  в кортеже вершины должны не имеет соединения.
   3. При выполнении 2 условий должно выполняться доп условие: 2 элементы в двух вершинах кортежей должна быть равны, иначе будут образовываться связи которые будут нас отдолять от декартовой суммы графов.

    
        P.S. Данный алгоритм зеркален и в обратную сторону.

1. Рассмотрим наши пары кортежи:
   1. При произедении вершин мы получаем следующие кортежи
    
        (1, 4) (1, 5) (2, 4) (2, 4) (3, 5) (3, 5)
    
    2. Рассмотрим пару (1, 4) и (1,5)

        Их 2-ые элементы вершин кортежей были соединены ранее.Далее проверяем 2-ое условие их 1-ые элементы не были соединены и последнее условие чтобы его 1-ые элементы совпадали.
        

        Вывод значит можем соединить данные вершины кортежи.Далее проделываем алгоритм с каждой вершиной и получаем результат.

        <img src="images/graph1.png">

## Реализация
```c++
#include <iostream>
#include <vector>

using namespace std;

vector<vector<int>> q(int n1, int n2) {
    vector<vector<int>> adj2;
    int i = 0;
    int g = 0;
    while (i < n1) {
        vector<int> temp = { i, g };
        adj2.push_back(temp);
        g += 1;
        if (g == n2) {
            g = 0;
            i += 1;
        }
    }

    return adj2;
}


int main() {
    setlocale(LC_ALL, "Rus");
    int n1, n2;
    cout << "Введите количество вершин первого графа ";
    cin >> n1;
    cout << "Введите количество вершин второго графа ";
    cin >> n2;


    vector<vector<int>> adj1(n1, vector<int>(n1));
    cout << "Введите матрицу смежности перого графа\n";
    for (int i = 0; i < n1; i++) {
        for (int j = 0; j < n1; j++){
            cin >> adj1[i][j];
    }

}


vector<vector<int>> adj2(n2, vector<int>(n2));
cout << "Введите матрицу смежности второго графа\n";
for (int i = 0; i < n2; i++) {
    for (int j = 0; j < n2; j++) {
        cin >> adj2[i][j];
    }
}


vector<vector<int>> sum(n1 * n2, vector<int>(n1 * n2));

for (auto i : q(n1, n2)) {
    for (auto j : q(n1, n2)) {
        if ((adj1[i[0]][j[0]] == 1 and adj2[i[1]][j[1]] == 0 and i[1] == j[1]) or
            (adj1[i[0]][j[0]] == 0 and adj2[i[1]][j[1]] == 1 and i[0] == j[0])) {

            sum[i[0] + i[1] * n1][j[0] + j[1] * n1] = 1;

        }

    }
}

cout << "Выводм матрицы смежности суммы графов\n";
for (int i = 0; i < n1 * n2; i++) {
    for (int j = 0; j < n1 * n2; j++) {
        cout << sum[i][j] << " ";
    }
    cout << "\n";
}

return 0;

}
```
Сам код состоит из 3 частей.

1. Ввод кол-ва вершин и матрицы смежности 1-ого и 2-ого графа.
2. Далее подсчет декартовой суммы 
3. Вывод результатов.

Рассмотрим 1-ую часть кода:

Ввод представлен через матрицу смежности

```c++
int main() {
    setlocale(LC_ALL,"Rus");
    int n1, n2;
    cout << "Введите количество вершин первого графа ";
    cin >> n1;
    cout << "Введите количество вершин второго графа ";
    cin >> n2;

    
    vector<vector<int>> adj1(n1, vector<int>(n1));
    cout << "Введите матрицу смежности перого графа\n";
    for (int i = 0; i < n1; i++) {
        for (int j = 0; j < n1; j++) 
            cin >> adj1[i][j];
        }            

    }

    
    vector<vector<int>> adj2(n2, vector<int>(n2));
    cout << "Введите матрицу смежности второго графа\n";
    for (int i = 0; i < n2; i++) {
        for (int j = 0; j < n2; j++) {
            cin >> adj2[i][j];
        }
    }

```

Рассмотрим 2-ую часть кода 
```c++
vector<vector<int>> sum(n1 * n2, vector<int>(n1 * n2));

for (auto i : q(n1, n2)) {
    for (auto j : q(n1, n2)) {
        if ((adj1[i[0]][j[0]] == 1 and adj2[i[1]][j[1]] == 0 and i[1] == j[1]) or
            (adj1[i[0]][j[0]] == 0 and adj2[i[1]][j[1]] == 1 and i[0] == j[0])) {

            sum[i[0] + i[1] * n1][j[0] + j[1] * n1] = 1;

        }

    }
}
```
Здесь происходит проверка на условия о составлении связей между ребрами, а так же переборка всех возможных связей между вершинами и заполнение финальной матрицы смедности.Также здесь используется функция для создания вершин-кортеж.



И 3-я часть вывод результата:
```c++
cout << "Выводм матрицы смежности суммы графов\n";
for (int i = 0; i < n1 * n2; i++) {
    for (int j = 0; j < n1 * n2; j++) {
        cout << sum[i][j] << " ";
    }
    cout << "\n";
}
```
## Тестирование



## Вывод
 
В результате выполнения данной работы были получены следующие практические навыки:
- изучены основы теории графов
- изучены способы представления графов
- изучены базовые алгоритмы для работы с графами
- изучена операция декартовой суммы графов.