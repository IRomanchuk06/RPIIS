# Отчет по расчетной работе по дисциплине ПиОИвИС


### Цель:


Ознакомиться с  основами теории графов, способами представления графов, базовыми алгоритмами для работы с разными видами графов.


### Условие задания


Найти максимальный путь между заданными вершинами в взвешанном неориентированном графе.
 
 
 ### Базовые понятия 
 - **Граф** - совокупность двух множеств множества самих объектов, называемого множеством вершин, и множества их парных связей, называемого множеством рёбер.
- **Неориентированный граф** - граф, в котором все ребра являются звеньями, то есть порядок двух концов ребра графа не существенен.
- **Взвешенный граф** - граф, в котором у каждого ребра и/или каждой вершины есть “вес” - некоторое число, которое может обозначать длину пути, его стоимость и т. п.
- **Матрица смежности** - это способ представления графа в виде матрицы. В этой матрице каждая строка и столбец соответствуют одной вершине графа. Элемент матрицы на пересечении строки i и столбца j равен 1, если вершины i и j соединены ребром, и 0, если они не соединены.


### Алгоритм решения


1.Получаем информацию о графе из текстового документа,где граф представлен способом матрицы смежности.


1.1. Открываем файл matrixfile,где хранится информация о графе.


1.2. Все числовые значения из файла помещаем в вектор.


1.3. Вычисляем кол-во вершин в графе извлекая квадратный корень из размера вектора.Количество вершин хранит переменная versh


1.4. Переписываем всю информацию о графе из вектора в  двумерный динамический массив graf .


1.5. Если значение массива graf с индексами i и j равно 1(между точками i+1 и j+1 существует ребро) ,просим польователя ввести вес этого ребра.Присваеваем вес массиву с индексами i,j и j,i.Также добавляем единицу к переменной rebra(переменная,которая хранит колличество ребер).


2. Вводим динамические массивы:


2.1 Динамический массив kraska с длиной равной кол-ву вершин.


2.2 Динамический массив kraska2 с длиной равной кол-ву вершин.


2.3 Динамический массив dist с длиной равной кол-ву вершин,умноженному на 10.


3. Запускаем цикл,который срабатывает 10*кол-во ребер раз(10*rebra)(цикл1).Номер итерации равен r


3.1.Присваеваем всем элементам массива kraska и kraska2 значение 0.


3.2. Присваеваем элементу массива dist с индексом r(счетчик цикла) значение 0.


3.3. Обнуляем все счетчики,использующиеся в последующих циклах


3.4. Запускаем цикл с кол-вом итераций равному кол-ву вершин(цикл 2)


3.4.1. Обрабатываем случай,когда последней вершиной рассчитываемого пути является вершина,из которой мы начинали путь(номер вершины=v+1).


3.4.1.1.Если есть вершина,связанная с вершиной номер v+1 и значение массива kraska2 с индексои равным v не равно 2,тогда к элементу массива dist с индексом r добавляем вес ребра между этими точками.Иначе выходим из цикла 2.


3.4.2 Ищем на какой вершине остановился рассчет пути:


```c++
            if (i > v)
            {
                if (kraska[i] % 2 == 1)
                {
                    ++schet;
                    if (schet == 2) break;
                }
                if (kraska[i] % 2 == 0) continue;
            }
```
3.4.3. Проверяем есть ли петли на этой вершине и не был ли добавлен вес петли к пути ранее(равно ли значение элемента массива kraska с индексом номер ребра -1 единице).Если есть и вес еще не был добавлен, добавляем вес петли к элементу массива dist с индексом r и добавляем единицу к элементу массива kraska2 с индексом номер вершины -1.


3.4.4. Ищем есть ли вершина связанная ребром с вершиной на которой остановился рассчет пути.Проверяем чтобы вес этого ребра не был зачтен в путь ранее.


3.4.4.1 Если такая вершина и ребро есть добавляем вес к элементу массива dist с индексом r.Добавляем единицу к элементам массива kraska соответствующим вершинам,которые соединяет зачтенное ребро.


3.4.5. Если ребер,вес которых можно добавить в путь не остается,выходим из цикла2.


3.5. Удаляем последнее ребро.


3.6. Если ребер в графе не осталось выходим из цикла 1.


4.Ищем максимальный путь и присваеваем его значнение переменной max:


```c++
   max = dist[0];
   for (int i = 0; i < 10 * reb; ++i)
       if (dist[i] > max) max = dist[i];
```
5.Выводим максимальный путь.


### Примеры выполнения
![Матрица 1](/images/matrix1.png) 
![Пример 1 с матрицей 1](/images/example1m1.png) 
![Пример 2 с матрицей 1](/images/example2m1.png) 
![Матрица 2](/images/matrix2.png) 
![Пример 1 с матрицей 2](/images/example1m2.png) 
![Пример 2 с матрицей 2](/images/example2m2.png) 
![Пример 3 с матрицей 2](/images/example3m2.png) 


## Вывод

В результате выполнения данной работы были получены следующие практические навыки:
- изучены основы теории графов
- изучены способы представления графов
- изучены базовые алгоритмы для работы с графами

