# Расчетная работа 

## Введение

### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами, 
### Задание
2.14 Число компонентов связности неориентированного графа.

Реализовать на C++ код, который может найти число компонентов связности неориентированного графа.

Граф представляется в виде списка смежности(списка инцидентности). 

### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Неориентированный граф (кратко нг)` —  граф, рёбрам которого не присвоено направления.

`Список смежности` - один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

`Путь в графе` – это последовательность рёбер, в которой конец каждого ребра (кроме последнего) совпадает с началом следующего.
Замкнутый путь называется `циклом`. 

`Компонент связности` — подграф, в котором для любой пары вершин v и u существует путь. Между двумя различными компонентами связности не существует пути.

`Обход в ширину (breadth-first search, BFS)` систематически обходит все вершины графа

Графический пример обхода в ширину:

![image](https://github.com/iis-32170x/RPIIS/assets/144383538/2684132b-37f0-4310-a2f7-9ed034df4b2a)

## Алгоритм решения

Выполняет поиск количества компонентов связности графа.  Применяем поиск в ширину (BFS) для каждой вершины графа, чтобы определить смежные вершины и посчитать количество компонентов связности.

Начинаем поиск с каждой вершины и инициируем очередь для выполнения поиска в ширину. Для каждой вершины в очереди, рассматриваем всех соседей этой вершины и добавляем их в очередь, если они еще не были посещены. Для непосещенной вершины, все вершины которые достижимы из данной, будут образовывывать компонент связности.

Затем такой же путь проделываем с остальными непосещенными вершинами и ищем смежные вершины.

Приведем пример алгоритма для поиска компонентов связности в качестве примера:

Исходный граф:

!![image](https://github.com/iis-32170x/RPIIS/assets/148707516/047bdb7d-8767-448a-bb4a-b65bbce2d861)


Теперь представим этот граф в виде списка смежности:

> - `1 -> 3`
> - `3 -> 2`
> - `4 -> 5`


1. Начинаем с вершины 1 и помечаем ее как посещенную.
 - Запускаем обход в ширину:
 - Извлекаем вершину 1 из очереди и помечаем ее как посещенную.
 - Просматриваем смежные вершины (в данном случае, вершины 2 и 3) и добавляем их в очередь, если они еще не были посещены.
 - Помечаем каждую добавленную вершину как посещенную.


2. Переходим к вершине 4:

  - Извлекаем вершину 4 из очереди и помечаем ее как посещенную.
  - Просматриваем смежные вершины (в данном случае, вершина 5) и добавляем ее в очередь.
  - Помечаем вершину 5 как посещенную.
  
3. Переходим к вершине 6:

  - Извлекаем вершину 6 из очереди и помечаем ее как посещенную.
  - Просматриваем смежные вершины (в данном случае их нет).
  - Помечаем вершину 6 как посещенную.

4. Завершаем обход в ширину, так как больше нет непосещенных вершин.
   Таким образом количество компонент связности в данном случае является 3. 

## Реализация на C++

Код, выполняющий наш алгоритм:

```c++
#include <fstream>
#include <vector>
#include <queue>
using namespace std;

int componenti(vector<vector<int>>& spisok) {
    int n = spisok.size();
    vector<bool> visited(n, false);
    int count = 0;

    for (int i = 0; i < n; ++i) {
        if (!visited[i]) {
            queue<int> q;
            q.push(i);
            visited[i] = true;

            while (!q.empty()) {
                int curr = q.front();
                q.pop();

                for (int neighbor : spisok[curr]) {
                    if (!visited[neighbor]) {
                        q.push(neighbor);
                        visited[neighbor] = true;
                    }
                }
            }

            ++count;
        }
    }

    return count;
}

int main() {
    ifstream inputFile("input.txt");
    ofstream outputFile("output.txt"); 

    int n, m; // Количество вершин и ребер
    inputFile >> n >> m;

    vector<vector<int>> spisok(n);

    for (int i = 0; i < m; ++i) {
        int u, v; // Смежные вершины u и v
        inputFile >> u >> v;
        spisok[u - 1].push_back(v - 1);
        spisok[v - 1].push_back(u - 1);
    }

    inputFile.close();

    int components = componenti(spisok);

    outputFile << "Count of components is: " << components << endl;

    outputFile.close();

   

    return 0;
}
```

## Разбор кода:

- `#include <vector>`, `#include <fstream>` и `#include <queue>`: библиотеки , которые предоставляют возможность использовать векторы, файлы и очереди.
- `int componenti(vector<vector<int>>& spisok)`: Это объявление функции componenti, которая принимает вектор векторов adj в качестве параметра. "adj" представляет собой список смежности графа.
- `int n = adj.size();` : Здесь создается переменная n, которая содержит количество вершин в графе. Она инициализируется значением adj.size(), то есть размером вектора adj, что предполагает, что каждый элемент вектора adj представляет вершину графа и содержит список смежных с ней вершин.
- `vector<bool> visited(n, false);` : Создается вектор visited типа bool размером n. Вектор visited используется для отслеживания посещенных вершин графа. Изначально все элементы вектора инициализируются значением false, что означает, что ни одна вершина не была посещена.
- `int count = 0;` : Создается переменная count, которая будет использоваться для подсчета количества компонент связности в графе. Изначально count инициализируется значением 0.
- `for (int i = 0; i < n; ++i) {` : Это начало цикла for, который перебирает все вершины графа по индексу i.
 - `if (!visited[i]) {` : Это условие проверяет, была ли вершина i уже посещена. Если вершина не была посещена, то выполняется следующий код внутри условия.
  - `queue<int> q;
     q.push(i);
     visited[i] = true;` : Создается очередь q, в которую помещается вершина i. Далее вершине i присваивается значение true в векторе visited, чтобы отметить ее как посещенную.
   - `while (!q.empty()) {` : Это начало цикла while, который будет выполняться до тех пор, пока очередь q не станет пустой.
   - `int curr = q.front();
       q.pop();` : Извлекается первый элемент из очереди q и помещается в переменную curr. Затем этот элемент удаляется из очереди с помощью q.pop().
   - `for (int neighbor : adj[curr])` : Это цикл for, который перебирает всех соседей текущей вершины curr из списка смежности adj[curr].
   - `if (!visited[neighbor]) {
        q.push(neighbor);
        visited[neighbor] = true;}` : Если соседняя вершина neighbor еще не была посещена, она добавляется в очередь q и помечается как посещенная в векторе visited.
 - `++count;` : После завершения внутреннего while-цикла, инкрементируется счетчик count, чтобы отразить посещение новой компоненты связности.
 - `return count;` : Функция возвращает общее количество компонент связности в графе.

    
После реализации алгоритма пользователю остается лишь, в строку `ifstream inputFile("graph3.txt");` в круглые скобки "()", вписать имя нужного текстового документа, который содержит граф представленный в списке смежности.


## Тестирование
# Первый граф:

Графическое изображение:

![image](https://github.com/iis-32170x/RPIIS/assets/148707516/b6aefb70-c5b7-493f-8248-e7c7a18b5138)

Задание графа списком смежности:

![image](https://github.com/iis-32170x/RPIIS/assets/148707516/89dabde1-85eb-47f6-af0c-bba989b3feb0)

Итоговое количество компонент данного графа:

![image](https://github.com/iis-32170x/RPIIS/assets/148707516/7a24134c-91ee-4c9b-a918-c342c4ecf592)


# Второй граф:
Графическое изображение:

![image](https://github.com/iis-32170x/RPIIS/assets/148707516/96df3bdc-13f7-4bd8-9659-6837532366a4)

Задание графа списком смежности:

![image](https://github.com/iis-32170x/RPIIS/assets/148707516/594195a4-8cfa-4f56-a0bf-72af88be3586)


Итоговое количество компонент данного графа:

![image](https://github.com/iis-32170x/RPIIS/assets/148707516/609028b7-b762-4881-b098-bb200f8cd997)

# Третий граф:

Графическое изображение:

![image](https://github.com/iis-32170x/RPIIS/assets/148707516/ebacf186-c4d1-48e5-addd-7c4a74ccc602)

Задание графа списком смежности:

![image](https://github.com/iis-32170x/RPIIS/assets/148707516/7297fbb7-00d5-4d8f-bfe0-b65a3e088052)


Итоговое количество компонент данного графа:


![image](https://github.com/iis-32170x/RPIIS/assets/148707516/84488062-9a55-401c-a268-0ec74f0943ae)







## Вывод
 
В результате выполнения расчётной работы приобрёл следующие навыки:
- научилась определять графы и их компоненты, как вершины и ребра связаны между собой.
- научилась определять связность и инцидентность в графах.
- научилась использовать алгоритмы на графах.
- изучила алгоритм обхода в ширину в графах.
- изучила базовые алгоритмы работы с векторами, очередями и файлами в C++.

## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.

[7] База знаний по теории графов OSTIS GT [Электронный ресурс] / проект OSTIS, 2012. –
Режим доступа: http://ostisgraphstheo.sourceforge.net. — Дата доступа : 11.09.2012.





