# Расчетная работа 

## Введение

### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами, 
### Задание
2.14 Число компонентов связности неориентированного графа.

Реализовать на C++ код, который может найти число компонентов связности неориентированного графа.

Граф представляется в виде списка смежности(списка инцидентности).

### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Неориентированный граф (кратко нг)` —  граф, рёбрам которого не присвоено направления.

`Список смежности` - один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

`Путь в графе` – это последовательность рёбер, в которой конец каждого ребра (кроме последнего) совпадает с началом следующего.
Замкнутый путь называется `циклом`. 

`Компонент связности` — подграф, в котором для любой пары вершин v и u существует путь. Между двумя различными компонентами связности не существует пути.

`Обход в ширину (breadth-first search, BFS)` систематически обходит все вершины графа

Графический пример обхода в ширину:

![image](https://github.com/iis-32170x/RPIIS/assets/144383538/2684132b-37f0-4310-a2f7-9ed034df4b2a)

## Алгоритм решения

Выполняет поиск количества компонентов связности графа.  Применяем поиск в ширину (BFS) для каждой вершины графа, чтобы определить смежные вершины и посчитать количество компонентов связности.

Начинаем поиск с каждой вершины и инициируем очередь для выполнения поиска в ширину. Для каждой вершины в очереди, рассматриваем всех соседей этой вершины и добавляем их в очередь, если они еще не были посещены. Для непосещенной вершины, все вершины которые достижимы из данной, будут образовывывать компонент связности.

Затем такой же путь проделываем с остальными непосещенными вершинами и ищем смежные вершины.

Приведем пример алгоритма для поиска компонентов связности в качестве примера:

Исходный граф:

!![image](https://github.com/iis-32170x/RPIIS/assets/148707516/047bdb7d-8767-448a-bb4a-b65bbce2d861)


Теперь представим этот граф в виде списка смежности:

> - `1 -> 3`
> - `3 -> 2`
> - `4 -> 5`


1. Начинаем с вершины 1 и помечаем ее как посещенную.
 - Запускаем обход в ширину:
 - Извлекаем вершину 1 из очереди и помечаем ее как посещенную.
 - Просматриваем смежные вершины (в данном случае, вершины 2 и 3) и добавляем их в очередь, если они еще не были посещены.
 - Помечаем каждую добавленную вершину как посещенную.


2. Переходим к вершине 4:

  - Извлекаем вершину 4 из очереди и помечаем ее как посещенную.
  - Просматриваем смежные вершины (в данном случае, вершина 5) и добавляем ее в очередь.
  - Помечаем вершину 5 как посещенную.
  
3. Переходим к вершине 6:

  - Извлекаем вершину 6 из очереди и помечаем ее как посещенную.
  - Просматриваем смежные вершины (в данном случае их нет).
  - Помечаем вершину 6 как посещенную.

4. Завершаем обход в ширину, так как больше нет непосещенных вершин.
   Таким образом количество компонент связности в данном случае является 3. 

## Реализация на C++

Код, выполняющий наш алгоритм:

```c++
#include <fstream>
#include <vector>
#include <queue>
using namespace std;

int connectedComponents(vector<vector<int>>& adj) {
    int n = adj.size();
    vector<bool> visited(n, false);
    int count = 0;

    for (int i = 0; i < n; ++i) {
        if (!visited[i]) {
            queue<int> q;
            q.push(i);
            visited[i] = true;

            while (!q.empty()) {
                int curr = q.front();
                q.pop();

                for (int neighbor : adj[curr]) {
                    if (!visited[neighbor]) {
                        q.push(neighbor);
                        visited[neighbor] = true;
                    }
                }
            }

            ++count;
        }
    }

    return count;
}

int main() {
    ifstream inputFile("input.txt");
    ofstream outputFile("output.txt"); 

    int n, m; // Количество вершин и ребер
    inputFile >> n >> m;

    vector<vector<int>> adj(n);

    for (int i = 0; i < m; ++i) {
        int u, v; // Смежные вершины u и v
        inputFile >> u >> v;
        adj[u - 1].push_back(v - 1);
        adj[v - 1].push_back(u - 1);
    }

    inputFile.close();

    int components = connectedComponents(adj);

    outputFile << "Count of components is: " << components << endl;

    outputFile.close();

   

    return 0;
}
```

## Разбор кода:

- `#include <vector>`, `#include <fstream>` и `#include <queue>`: библиотеки , которые предоставляют возможность использовать векторы, файлы и очереди.
- `int shortestCycle(vector<vector<int>>& adjList, int numberofsize)`: Объявление функции shortestCycle, которая принимает ссылку на вектор векторов adjList и целочисленное значение n, обозначающее количество вершин в графе. Функция возвращает целочисленное значение - длину кратчайшего цикла в графе, либо -1, если цикл отсутствует.
- `for (int i = 0; i < numberofsize; i++)` : Цикл, в котором происходит перебор всех вершин графа. Внутри этого цикла будет запущен поиск кратчайшего цикла из каждой вершины:
  -   `vector<bool> visited(numberofsize, false) `: Объявление вектора visited размером n, которая будет использоваться для отслеживания посещенных вершин во время обхода графа.
  - `queue<pair<int, int>> q`: Объявление очереди q с элементами типа pair<int, int>, где первый элемент - вершина графа, а второй - расстояние от начальной вершины.
  - `q.push({ i, 0 })`: Добавление начальной вершины i в очередь q с расстоянием 0.
  - `while (!q.empty())`: Цикл, который будет выполняться, пока очередь не станет пустой. Здесь происходит обход графа в ширину (BFS) из текущей вершины:
     - `int cur = q.front().first`: Извлечение текущей вершины из очереди.
     -  `int dist = q.front().second `: Извлечение расстояния от начальной вершины до текущей вершины.
     -   `q.pop()`: Очищение очереди
     -   `for (int neighbor : adjList[cur]`: Цикл, в котором происходит перебор всех смежных вершин текущей вершины.
     -   `if (neighbor == i)`: Проверка, является ли смежная вершина начальной вершиной. Если да, то обновляем значение `minCycle` с помощью строки `minCycle = min(minCycle, dist + 1)`
     -   `else if (!visited[neighbor])`: Проверка, была ли уже посещена смежная вершина. Если нет, то добавляем её в очередь c помощью строк `visited[neighbor] = true` и `q.push({ neighbor, dist + 1 })`.
- `if (minCycle == numberofsize  + 1){ return -1;} `:Проверка, был ли найден цикл во всем графе. Если нет, возвращаем -1, чтобы обозначить отсутствие цикла.
- `else { return minCycle; }`: Если же цикл был найден, возвращаем его длину.

После реализации алгоритма пользователю остается лишь, в строку `ifstream inputFile("graph3.txt");` в круглые скобки "()", вписать имя нужного текстового документа, который содержит граф представленный в списке смежности.


## Тестирование
Все тесты и наглядное изображение графов можетете посмотреть  [здесь](https://github.com/iis-32170x/RPIIS/tree/Позняк_А/RR/tests)

## Вывод
 
В результате выполнения расчётной работы приобрёл следующие навыки:
- научилась определять графы и их компоненты, как вершины и ребра связаны между собой.
- научилась определять связность и инцидентность в графах.
- научилась использовать алгоритмы на графах.
- изучила алгоритм обхода в ширину в графах.
- изучила базовые алгоритмы работы с векторами, очередями и файлами в C++.

## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.

[7] База знаний по теории графов OSTIS GT [Электронный ресурс] / проект OSTIS, 2012. –
Режим доступа: http://ostisgraphstheo.sourceforge.net. — Дата доступа : 11.09.2012.





