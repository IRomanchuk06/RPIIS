# Расчетная работа 

## Введение

### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графам.
### Задание
5.15 Поиск в графе

Найти мосты в неориентированном графе.

Граф представляется в виде списка смежности(списка инцидентности).

### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Неориентированный граф` - граф, рёбра которого не имеют определённогонаправление.

`Список смежности` - один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

`Мост` - ребро в теории графов, удаление которого увеличивает число компонентов связности.

Пример мостов в графах (мосты выделены красным цветом): 

![image](https://github.com/sourist/assets/blob/master/bridges.png?raw=true)


## Алгоритм решения

Находим мосты в графе. Берём каждую вершину графа и рассматриваем каждое ребро, исходящее от этой вершины как потенциальный мост. Обозначаем взятую вершину как `предок`, а взятого соседа как `потомок`.

Выполняем обход в ширину для вершины `предок`, исключая из нашего пути ребро `предок-потомок`. Добавялем каждую пройденную вершину во множество пройденных вершин.

После обхода графа в ширину проверяем: есть ли вершина `потомок` во множестве пройденных вершин.

Если такая вершина есть, значит существует альтернативный путь к ней от вершины `предок` и рассматриваемое ребро мостом не является.

Если же такого пути не существует, т.е вершина `потомок` не принадлежит множеству пройденных вершин, то рассматриваемое ребро `предок-потомок` является мостом.

Рассмотрим пример:

Исходный граф:

![image](https://github.com/sourist/assets/blob/master/graph1.png?raw=true)

Представим его в виде списка смежности (списка инцидентности):

> - `0`:  `1`  `5`
> - `1`:  `0`  `2`  `5`
> - `2`:  `1`  `3`  `4`
> - `3`:  `2`
> - `4`:  `2`
> - `5`:  `0`  `1`

1. Берём вершину 0.
 
   - Добавляем её в список посещённых вершин.
     
2. Перебираем список посещённых вершин: 0.
   
3. Берём первую вершину инциндентную вершине 0 - 1.
   
    - Вершина 0 становится `предком`.
     
    - Вершина 1 становится `потомком`.
     
4. Проверяем: является ли ребро `0-1` мостом.
   
5. Находим по списку смежности соседей `0` и добавляем их всех (кроме `1`) в список посещённых, если их там нет.
   
6. Перебираем все вершины из списка посещённых и добавляем их соседей в список (если рассматриваются соседи `предка`, то вершина `потомок` не учитывается, так как это потенциальный мост)
    
      - Отмечаем вершину `5` как посещённую.
     
	Пункт 6 повторяется пока не будут рассмотрены все пути, по которым можно пройти от вершины `0` (или `предка`):

	- Добавятся вершины, инцидентные `5`: `1`.
        
 	- Добавятся вершины, инцидентные `1`: `2`.
        
	- Добавятся вершины, инцидентные `2`: `3`, `4`.
        
	- Добавятся вершины, инцидентные `3`:

 	- Добавятся вершины, инцидентные `4`:
  
7. Проверяем наличие вершины `1` (`потомка`) в списке посещённых вершин:

-  `Список посещённых вершин`:  `0`,  `1`,  `5`,  `2`,  `3`,  `4`.
- Вершина `1` есть в списке, значит ребро `0-1` не является мостом.

## Реализация на C++

Код, выполняющий данный алгоритм:

```c++

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>

using namespace std;

/*Проверка на принадлежность множеству посещённых вершин*/
bool find(vector<int> visited, int elem) {
	for (int el : visited)
		if (el == elem)
			return true;

	return false;
}

bool ThisIsTheWay(vector<vector<int>> graph,  int predok,  int potomok) {

	vector<int> visited;

	visited.reserve(100);

	vector<int> tmp;

	visited.push_back(predok);

	int size = 0;

	while (true) {

		for (int a: tmp)
			if (!find(visited, a))
				visited.push_back(a);

		if (size != visited.size()) {

			size = visited.size();

			for (int v: visited)
				
				for (int el : graph[v])

						if (!find(visited, el) && !(el == potomok && v == predok))
							tmp.push_back(el);		
		}
		else {
			if (find(visited, potomok))
				return true;
			else
				return false;
		}
	}
}

int main() {

	setlocale(LC_ALL, "russian");

	vector<vector<int>> graph;

	string file;

	cout << "Введите название файла: "; cin >> file;

	ifstream graphfile(file);

		/*Граф читается из файла*/
	if (graphfile.is_open()) {

		string accident;

		while (getline(graphfile, accident)) {

			int vertex;
			int tmp;
			int n(0);

			istringstream vertexes(accident);

			while (vertexes >> vertex) {
				n++;
				if (n == 1) {
					tmp = vertex;
					graph.push_back(vector<int>());
				}
				else
					graph[tmp].push_back(vertex);
			}
		}
	}

	else
		std:: cout << "Ошибка при открытии файла!";

	std :: cout << "Мосты в графе: " << endl;

	for (int predok = 0; predok < graph.size(); predok++)

		for (int potomok : graph[predok])
			if (!ThisIsTheWay(graph, predok, potomok))
				std :: cout << predok << "->" << potomok << endl;

	return 0;
}
```

## Пояснение кода

### Подключение необходимых для работы кода библиотек.

```c++
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
```

- `<iostream>` - библиотека C++, позволяющая совершать ввод и вывод через консоль.
- `<fstream>` - библиотека C++, предоставляющая функции чтения или записи данных из файлов или в файлы.
- `<sstream>` - библиотека C++, предоставляющая функции для работы со строками.
- `<vector>` - библиотека C++, предоставляющая функции для работы с векторами.

### Фунция для поиска элемента в векторе
```c++
  bool find(vector<int> visited, int elem) {
	for (int el : visited)
		if (el == elem)
			return true;

	return false;
}
```

Функция `find` принимает в виде аргументов вектор посещённых вершин `visited` и проверяемую вершину.

Если вершина принадлежит вектору, функция возвращает значени `true`, в противном случае - `false`.

### Поиск альтернативного пути
```c++
bool ThisIsTheWay(vector<vector<int>> graph,  int predok,  int potomok) {

	vector<int> visited;

	visited.reserve(100);

	vector<int> tmp;

	visited.push_back(predok);

	int size = 0;

	while (true) {

		for (int a: tmp)
			if (!find(visited, a))
				visited.push_back(a);

		if (size != visited.size()) {

			size = visited.size();

			for (int v: visited)
				
				for (int el : graph[v])

						if (!find(visited, el) && !(el == potomok && v == predok))
							tmp.push_back(el);		
		}
		else {
			if (find(visited, potomok))
				return true;
			else
				return false;
		}
	}
}
```
Функция `ThisIsTheWay` принимает в виде аргументов исходный граф, вершину `предок` и вершину `потомок`.

Она возвращает значение `true`, если альтернативный путь существует и возвращает `false`, если такового нет.

### Чтение графа из файла и представление в виде двумерного вектора
```c++
	string file;

	cout << "Введите название файла: "; cin >> file;

	ifstream graphfile(file);

		/*Граф читается из файла*/
	if (graphfile.is_open()) {

		string accident;

		while (getline(graphfile, accident)) {

			int vertex;
			int tmp;
			int n(0);

			istringstream vertexes(accident);

			while (vertexes >> vertex) {
				n++;
				if (n == 1) {
					tmp = vertex;
					graph.push_back(vector<int>());
				}
				else
					graph[tmp].push_back(vertex);
			}
		}
	}

	else
		std:: cout << "Ошибка при открытии файла!";
```
Данный фрагмент кода запрашивает пользователя ввести название файла, содержащего граф и после

обрабатывает его, представляя в виде двумерного вектора для последующей работы программы.

### Поиск мостов

```c++
	std :: cout << "Мосты в графе: " << endl;

	for (int predok = 0; predok < graph.size(); predok++)

		for (int potomok : graph[predok])
			if (!ThisIsTheWay(graph, predok, potomok))
				std :: cout << predok << "->" << potomok << endl;
```
Данный цикл перебирает все вершины графа, вызывает функцию `ThisIsTheWay`, передавая ей значения `предок` и `потомок`

и в зависимости от возвращаемого результата функции предоставляет информацию о мостах в графе.

## Вывод
 
В результате выполнения расчётной работы приобрёл следующие навыки:
- изучил основы теории графов
- изучил способы представления графов
- освоил навыки работы с векторами и файлами в на языке программирования C++

## Список литературы
[1] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[2] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.

[3] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.
