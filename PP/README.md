# *Расчётная работа*
## Введение
### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами.
### Задание
5.6 Найти вершины с указанной степенью.

Реализовать на C++ код, который находит вершины графа с указанной степенью.

Граф(ориентированный) представляется в виде списка смежности(списка инцидентности).
### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Ориентированный граф (кратко орграф)` — граф, рёбрам которого присвоено направление.

`Список смежности` - один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

`Степень вершины графа` - это количество вершин, смежных с данной вершиной.

`Изолированная вершина` - вершина, не являющаяся концом ни для одного ребра.
## Алгоритм решения
Получаем из файла количество вершин графа, степень, вершины с которой будем искать и граф в виде списка смежности. Затем перебираем все вершины, смотря, сколько вершин связаны с текущей, выводя в файл список смежности. Также вместе с этим фиксируем номера вершин, которые связаны с числом других вершин, равным степени, вершины с которой ищем. При фиксировании такой вершины записываем её номер в отдельный массив. Затем выводим массив с вершинами, имеющими указанную степень, в файл.
## Реализация на С++
Код, выполняющий приведённый алгоритм:
```C++
#include <vector>
#include <fstream>
using namespace std;
int main()
{
	setlocale(LC_ALL, "Ru");
	int v;
	ifstream fin("Данные.txt");
	ofstream fout("Вершины.txt");
	fin >> v;
	if (v == 0)
	{
		fout << "Граф пуст";
		fin.close();
		fout.close();
		return 0;
	}
	int	i, k, n = 0, d, * deg = new int[v], s = 0; 
	
	fin >> d;
	vector<vector<int>> graph(v);
	for (i = 0; i < v; i++)
	{
		n = 0;
		vector<int> vec(v);
		do
		{
			fin >> k;
			if (k == 0)
				break;
			k = k - 1;
			vec[n] = k;
			n++;
		} while (true);
		vec.erase(vec.begin()+n, vec.end());
		graph[i] = vec;
	}
	fin.close();
	fout << "Полученный список смежности: " << endl;
	for (i = 0; i < v; i++)
	{
		fout << i + 1 << ": ";
		if (graph[i].size() == 0)
			fout << "Вершина изолированная";
		for (k = 0; k < graph[i].size(); k++)
		{
			fout << graph[i][k] + 1 << " ";
		}
		if (k == d)
		{
			deg[s] = i;
			s++;
		}
		fout << endl;
	}
	if (s == 0)
		fout << "Вершин со степенью " << d << " нет";
	else
	{
		fout << "Вершины со степенью " << d << ": ";
		for (i = 0; i < s; i++)
		{
			fout << deg[i] + 1 << " ";
		}
	}
	fout.close();
	delete []deg;
}
```
## Разбор кода
- `#include <vector>, #include <fstream>` : подключение библиотек, отвечающих за работу с векторами и сторонними файлами.
- `setlocale(LC_ALL, "Ru")` : обеспечение нормальной работы с русским языком.
- `int v` : иницивлизация переменной, которая будет хранить количество вершин графа.
- `ifstream fin("Данные.txt"), ofstream fout("Вершины.txt")` : определение команд классов вывода и ввода информации из и в файлы.
- `fin >> v` : ввод из файла количества вершин графа.
- `if (v == 0) fout  << "Граф пуст"` : Если введённое количество вершин равно 0, выводим в файл сообщение, что граф пуст.
- `fin.close() fout.close()` : свидетельства окончания ввода и вывода данных из файлов.
- `return 0` : Завершение программы.
- `int i, v = 0, k, n, d, * deg = new int[v], s = 0` : инициализация всех необходимых переменных и массивов.
- `fin >> d` : ввод из файла количества вершин и степени, вершины с которой будем искать.
- `vector<vector<int>> graph(v)` : инициализация основного графа в виде вектора векторов.
- `for (i = 0; i < v; i++)` : запуск цикла, с помощью которого получим граф из файла.
- `vector<int> vec(v)` : инициализация вектора, который будет содержать вершины, связанные с i-той.
- `do while (true)` : запуск бесконечного цикла (выход из которого реализован в самом цикле при нужном условии).
- `fin >> k` : ввод из файла вершины, связанной с i-той.
- `if (k == 0) break` : условие, реализующее выход из бесконечного цикла, если пользователь введёт 0.
- `k = k - 1` : уменьшение номера вершины на единицу для учёта счёта цикла с нуля.
- `vec[n] = k` : присваивание n-ому элементу вектора значения введённой вершины.
- `n++` : увеличение размера вектора на 1.
- `vec.erase(vec.begin()+n, vec.end())` : удаление 0, введённого пользователем, который означал окончание ввода вершин, связанных с i-той вершиной.
- `graph[i] = vec` : Копирование полученного списка вершин (вектора) к i-тому вектору вектора векторов (основного графа).
- `fin.close()` : свидетельство окончания вывода данных из файла.
- `fout << "Полученный список смежности: " << endl, for (i = 0; i < v; i++)` : объявление в конечный файл полученного списка смежности и запуск цикла, реализующего этот вывод (заодно и подсчёт вершин с заданной степенью).
- `fout << i + 1 << ": "` :  вывод в файл номера i-той вершины (с учётом счёта с 0).
- `if (graph[i].size() == 0) fout << "Вершина изолированная"` : условие вывода в файл соответствующего сообщения, если вершина изолированная.
- `for (k = 0; k < graph[i].size(); k++)` : начало цикла, выводящего в файл вершины, связанные с i-той.
- `fout << graph[i][k] + 1 << " "` : вывод каждой вершины, связанной с i-той (с учётом счёта с 0).
- `if (k == d) deg[s] = i, s++` : если количество вершин, связанных с i-той равно степени, вершины с которой ищем, заносим номер этой вершины в массив, содержащий список этих вершин, и увеличение на один переменной s, отслеживающей их количество.
- `if (s == 0) fout << "Вершин со степенью " << d << " нет"` : если предыдущему условию не удовлетворила ни одна вершина, ввести в файл соответствующее сообщение.
- `else fout << "Вершины со степенью " << d << ": "` : иначе объявить о начале вывода в файл удовлетворивиших условию вершин.
- `for (i = 0; i < s; i++)` : запуск цикла, выводящего в файл номера этих вершин.
-	`fout << deg[i] + 1 << " "` : вывод этих вершин (с учётом счёта с 0).
-	`fout.close()` : свидетельство окончания вывода данных в файл.
- `delete[]deg` : очищение памяти после использования динамического массива.
## Тестирование
Все тесты и наглядные изображения графов, участвующих в них, можно посмотреть [здесь](https://github.com/iis-32170x/RPIIS/tree/%D0%90%D0%B1%D1%80%D0%B0%D0%BC%D0%BE%D0%B2_%D0%94/PP/%D0%A2%D0%B5%D1%81%D1%82%D1%8B).
## Вывод
В результате выполнения расчётной работы приобрёл следующие навыки:

- изучил основы теории графов
- изучил способы представления графов
- изучил базовые алгоритмы для работы с графами
- изучил базовые алгоритмы работы с векторами, файлами в C++
