# Расчётная работа   ПРИМЕР С ОДНОЙ ОТДЕЛЬНОЙ ВНРШИНОЙ

### Цель

Формализовать выполнение алгоритма в виде SCg-кода.

### Задание

Реализовать на C++ код, который может найти в неориентированном взвешенном графе минимальный простой разрез.

### Ключевые понятия

`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями. 

Графы, в которых все ребра являются звеньями, то есть порядок двух концов ребра графа не существенен, называются `неориентированными`. 

`G` - неориентированный взвешенный граф с n вершинами и m рёбрами.

`Матрица смежности` - это вид представления графа в виде матрицы, когда пересечение столбцов и строк задаёт дуги. Используя матрицу смежности, можно задать вес дуг и ориентацию. Каждая строка и столбец матрицы соответствуют вершинам, номер строки соответствует вершине, из которой выходит дуга, а номер столбца - в какую входит дуга.

`Весом разреза` называется сумма весов рёбер, проходящих через разрез, т.е. таких рёбер, один конец которых принадлежит A, а второй конец - B.

`Взвешенный граф` — граф, каждому ребру которого поставлено в соответствие некое значение (вес ребра)

`Разрезом` называется такое разбиение множества V на два подмножества A и B, что: A,B⊂V;   A,B≠∅;  A∩B=∅;  A∪B=V.

`Наименьший (минимальный) разрез графа` — это разрез с минимально возможным весом.

### Алгоритм решения 

1. Создаём множество непосещённых вершин.
2. Создаём счетчик минимального разреза minR=inf.
3. Создаём множество вершин А, куда последовательно будут добавляться вершины с большим весом.
4. Создаём счётчик n-1 фаз, где n - количество вершин в графе. 
5. Добавляем произвольную вершину в множество А
6. Из смежных вершин к множеству А, добавляем в множество вершину с большим весом.
   6.1. Повторяем процесс до n-1 фазы (включая предпоследнюю вершину(s))
7. Если вес последней недобавленной вершины(t) меньше записанного минимального разреза в minR, то перезаписываем его в minR.
8. Сливаем две последние вершины в одну.
9. Очищаем множество А
10. Если n = 1 (в графе осталась одна вершина), то выводим результат и завершаем алгоритм.
11. Если n не равно 1, то переходим к пункту 5. 

### Демонстрация алгоритма


##### Переменная `graph` получает в качестве значения sc-узел неориентированного взвешенного графа
![images](10.png)
***

##### Переменная `not_added_vertexes` получит в качестве значения множество недобавленных в множество вершин
![image](11.png)
***

##### Создаём счётчик `number_of_vertexes` равный 5
![image](20.png)
***

##### Добавляем переменную `_min_cut` со значением ∞
![image](30.png)
***

##### Создание волны, включающей вершину *1v*
![image](31.png)
***

##### Создание волны, включающей вершину *3v*
![image](32.png)
***

##### Создание волны, включающей вершину *2v*
![image](33.png)
***

##### Создание волны, включающей вершину *5v*
![image](34.png)
***

##### Создание волны, включающей вершину *4v*
![image](35.png)
***

##### В счётчик _min_cut записываем вес вершины *4v* = 6, так как он меньше бесконечности
Объединяем вершины *4v* и *5v*
_number_of_vertexes уменьшаем на один 
Удаляем множество посещённых вершин
Создаём волну, включающуюю вершину *1v*
![image](41.png)
***

##### Создание волны, включающей вершину *3v*
![image](42.png)
***

##### Создание волны, включающей вершину *2v*
![image](43.png)
***

##### Создание волны, включающей вершину *5v,4v*
![image](44.png)
***

##### Объединяем вершины *2v* и *4v,5v*
_number_of_vertexes уменьшаем на один 
Удаляем множество посещённых вершин
Создаём волну, включающуюю вершину *1v*
![image](51.png)
***

##### Создание волны, включающей вершину *3v*
![image](52.png)
***

##### Создание волны, включающей вершину *2v*
![image](53.png)
***

##### Объединяем вершины *3v* и *2v,4v,5v*
_number_of_vertexes уменьшаем на один 
Удаляем множество посещённых вершин
Создаём волну, включающуюю вершину *1v*
![image](61.png)
***

##### Создание волны, включающей вершину *3v,2v,5v,4v*
![image](62.png)
***

##### Объединяем вершины *1v* и *3v,2v,4v,5v*
_number_of_vertexes уменьшаем на один 
Удаляем множество посещённых вершин
![image](70.png)
***

##### Результат работы алгоритма:
_min_cut = 6
***

### Тестовые примеры

#### Тест №1

##### Входные данные
![image](test_1_input.png)


##### Выходные данные
![image](test_1_output.png)
***

#### Тест №2

##### Входные данные
![image](test_2_input.png)


##### Выходные данные
![image](test_2_output.png)
***

#### Тест №3

##### Входные данные
![image](test_3_input.png)


##### Выходные данные
![image](test_3_output.png)
***

#### Тест №4

##### Входные данные
![image](test_4_input.png)


##### Выходные данные
![image](test_4_output.png)
***

#### Тест №5

##### Входные данные
![image](test_5_input.png)


##### Выходные данные
![image](test_5_output.png)
***

### Вывод

В результате выполнения данной расчётной работы был формализован алгоритм нахождения минимального разреза графа.

### Источники

- [Руководство к выполнению РР](https://drive.google.com/drive/folders/1RSriLOZWpxyozHjUa1Kz3uZtIr0PixVh)