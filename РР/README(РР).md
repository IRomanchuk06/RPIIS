# ПиОИвИС - Расчётная работа

## Разработка программы решения теоретико-графовой задачи
### Задание 5.10
<em>Условие</em>: Найти максимальный простой разрез взвешенного неориентированного графа, заданного матрицей инцидентности.

<h2>Ключевые понятия</h2>

**<em>Граф</em>** — математическая абстракция системы любого рода, объекты которой обладают парными связями; как математический объект — это совокупность двух множеств — множества самих объектов (вершин) и множества их парных связей (рёбер). <br>
<br>
Граф называется **<em>взвешенным</em>**, если его рёбра (и/или вершины) несут добавочную информацию, т.е. вес.

Граф называется **<em>неориентированным</em>**, если ни одному ребру которого не присвоено направление; граф, в котором все связки являются ребрами.

Термин **<em>«разрез»</em>** относится к разделению графа на два непересекающихся набора вершин, при этом все ребра, соединяющие два набора, удаляются. <br>
![image](https://github.com/iis-32170x/RPIIS/assets/146581542/cb540c58-63ce-41b5-a308-dbddc94c0704)

**Максимальный разрез графа** — это разрез, размер которого не меньше размера любого другого разреза. Для взвешенного графа сумма весов всех ребер на разрезе определяет, является ли это максимальным разрезом.

**Матрица инцидентности** — способ представления графа в виде структуры данных, в которой указываются связи между инцидентными элементами графа (ребро(дуга) и вершина).

**Смежность** — "примыкание"; в теории графов смежность вершин соответствует наличию ребра между ними.

**Инцидентность** — вершина и ребро называются инцидентными, если вершина является для этого ребра концевой.

## Алгоритм
Для решения задачи необходимы следующие переменные:
1.	Множество вершин графа (_versh).
2.	Множество ребер разреза (_rebra).
3.	Вершина с максимальным весом (_max).

### Описание алгоритма:
*Введем термин **<em>вес вершины</em>** – сумма весов ребер, инцидентных данной вершине.
1.	Заносим вершины  графа во множества _ versh и _rebra соответственно. 
2.	Дальше мы проходим по множеству вершин _versh, для каждой вершины считаем вес и находим вершину с максимальным весом (_max). 
3.	Удаляем ребра, связанные с вершиной (_max) и уменьшаем веса вершин, смежных ей на удвоенный вес ребра, а вес самой вершины (_max) приравниваем 0.
<br> a.	Если не осталось вершин с положительным весом, то переходим к шагу 5.
<br> b.	 Если вершины остались, то возвращаемся к шагу 2.
4.	Из множества ребер начального графа исключаем ребра из множества (_rebra), а также ребра, которые связывали вершины с максимальными весами.
5.	Выводим максимальный простой разрез на экран.
#### Конец алгоритма.

## Код программы

```C++
#include<set>
#include<tuple>
#include<vector>
#include<fstream>
#include<iostream>
using namespace std;

int main()
{
//Кириллица в консоли
	setlocale(LC_CTYPE, "rus");
	int number;
	fstream fin;
	cout << "Введите номер графа (от 1 до 5): " << endl;
	cin >> number;
//Массив строк с путями к файлам
	string file_paths[] = {
	"C:\\Users\\Acer\\Desktop\\1 КУРС\\РР\\tests\\in1.txt",
	"C:\\Users\\Acer\\Desktop\\1 КУРС\\РР\\tests\\in2.txt",
	"C:\\Users\\Acer\\Desktop\\1 КУРС\\РР\\tests\\in3.txt",
	"C:\\Users\\Acer\\Desktop\\1 КУРС\\РР\\tests\\in4.txt",
	"C:\\Users\\Acer\\Desktop\\1 КУРС\\РР\\tests\\in5.txt"
	};

	if (number >= 1 && number <= 5) {
//Ввод из файла с именем in в формате: первая строка - кол-во ребёр,
//последующие - структуры "Начальная_Вершина_n Конечная_Вершина_n Вес_Ребра_Связи"
		fin.open(file_paths[number - 1], ios::in);
	}
	else {
		cout << "Некорректный номер графа" << endl;
//Выход из программы в случае неверного ввода
		return 1;                                 
	}
//Вывод в файл с именем result в формате:
//первая строка - общий вес разреза, последующие строки - рёбра разреза
	ofstream fout("C:\\Users\\Acer\\Desktop\\1 КУРС\\РР\\tests\\result.txt");
//Матрица инцидентности
	vector<pair<pair<int, int>, int>> graph;
//Вектор, отвечающий за вес каждой вершины	
	vector<int> value_versh;
//Подмножество вершин, полученное в результате разреза					
	set<int> versh_raz;
//Суммарный вес разреза						
	int sum_value = 0;
//Кол-во рёбер в графе							
	int N;
//Заполнение списка инцидентности								
	fin >> N;
	int size = N;
	while (size) {
		int first_v;  //Первая вершина в ребре							
		int second_v; //Вторая вершина в ребре							
		int value;    //Вес ребра
		fin >> first_v;
		fin >> second_v;
		fin >> value;
//Добавление ребра в матрицу инцидентности
		graph.push_back(pair<pair<int, int>, int>(pair<int, int>(first_v, second_v), value));	
		size--;
	}
//Добавление нулевой вершины, чтобы отсчёт вершин шёл с единицы
	value_versh.push_back(0);
//Заполнение веса вершин, номер вершины = её индекс в векторе														
	for (int i = 1, value = 0; ; i++, value = 0) {
		for (int j = 0; j < graph.size(); j++) {
			if (graph[j].first.first == i || graph[j].first.second == i) //Если вершина принадлежит ребру
				value += graph[j].second;  //То добавить вес ребра к весу вершины											
		}
		if (value == 0)	break;	//Если вес равен нулю, значит прошлая вершина была последняя														
		value_versh.push_back(value);   //Добавляем вес вершины в вектор 											
	}
	do {
		int max = 0;
		for (int i = 1; i < value_versh.size(); i++) {
			if (value_versh[i] > value_versh[max]) max = i;	 //Ищем вершину с максимальным весом						
		}
		if (value_versh[max] > 0) {	//Вес вершины должен быть больше нуля												
			sum_value += value_versh[max];	//Прибавляем вес вершины в итоговый вес разреза										
			value_versh[max] = 0;	//Обнуляем вес вершины, чтобы не взять её снова 												
			versh_raz.insert(max);	 //Добавляем эту вершину в множество
//Ищём рёбра инцидентные вершине с максимальным весом										
			for (int i = 0; i < graph.size(); i++) {								
				if (graph[i].first.first == max) {
//Вычитаем 2 раза вес инцидентного ребра из веса смежной вершины
//Один раз вычитаем, потому что данное ребро пойдет в разрез
//Второй раз — чтобы проверить, выгодно ли добавлять смежную вершину в множество													
					value_versh[graph[i].first.second] -= graph[i].second * 2;
				}
//Вершина может стоять как на первом месте ребра, так и на втором																
				if (graph[i].first.second == max) {
					value_versh[graph[i].first.first] -= graph[i].second * 2;
				}  																	
			}

		}
		else break;
	} while (1);
	fout << sum_value << endl;	//Выводим суммарный вес разреза													
	for (const int& a : versh_raz)
	{
		for (int i(0); i < graph.size(); i++)	//Выводим все рёбра, входящие в разрез									
		{
//Если вершина стоит на первом месте ребра и вершина на втором месте 
			if (graph[i].first.first == a && versh_raz.find(graph[i].first.second) == versh_raz.end())
//не относится к тому же множеству			
				fout << graph[i].first.first << ' ' << graph[i].first.second << ' ' << graph[i].second << endl;
//Если вершина стоит на втором месте ребра и вершина на первом месте 
			if (graph[i].first.second == a && versh_raz.find(graph[i].first.first) == versh_raz.end())
//не относится к тому же множеству			
				fout << graph[i].first.first << ' ' << graph[i].first.second << ' ' << graph[i].second << endl;		
		}
	}
	cout << " Результат разреза записан в файл result.txt";
	return 0;
}
```

## Структура txt-файла
Вводный txt-файл должен иметь следующую структуру:<br>
Количество_рёбер<br>
Начальная_Вершина_1 Конечная_Вершина_1 Вес_Ребра_Связи_1<br>
Начальная_Вершина_2 Конечная_Вершина_2 Вес_Ребра_Связи_2<br>
...<br>
Где все значения являются целыми положительными числами.<br>

## Тест программы
1) Граф 1: макс. вес = 4+5+1+3=13
***
![1](https://github.com/iis-32170x/RPIIS/assets/146581542/0f184667-0a08-42f9-b485-307b3b95749a)
***
2) Граф 2: макс. вес = 5+5+7=17
***
![2](https://github.com/iis-32170x/RPIIS/assets/146581542/096151f4-8cec-4680-9b86-ea0b83e9abc0)
***
3) Граф 3: макс. вес = 5+4+6+3=19
***
![3](https://github.com/iis-32170x/RPIIS/assets/146581542/8744dab6-55a8-43bc-90a2-676644423c7e)
***
4) Граф 4: макс. вес = 6+6+4+2+5=23
***
![4](https://github.com/iis-32170x/RPIIS/assets/146581542/7468b289-ceab-462a-adca-ed4532f2b1b5)
***
5) Граф 5: макс. вес. = 2+4+7+3=16
***
![5](https://github.com/iis-32170x/RPIIS/assets/146581542/08170af6-c0f2-4fad-86c6-81faf28983e6)
***

## Вывод
В ходе работы я приобрела следующие знания и навыки:
- изучила основы теории графов;
- изучила способы представления графов;
- изучила базовые алгоритмы работы с информацией, представленной в виде графов;
- изучила базовые алгоритмы работы с векторами на языке C++.

## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.
