# Расчётная работа
## Введение
### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами.
### Задание
2.1. Радиус взвешенного ориентированного графа

Реализовать на C++ код, который может найти радиус взвешенного орграфа.

Граф представляется в виде матрицы инцидентности.

### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Эксцентриситет` - это максимальное расстояние от данной вершины до всех остальных вершин в графе.

`Радиус графа` - это минимальный эксцентриситет всех вершин в графе.

`Ориентированный граф ` —  это граф, в котором каждое ребро имеет направление. То есть, каждое ребро в ориентированном графе указывает на направление от одной вершины, называемой начальной вершиной, к другой вершине, называемой конечной вершиной.

`Матрица инцидентности` - это матрица, которая представляет собой инструмент для описания ориентированного или неориентированного графа.

`Взвешенный граф` - это граф, в котором каждому ребру присвоено числовое значение, называемое весом.

`Алгоритм поиска кратчайших путей` - это алгоритм, используемый для нахождения кратчайшего пути между двумя вершинами в графе или для нахождения кратчайших путей от одной вершины до всех остальных вершин. Алгоритмы поиска кратчайших путей, такие как алгоритм Дейкстры или алгоритм Флойда-Уоршелла, могут быть использованы для нахождения расстояний между вершинами и, следовательно, для определения эксцентриситета вершин и радиуса графа.

## Алгоритм решения

Алгоритм определяет, можно ли найти радиус графа.

Алгоритм решения построен на алгоритме Флойда-Уоршелла.

Алгоритм Флойда игнорирует петли.

В процессе работы алгоритм обрабатывает матрицу A.

Граф задаётся матрицей инцидентности.

Граф должен быть связным: Все вершины графа должны быть достижимы из любой другой вершины. Если граф несвязный (состоит из нескольких компонент связности), то каждая компонента связности должна быть обработана отдельно для нахождения радиуса.

Граф должен быть ориентированным: Взвешенный ориентированный граф имеет направления на ребрах, что влияет на алгоритмы для нахождения радиуса. Ориентация ребер указывает на направление обхода и влияет на определение пути между вершинами.

Граф не должен содержать отрицательных циклов: Наличие отрицательных циклов может создать проблемы при определении радиуса, так как можно бесконечно уменьшать расстояния, обходя циклы. Если граф содержит отрицательные циклы, алгоритмы нахождения радиуса могут не дать корректных результатов.

Граф должен быть взвешенным: Для определения радиуса требуется наличие весов на ребрах графа, которые указывают на стоимость перехода между вершинами. Веса ребер могут быть положительными, нулевыми или отрицательными, но должны быть определены.

Если граф успешно проходит все эти проверки, то можно найти радиус. Этот алгоритм работает для взвешенных ориентированных графов.

*Приведём пример работы алгоритма:*

Рассмотрим пример графа с помощью матрицы инцидентности.

Предположим, у нас есть граф с 3 вершинами и 4 ребрами.

Матрица инцидентности для этого графа будет иметь размерность 4x5, где строки соответствуют вершинам, а столбцы соответствуют ребрам. Значение n(n-число) в ячейке указывает, что вершина инцидентна ребру, а значение 0 указывает на отсутствие инцидентности.

Пример матрицы инцидентности:

![matrix](https://github.com/iis-32170x/RPIIS/blob/Свиридо_Е/РР/матрица.png)

Полученный граф:

![matrix](https://github.com/iis-32170x/RPIIS/blob/Свиридо_Е/РР/граф1.png)

Алгоритм обрабатывает матрицу А. Именно в этой матрице будут находиться кратчайшие пути между парами вершин. Матрица А - это матрица смежности. Её размер nxn (где n - количество вершин графа). В нашем пример у графа 3 вершины, поэтому матрица имеет размеры 3x3. На главной диагонали всегда расположены нули. Исходя из веса и направления дуг получаем матрицу: 

![m1](https://github.com/iis-32170x/RPIIS/blob/Свиридо_Е/РР/m1.png)

После всех этих итераций мы нашли кратчайшие пути из одной вершины в другую.

Для нахождения радиуса выберем одну вершины и в её строке выберем наибольшее число

На k-ой итерации мы подставляем k-ую вершину. Таким образом, если на существующем кратчайшим пути подставляется вершина k и этот путь оказывается короче, то мы его принимаем за кратчайший путь, изменяя значения матрицы А.

Рассмотрим 1-ую (k=1) итерацию:

![m2](https://github.com/iis-32170x/RPIIS/blob/Свиридо_Е/РР/m2.png)

Проходя через 1-ую вершину появились новые кратчайшие пути и новые значения вместо знака бесконечности.

Также делаем ещё 2 итерации:

k=2:

![m3](https://github.com/iis-32170x/RPIIS/blob/Свиридо_Е/РР/m3.png)

k=3:

![m4](https://github.com/iis-32170x/RPIIS/blob/Свиридо_Е/РР/m4.png)

После всех итераций мы нашли кратчайшие пути из одной вершины в другую.

Для нахождения радиуса выберем 1-ю вершину и в её строке выберем наибольшее число.

В 1-ой строке этим числом является число 7.

## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.

[7] База знаний по теории графов OSTIS GT [Электронный ресурс] / проект OSTIS, 2012. –
Режим доступа: http://ostisgraphstheo.sourceforge.net. — Дата доступа : 11.09.2012.

