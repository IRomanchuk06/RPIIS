# Расчетная работа 

## Введение

### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами.
### Задание
5.4 (ми) Найти кол-во компонент связности в неориентированном графе.

Реализовать на C++ код, который может найти кол-во компонент связности в неориентированном графе.

Используется неориентированный граф.

Граф представляется в виде матрицы инцидентности.

### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Неориентированный граф` —  граф, рёбрам которого не присвоено направление.

`Инцидентность` - Инцидентность – понятие, используемое только в отношении ребра и вершины: две вершины (или два ребра) инцидентными быть не могут. 

`Подграф` — это часть графа, в которой мы берем некоторые его вершины и ребра.

`Путь в графе` – это последовательность рёбер, в которой конец каждого ребра (кроме последнего) совпадает с началом следующего.
Замкнутый путь называется циклом. 

`Цикл` — граф, состоящий из единственного цикла, или, другими словами, некоторого числа вершин, соединённых замкнутой цепью

`Смежность` — понятие, используемое в отношении только двух рёбер либо только двух вершин: Два ребра, инцидентные одной вершине, называются смежными; две вершины, инцидентные одному ребру, также называются смежными. 

## Алгоритм DFS

Решение задачи основано на алгоритме поиска в глубину(deep first search).

# Описание алгоритма
Алгоритм поиска в глубину (Depth-First Search, DFS) — это один из основных алгоритмов обхода и поиска в графах. Он позволяет обойти все вершины графа, достигнув каждую вершину как можно глубже, прежде чем возвращаться назад.
Поэтапно алгоритм работает следующим образом:

1. Инициализация:
Выбирается начальная вершина.
Создаётся пустой стек.
Создаётся массив для отслеживания посещённых вершин.

2. Обход:
Текущая вершина помечается как посещённая и добавляется в стек.
Если требуется, выполняются операции с текущей вершиной.
Выбирается следующая непосещённая смежная вершина и переходим к шагу 3.

3. Рекурсивное продолжение или возврат:
Если есть непосещённая смежная вершина, переходим к ней и повторяем шаги 2 и 3.
Если все смежные вершины уже посещены, возвращаемся к предыдущей вершине, извлекаем её из стека и переходим к шагу 3.
Если стек пуст и все вершины посещены, алгоритм завершается.

Теперь представим этот граф в виде матрицы инциденстности:

![image](https://github.com/iis-32170x/RPIIS/assets/143909949/39554364-a7b6-4a61-88c5-02ce11818301)


Начинаем обход по вершинам графа.

Начинаем с вершины 0. Она еще не посещена, поэтому увеличиваем счетчик компонент связности на 1 и вызываем функцию DFS для обхода связной компоненты.

В функции DFS:

Помечаем текущую вершину 0 как посещенную и добавляем ее в стек.

Проходим по смежным вершинам. Единственная смежная вершина — вершина 1. Она не была посещена, поэтому вызываем DFS для нее.

В функции DFS для вершины 1:

Помечаем вершину 1 как посещенную и добавляем ее в стек.

Проходим по смежным вершинам. Единственная смежная вершина — вершина 2. Она не была посещена, поэтому вызываем DFS для нее.

В функции DFS для вершины 2:

Помечаем вершину 2 как посещенную и добавляем ее в стек.

Проходим по смежным вершинам. Единственная смежная вершина — вершина 3. Она не была посещена, поэтому вызываем DFS для нее.

В функции DFS для вершины 3:

Помечаем вершину 3 как посещенную идобавляем ее в стек.
Проходим по смежным вершинам. Единственная смежная вершина — вершина 2. Она уже посещена, поэтому переходим к следующей смежной вершине.
Завершаем обход всех смежных вершин для вершины 3 и извлекаем ее из стека.
Возвращаемся к функции DFS для вершины 2.

Завершаем обход всех смежных вершин для вершины 2 и извлекаем ее из стека.

Возвращаемся к функции DFS для вершины 1.

Завершаем обход всех смежных вершин для вершины 1 и извлекаем ее из стека.

Возвращаемся к функции DFS для вершины 0.

Завершаем обход всех смежных вершин для вершины 0 и извлекаем ее из стека.

Переходим к следующей вершине 1. Она уже была посещена в предыдущем обходе, поэтому пропускаем ее.

Переходим к следующей вершине 2. Она уже была посещена в предыдущем обходе, поэтому пропускаем ее.

Переходим к следующей вершине 3. Она уже была посещена в предыдущем обходе, поэтому пропускаем ее.

Переходим к последней вершине 4. Она еще не была посещена, поэтому увеличиваем счетчик компонент связности на 1 и вызываем функцию DFS для обхода связной компоненты.

В функции DFS для вершины 4:

Помечаем вершину 4 как посещенную и добавляем ее в стек.
Проходим по смежным вершинам. В данном случае смежных вершин нет, поэтому завершаем обход всех смежных вершин для вершины 4 и извлекаем ее из стека.
Возвращаемся к шагу обхода и продолжаем поиск не посещенных вершин.

В данном случае все вершины уже были посещены, поэтому завершаем обход.

## Реализация на C++

Код, выполняющий алгоритм
``` c++
#include <iostream>
#include <vector>

using namespace std;

class Graph {
private:
    int numVertices;
    vector<vector<int>> incidenceMatrix;
    vector<bool> visited;

public:
    Graph(const vector<vector<int>>& matrix) : incidenceMatrix(matrix) {
        numVertices = matrix.size();
        visited.resize(numVertices, false);
    }

    void DFS(int v) {
        visited[v] = true;

        for (int u = 0; u < numVertices; ++u) {
            if (incidenceMatrix[v][u] == 1 && !visited[u]) {
                DFS(u);
            }
        }
    }

    int countConnectedComponents() {
        int count = 0;

        for (int v = 0; v < numVertices; ++v) {
            if (!visited[v]) {
                DFS(v);
                count++;
            }
        }

        return count;
    }

    vector<vector<int>> findConnectedComponents() {
        vector<vector<int>> connectedComponents;

        for (int v = 0; v < numVertices; ++v) {
            if (!visited[v]) {
                vector<int> component;
                DFS(v);
                connectedComponents.push_back(component);
            }
        }

        return connectedComponents;
    }
};

int main() {
    setlocale(LC_ALL, "RU");
    // Пример графа с матрицей инцидентности
    vector<vector<int>> incidenceMatrix = {
        {1, 0, 0, 0, 0},
        {1, 0, 1, 0, 0},
        {0, 0, 0, 0, 1},
        {0, 0, 1, 0, 1},
        {0, 0, 0, 0, 0}
    };

    Graph graph(incidenceMatrix);

    // Подсчет количества компонент связности
    int numComponents = graph.countConnectedComponents();

    // Вывод количества компонент связности
    cout << "Количество компонент связности: " << numComponents << endl;
  

    return 0;
}
```

## Разбор кода:
#include <iostream>
#include <vector>

using namespace std;
Эти строки подключают необходимые библиотеки для работы с вводом-выводом и векторами.



class Graph {
private:
    int numVertices;
    vector<vector<int>> incidenceMatrix;
    vector<bool> visited;

public:
    Graph(const vector<vector<int>>& matrix) : incidenceMatrix(matrix) {
        numVertices = matrix.size();
        visited.resize(numVertices, false);
    }
Здесь определен класс Graph, который представляет неориентированный граф. У него есть приватные данные:

numVertices - количество вершин в графе,
incidenceMatrix - матрица инцидентности графа,
visited - вектор для отслеживания посещенных вершин.
Конструктор класса Graph принимает матрицу инцидентности в качестве аргумента. Он инициализирует поля incidenceMatrix и numVertices, а также создает вектор visited размером numVertices и заполняет его значениями false.
void DFS(int v) {
    visited[v] = true;

    for (int u = 0; u < numVertices; ++u) {
        if (incidenceMatrix[v][u] == 1 && !visited[u]) {
            DFS(u);
        }
    }
}
Метод DFS (Depth-First Search) рекурсивно выполняет обход графа в глубину, начиная с вершины v. Он помечает вершину v как посещенную, а затем рекурсивно вызывает себя для всех смежных вершин, которые еще не были посещены.
int countConnectedComponents() {
    int count = 0;

    for (int v = 0; v < numVertices; ++v) {
        if (!visited[v]) {
            DFS(v);
            count++;
        }
    }

    return count;
}
Функция countConnectedComponents подсчитывает количество компонент связности в графе. Он инициализирует переменную count нулем и затем выполняет обход графа в глубину для каждой вершины, которая еще не была посещена. После каждого такого обхода увеличивает счетчик count на единицу. В итоге метод возвращает общее количество компонент связности в графе.
vector<vector<int>> findConnectedComponents() {
    vector<vector<int>> connectedComponents;

    for (int v = 0; v < numVertices; ++v) {
        if (!visited[v]) {
            vector<int> component;
            DFS(v);
            connectedComponents.push_back(component);
        }
    }

    return connectedComponents;
}
Функция findConnectedComponents находит все компоненты связности в графе. Он создает вектор connectedComponents для хранения компонент связности. Затем выполняет обход графа в глубину для каждой вершины, которая еще не была посещена. После завершения каждого обхода, он добавляет компоненту связности в вектор connectedComponents. В итоге метод возвращает вектор всех найденных компонент связности.
int main() {
    setlocale(LC_ALL, "RU");
    // Пример графа с матрицей инцидентности
    vector<vector<int>> incidenceMatrix = {
        {1, 0, 0, 0, 0},
        {1, 0, 1, 0, 0},
        {0, 0, 0, 0, 1},
        {0, 0, 1, 0, 1},
        {0, 0, 0, 0, 0}
    };

    Graph graph(incidenceMatrix);

    // Подсчет количества компонент связности
    int numComponents = graph.countConnectedComponents();

    // Вывод количества компонент связности
    cout << "Количество компонент связности: " << numComponents << endl;

    return 0;
}
В функции main создается экземпляр класса Graph с заданной матрицей инцидентности. Затем вызывается метод countConnectedComponents для подсчета количества компонент связности в графе. Результат выводится на экран.
## Вывод
В результате я приобрёл следующие навыки:
- изучил основы теории графов
- изучил базовые алгоритмы для работы с графами
- изучил способы представления графов
- изучил базовые алгоритмы работы с векторами в C++
## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.

