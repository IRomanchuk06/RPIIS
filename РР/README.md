# Расчетная работа 

## Введение

### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами, 
### Задание
2.13(Обхват графа)

Реализовать на C++ код, который может найти обхват орграфа.

Граф представляется в виде списка смежности(списка инцидентности).

### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Ориентированный граф (кратко орграф)` —  граф, рёбрам которого присвоено направление.

`Список смежности` - один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

`Путь в графе` – это последовательность рёбер, в которой конец каждого ребра (кроме последнего) совпадает с началом следующего.
Замкнутый путь называется `циклом`. 

`Обхват графа` — длина наименьшего цикла, содержащегося в данном графе. Если граф не содержит циклов (то есть является `ациклическим графом`), его обхват по определению равен бесконечности.

`Обход в ширину (breadth-first search, BFS)` систематически обходит все вершины графа

Графический пример обхода в ширину:

![image](https://github.com/iis-32170x/RPIIS/assets/144383538/2684132b-37f0-4310-a2f7-9ed034df4b2a)

## Алгоритм решения

Выполняет поиск кратчайшего цикла в графе. Применяем поиск в ширину (BFS) для каждой вершины графа, чтобы определить минимальную длину цикла, начинающегося в этой вершине.

Начинаем поиск с каждой вершины и инициируем очередь для выполнения поиска в ширину. Для каждой вершины в очереди, рассматриваем всех соседей этой вершины и добавляем их в очередь, если они еще не были посещены. Если один из соседей совпадает с начальной вершиной, то обновляем минимальную длину найденного цикла.

Затем  возвращаем минимальную длину цикла в графе. Если такой цикл не найден, это значит что граф является ациклическим и его обхват равен бесконечности.

Чтобы было немного понятней, привидём простенький пример работы алгоритма:

Исходный граф:

![image](https://github.com/iis-32170x/RPIIS/assets/144383538/bf12521b-850b-4052-9898-95e7e92c2c40)

Теперь представим этот граф в виде списка смежности:

> - `0 -> 1`
> - `1 -> 2`
> - `1 -> 3`
> - `2 -> 3` 
> - `3 -> 0`

1. Начинаем с вершины 0:

- Добавляем вершину 0 в очередь с расстоянием 0.

- Распространяемся по смежным вершинам: добавляем вершину 1 в очередь с расстоянием 1.

2. Переходим к вершине 1:

- Распространяемся по смежным вершинам: добавляем вершины 2 и 3 в очередь с расстоянием 2.

- Обнаруживаем, что смежная вершина 3 смежна с начальной вершиной 0, обновляем минимальное расстояние до цикла = 3.

3. Переходим к вершине 2:

- Распространяемся по смежным вершинам: добавляем вершину 3 в очередь с расстоянием 3.

- Обнаруживаем, что смежная вершина 3 смежна с начальной вершиной 0, но расстояние 4 больше минимального, поэтому не обновляем минимальное расстояние.

4. Переходим к вершине 3:

- Распространяемся по смежной вершине 0, но она уже была посещена, поэтому не добавляем в очередь.

Таким образом, минимальная длина цикла в данном графе равна 3 (0 -> 1 -> 3 -> 0).

## Реализация на C++

Код, выполняющий наш алгоритм:

```c++

#include <iostream>
#include <fstream>
#include <vector>
#include <queue>
using namespace std;

int shortestCycle(vector<vector<int>>& adjList, int n) {
    int minCycle = n + 1;

    for (int i = 0; i < n; i++) {
        vector<bool> visited(n, false);
        queue<pair<int, int>> q;
        q.push({ i, 0 });

        while (!q.empty()) {
            int cur = q.front().first;
            int dist = q.front().second;
            q.pop();

            for (int neighbor : adjList[cur]) {
                if (neighbor == i) {
                    minCycle = min(minCycle, dist + 1);
                }
                else if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push({ neighbor, dist + 1 });
                }
            }
        }
    }

    if (minCycle == n + 1) {
        return -1;
    }
    else {
        return minCycle;
    }
}

int main() {
   setlocale(LC_ALL, "ru");
string line;
cout << "Введите файл: ";
cin >> line;
ifstream inputFile(line);
ofstream outputFile("obhvat.txt");
int n, m;
inputFile >> n >> m;

    vector<vector<int>> adjList(n);
    for (int i = 0; i < m; i++) {
        int u, v;
        inputFile >> u >> v;
        u--, v--;
        adjList[u].push_back(v);
    }
    inputFile.close();

    int cycleLength = shortestCycle(adjList, n);
    if (cycleLength == -1) {
        outputFile << "Обхват графа: бесконечность" << endl;
    }
    else {
        outputFile << "Обхват графа: " << cycleLength << endl;
    }

    outputFile.close();
    return 0;
}
}
```

## Разбор кода:

- `#include <vector>` и `#include <queue>`: библиотеки , которые предоставляют возможность использовать векторы и очереди.
- `int shortestCycle(vector<vector<int>>& adjList, int n)`: Объявление функции shortestCycle, которая принимает ссылку на вектор векторов adjList и целочисленное значение n, обозначающее количество вершин в графе. Функция возвращает целочисленное значение - длину кратчайшего цикла в графе, либо -1, если цикл отсутствует.
- `for (int i = 0; i < n; i++)` : Цикл, в котором происходит перебор всех вершин графа. Внутри этого цикла будет запущен поиск кратчайшего цикла из каждой вершины:
  -   `vector<bool> visited(n, false) `: Объявление вектора visited размером n, которая будет использоваться для отслеживания посещенных вершин во время обхода графа.
  - `queue<pair<int, int>> q`: Объявление очереди q с элементами типа pair<int, int>, где первый элемент - вершина графа, а второй - расстояние от начальной вершины.
  - `q.push({ i, 0 })`: Добавление начальной вершины i в очередь q с расстоянием 0.
  - `while (!q.empty())`: Цикл, который будет выполняться, пока очередь не станет пустой. Здесь происходит обход графа в ширину (BFS) из текущей вершины:
     - `int cur = q.front().first`: Извлечение текущей вершины из очереди.
     -  `int dist = q.front().second `: Извлечение расстояния от начальной вершины до текущей вершины.
     -   `q.pop()`: Очищение очереди
     -   `for (int neighbor : adjList[cur]`: Цикл, в котором происходит перебор всех смежных вершин текущей вершины.
     -   `if (neighbor == i)` : Проверка, является ли смежная вершина начальной вершиной. Если да, то обновляем значение minCycle, если текущее расстояние до неё меньше, чем сохраненное в minCycle.
     -   `if (neighbor == i)`: Проверка, является ли смежная вершина начальной вершиной. Если да, то обновляем значение `minCycle` с помощью строки `minCycle = min(minCycle, dist + 1)`
     -   `else if (!visited[neighbor])`: Проверка, была ли уже посещена смежная вершина. Если нет, то добавляем её в очередь c помощью строк `visited[neighbor] = true` и `q.push({ neighbor, dist + 1 })`.
- `if (minCycle == n + 1){ return -1;} `:Проверка, был ли найден цикл во всем графе. Если нет, возвращаем -1, чтобы обозначить отсутствие цикла.
- `else { return minCycle; }`: Если же цикл был найден, возвращаем его длину.

После реализации алгоритма остаётся, лишь запросить у пользователя файл с орграфом (в виде списка смежности) и вывести обхват орграфа в новый файл.
```c++
int main() {
    setlocale(LC_ALL, "ru");
    string line;
    cout << "Введите файл: ";
    cin >> line;
    ifstream inputFile(line);
    ofstream outputFile("obhvat.txt");
    int n, m;
    inputFile >> n >> m;


    vector<vector<int>> adjList(n);
    for (int i = 0; i < m; i++) {
        int u, v;
        inputFile >> u >> v;
        u--, v--;
        adjList[u].push_back(v);
    }
    inputFile.close();

    int cycleLength = shortestCycle(adjList, n);
    if (cycleLength == -1) {
        outputFile << "Обхват графа: бесконечность" << endl;
    }
    else {
        outputFile << "Обхват графа: " << cycleLength << endl;
    }

    outputFile.close();
    return 0;
}
```

## Тестирование
Все тесты и наглядное изображение графов можетете посмотреть  [здесь](https://github.com/iis-32170x/RPIIS/tree/%D0%A1%D0%B5%D0%BC%D1%87%D0%B5%D0%BD%D0%BA%D0%BE_%D0%91/%D0%A0%D0%A0/%D1%81%D0%BA%D1%80%D0%B8%D0%BD%D1%8B%20%D1%82%D0%B5%D1%81%D1%82%D0%BE%D0%B2)

## Вывод
 
В результате выполнения расчётной работы приобрёл следующие навыки:
- изучил основы теории графов
- изучил способы представления графов
- изучил базовые алгоритмы для работы с графами
- изучил базовые алгоритмы работы с векторами, очерядими и файлами в C++

## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.

[7] База знаний по теории графов OSTIS GT [Электронный ресурс] / проект OSTIS, 2012. –
Режим доступа: http://ostisgraphstheo.sourceforge.net. — Дата доступа : 11.09.2012.




