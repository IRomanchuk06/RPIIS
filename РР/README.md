# Расчетная работа 

## Введение

### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами, 
### Задание
5.29(Найти дерево кратчайших путей)

Реализовать на C++ код, который может найти дерево кратчайших путей.

Используется неориентированный граф.

Граф представляется в виде списка инцидентности.

### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Неориентированный граф` —  граф, рёбрам которого не присвоено направление.

`Список смежности(инцидентности)` - один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

`Дерево` - это связный граф без циклов, петель и кратных рёбер.

`О́стовное де́рево графа` — это дерево, подграф данного графа, с тем же числом вершин, что и у исходного графа.

`Подграф` — это часть графа, в которой мы берем некоторые его вершины и ребра.

`Путь в графе` – это последовательность рёбер, в которой конец каждого ребра (кроме последнего) совпадает с началом следующего.
Замкнутый путь называется циклом. 

`Вес ребра` — значение, поставленное в соответствие данному ребру графа.

`Цикл` — граф, состоящий из единственного цикла, или, другими словами, некоторого числа вершин, соединённых замкнутой цепью

`Смежность` — понятие, используемое в отношении только двух рёбер либо только двух вершин: Два ребра, инцидентные одной вершине, называются смежными; две вершины, инцидентные одному ребру, также называются смежными. 

`Инцидентность` - вершина и ребро называются инцидентными, если вершина является для этого ребра концевой.

## Алгоритм Прима

Решение задачи основано на алгоритме Прима.

# Описание алгоритма
На вход алгоритма подаётся связный неориентированный граф. Для каждого ребра задаётся его вес.

Сначала берётся произвольная вершина и находится ребро, инцидентное данной вершине и обладающее наименьшим весом. Найденное ребро и соединяемые им две вершины образуют дерево. Затем, рассматриваются рёбра графа, 
один конец которых — уже принадлежащая дереву вершина, а другой — нет; из этих рёбер выбирается ребро наименьшей стоимости. Выбираемое на каждом шаге ребро присоединяется к дереву. Рост дерева происходит до тех
пор, пока не будут исчерпаны все вершины исходного графа.

Результатом работы алгоритма является остовное дерево минимального веса.

Исходный граф:

![wORDRxQMqQmCbRik](https://github.com/iis-32170x/RPIIS/assets/144374775/efd66376-e6af-434f-9337-404a66756055)

Теперь представим этот граф в виде списка смежности:

> - `0 - 1 (10)`
> - `1 - 2 (8)`
> - `1 - 4 (11)`
> - `2 - 3 (5)` 
> - `3 - 4 (14)`
> - `2 - 4 (25)`

1. Начинаем с вершины 0:

-Добавляем вершину 0 в дерево

- Находим инцидентное ребро с минимальным весом(ребро с весом 10), добавляем его в дерево

- Распространяемся по инцидентным вершинам, добавляем вершину 1

2.  Переходим к множеству вершин {0,1}:

- Находим инцидентное ребро с минимальным весом(ребро с весом 8), добавляем его в дерево

- Распространяемся по смежным вершинам, добавляем вершину 2

3. Переходим к множеству вершин {0,1,2}:

- Находим инцидентное ребро с минимальным весом(ребро с весом 5), добавляем его в дерево

- Распространяемся по смежным вершинам, добавляем вершину 3

4. Переходим к множеству вершин {0,1,2,3}:

- Находим инцидентное ребро с минимальным весом(ребро с весом 11), добавляем его в дерево

- Распространяемся по смежным вершинам, добавляем вершину 4

В итоге у нас получается дерево:
> - `0 - 1`
> - `1 - 2`
> - `2 - 3`
> - `1 - 4` 

![gdDgVzeskBoVvKFR](https://github.com/iis-32170x/RPIIS/assets/144374775/5f046885-f469-41c5-b2bd-73615859ce68)

## Реализация на C++

Код, выполняющий алгоритм находится здесь(https://github.com/iis-32170x/RPIIS/blob/%D0%94%D1%80%D0%B0%D0%BD%D1%8C%D0%BA%D0%BE_%D0%98/%D0%A0%D0%A0/Source.cpp)

## Разбор кода:

`#include <iostream>` - библиотека для ввода \ вывода
`#include <vector>` - библиотека позволяющая использовать векторы
`#include <utility>` - библиотека необходимая для использования пар объектов

`using namespace std`
## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.
