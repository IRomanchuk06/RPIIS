# Расчетная работа 

## Введение

### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами, 
### Задание
5.29(Найти дерево кратчайших путей)

Реализовать на C++ код, который может найти дерево кратчайших путей.

Используется неориентированный граф.

Граф представляется в виде списка инцидентности.

### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Неориентированный граф` —  граф, рёбрам которого не присвоено направление.

`Список смежности(инцидентности)` - один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

`Дерево` - это связный граф без циклов, петель и кратных рёбер.

`О́стовное де́рево графа` — это дерево, подграф данного графа, с тем же числом вершин, что и у исходного графа.

`Подграф` — это часть графа, в которой мы берем некоторые его вершины и ребра.

`Путь в графе` – это последовательность рёбер, в которой конец каждого ребра (кроме последнего) совпадает с началом следующего.
Замкнутый путь называется циклом. 

`Цикл` — граф, состоящий из единственного цикла, или, другими словами, некоторого числа вершин, соединённых замкнутой цепью

`Смежность` — понятие, используемое в отношении только двух рёбер либо только двух вершин: Два ребра, инцидентные одной вершине, называются смежными; две вершины, инцидентные одному ребру, также называются смежными. 

`Инцидентность` - вершина и ребро называются инцидентными, если вершина является для этого ребра концевой.

## Алгоритм Прима

Решение задачи основано на алгоритме Прима.

# Описание алгоритма
На вход алгоритма подаётся связный неориентированный граф. Для каждого ребра задаётся его вес.

Сначала берётся произвольная вершина и находится ребро, инцидентное данной вершине и обладающее наименьшим весом. Найденное ребро и соединяемые им две вершины образуют дерево. Затем, рассматриваются рёбра графа, 
один конец которых — уже принадлежащая дереву вершина, а другой — нет; из этих рёбер выбирается ребро наименьшей стоимости. Выбираемое на каждом шаге ребро присоединяется к дереву. Рост дерева происходит до тех
пор, пока не будут исчерпаны все вершины исходного графа.

Результатом работы алгоритма является остовное дерево минимального веса.

Исходный граф:

![srmKzBqxEhGLaErh](https://github.com/iis-32170x/RPIIS/assets/144374775/625b717e-9c2e-4d86-9dff-542c692d1092)

Теперь представим этот граф в виде списка смежности:

> - `0 : 1 `
> - `1 : 2 - 4 `
> - `2 : 3 - 4 ` 
> - `3 : 4 `

1. Начинаем с вершины 0:

-Добавляем вершину 0 в дерево

- Находим инцидентное ребро, добавляем его в дерево

- Распространяемся по инцидентным вершинам, добавляем вершину 1

2.  Переходим к множеству вершин {0,1}:

- Находим инцидентное ребро, добавляем его в дерево

- Распространяемся по смежным вершинам, добавляем вершину 2

3. Переходим к множеству вершин {0,1,2}:

- Находим инцидентное ребро, добавляем его в дерево

- Распространяемся по смежным вершинам, добавляем вершину 3

4. Переходим к множеству вершин {0,1,2,3}:

- Находим инцидентное ребро, добавляем его в дерево

- Распространяемся по смежным вершинам, добавляем вершину 4

В итоге у нас получается дерево:
> - `0 : 1`
> - `1 : 2 - 4`
> - `2 : 3`

![gdDgVzeskBoVvKFR](https://github.com/iis-32170x/RPIIS/assets/144374775/5f046885-f469-41c5-b2bd-73615859ce68)

## Реализация на C++

Код, выполняющий алгоритм находится здесь(https://github.com/iis-32170x/RPIIS/blob/%D0%94%D1%80%D0%B0%D0%BD%D1%8C%D0%BA%D0%BE_%D0%98/%D0%A0%D0%A0/Source.cpp)

## Разбор кода:
*Изначально программа была созданна для взвешенного графа, поэтому алгоритм находит дерево кратчайших путей учитывая вес рёбер. Однако при вызове функции вес рёбер задаётся константой равной 1, благодаря чему программа работает корректно.* 
- `#include <iostream>` - библиотека для ввода \ вывода

- `#include <vector>` - библиотека позволяющая использовать векторы

- `#include <utility>` - библиотека необходимая для использования пар объектов

- `using namespace std` - подключение пространства имен `std`

- `class Graph {` - объявление класса `Graph`, при помощи которого список смежности(инцидентности), фактически в виде матрицы, будет сохраняться в памяти компьютера

    - ` int V;` - инициальзация переменной V, которая отвечает за количество вершин в графе

    - `vector<vector<pair<int, int>>> Listsmez;` - Объявляется вектор `Listsmesz`, который является вектором векторов пар целых чисел (`pair<int, int>`). Каждый элемент этого вектора представляет список смежных вершин для определенной вершины.

    - `Graph(int V) : V(V), Listsmez(V) {}` - Конструктор класса `Graph`, которому передаётся количество вершин `V` и создается `V` пустых списков смежности.

    - `void addV(int u, int v, int weight) {` - Объявление функции `addV`, которая добавляет ребра между вершинами `u` и `v` с заданным весом `weight`.

        - `Listsmesz[u].push_back(make_pair(v, weight));` - Добавляет вершину `v` в список смежности для вершины `u` с заданным весом `weight`.

        - `Listsmesz[v].push_back(make_pair(u, weight));` - Добавляет вершину `u` в список смежности для вершины `v` с заданным весом `weight`.

- `void Tree(Graph& graph) {` - Объявление функции `Tree`, которая находит дерево кратчайших путей.
    - `vector<bool> inTree(graph.V, false);` - Создается вектор `inTree` длиной `graph.V`, который инициализируется значениями `false`. В этом векторе отслеживается, является ли вершина частью дерева или нет.
      
    - `vector<int> key(graph.V, INT_MAX);` - Создается вектор `key` длиной `graph.V`, инициализированный максимальными значениями. Эти значения будут использоваться для хранения весов путей к вершинам.
      
    - `vector<int> parent(graph.V, -1);` - Создается вектор `parent` длиной `graph.V`, который хранит информацию о родительских вершинах в полученном дереве.
      
    - `key[0] = 0;` - вес пути к первой вершине.
      
    - `for (int count = 0; count < graph.V; count++) {` - "Цикл, который выполнятет итерации для каждой вершины графа.
      
        - `int minKey = INT_MAX;` - Переменная `minKey`  инициализируется максимальным значением. Эта переменная сравнивается с весом рёбер, инцидентным не включённым в дерево вершининам
          
        - `int u = -1;` - Переменная `u` инициализируется значением -1. Переменная отвечает за ту вершину, которая в даленейшем будет включена в дерево
     
        - `for (int v = 0; v < graph.V; ++v) {` - Внутренний цикл для перебора смежных вершин.
     
        - `if (!inTree[v] && key[v] < minKey) {` - Проверяется, не включена ли вершина в текущее дерево и не является ли ёё вес меньше текущего минимального веса.
     
            - `minKey = key[v]; u = v;` - Если выполнено условие, обновляются значения `minKey` и `u`.
         
            - `inTree[u] = true;` - Текущая вершина включается в дерево.
          
        - `for (auto& neighbor : graph.Listsmez[u]) {` - Внутренний цикл, который переберает все вершины смежные вершине `u`
     
        - `if (!inTree[neighbor.first] && neighbor.second < key[neighbor.first]) {` - В этой строке происходит проверка: является ли смежная вершина `neighbor.first` частью дерева мешьше ли вес ребра между вершиной `u` и `neighbor.first` чем текущий вес рёбер к вершине `neighbor.first`.
     
            - `parent[neighbor.first] = u; key[neighbor.first] = neighbor.second;` если условие выполнено, происходит обновление родительской вершины `parent[neighbor.first] = u;` и веса ребра к вершине `key[neighbor.first] = neighbor.second;`.
          
    - `for (int i = 1; i < graph.V; ++i) {
        cout << parent[i] << " - " << i << endl;
    } ` - Цикл вывода рёбер в консоль

После необходимо запросить у пользователя список смежности(инцидентности) и вывести результат в консоль
``` c++
int main() {
    int n, m;
    system("chcp 1251 > nul");
    cout << "Введите количество вершин: \n";
    while (1) {
        cin >> n;
        if (!cin.fail()) {
            break;
        }
        cin.clear();
        cout << "Это не число \n";
        cout << "Введите количество вершин \n";
        cin.ignore(INT_MAX, '\n');
    }

    cout << "Введите количество рёбер: \n";
    while (1) {
        cin >> m;
        if (!cin.fail()) {
            break;
        }
        cin.clear();
        cout << "Это не число \n";
        cout << "Введите количество рёбер \n";
        cin.ignore(INT_MAX, '\n');
    }
    Graph graph(n);
    cout << "Введите список инцидентности(числа от 0 до n-1, где n - количество вершин): \n";
    for (int i = 0; i < m; i++) {
        int v, u, 
        const weight = 1;
        while (1) {
            cin >> v >> u;
            if (!cin.fail()) {
                if (v >= n || u >= n) {
                    cout << "Ошибка ввода\n";
                }
                else {
                    break;
                }
            }
            cin.clear();
            cout << "Некорректный ввод\n";
            cout << "Введите 2 вершины: \n";
            cin.ignore(INT_MAX, '\n');
        }
        graph.addV(v, u, weight);
    }

    Tree(graph);

    return 0;
}
```
## Тестирование
Результаты тестирования представлены тут(https://github.com/iis-32170x/RPIIS/tree/%D0%94%D1%80%D0%B0%D0%BD%D1%8C%D0%BA%D0%BE_%D0%98/%D0%A0%D0%A0/Tests)
## Вывод
В результате я приобрёл следующие навыки:
- изучил основы теории графов
- изучил базовые алгоритмы для работы с графами
- изучил способы представления графов
- изучил базовые алгоритмы работы с векторами в C++
## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.
