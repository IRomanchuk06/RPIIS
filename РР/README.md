# Расчётная работа
## Введение
### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами.
### Задание
2.1. Радиус взвешенного ориентированного графа

Реализовать на C++ код, который может найти радиус взвешенного орграфа.

Граф представляется в виде матрицы инцидентности.

### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Эксцентриситет` - это максимальное расстояние от данной вершины до всех остальных вершин в графе.

`Радиус графа` - это минимальный эксцентриситет всех вершин в графе.

`Ориентированный граф ` —  это граф, в котором каждое ребро имеет направление. То есть, каждое ребро в ориентированном графе указывает на направление от одной вершины, называемой начальной вершиной, к другой вершине, называемой конечной вершиной.

`Матрица инцидентности` - это матрица, которая представляет собой инструмент для описания ориентированного или неориентированного графа.

`Матрица смежности` - это квадратная матрица, используемая в теории графов для представления связей между вершинами в графе.

`Взвешенный граф` - это граф, в котором каждому ребру присвоено числовое значение, называемое весом.

`Алгоритм поиска кратчайших путей` - это алгоритм, используемый для нахождения кратчайшего пути между двумя вершинами в графе или для нахождения кратчайших путей от одной вершины до всех остальных вершин. Алгоритмы поиска кратчайших путей, такие как алгоритм Дейкстры или алгоритм Флойда-Уоршелла, могут быть использованы для нахождения расстояний между вершинами и, следовательно, для определения эксцентриситета вершин и радиуса графа.

## Алгоритм решения

Алгоритм находит радиус взвешенного ориентированного графа.
1. Алгоритм решения построен на алгоритме Флойда-Уоршелла.

2. Алгоритм Флойда игнорирует петли.

2. В процессе работы алгоритм обрабатывает матрицу A.

3. Граф задаётся матрицей инцидентности.

4. Граф должен быть связным: Все вершины графа должны быть достижимы из любой другой вершины. Если граф несвязный (состоит из нескольких компонент связности), то каждая компонента связности должна быть обработана отдельно для нахождения радиуса.

5. Граф должен быть ориентированным: Взвешенный ориентированный граф имеет направления на ребрах, что влияет на алгоритмы для нахождения радиуса. Ориентация ребер указывает на направление обхода и влияет на определение пути между вершинами.

6. Граф не должен содержать отрицательных циклов: Наличие отрицательных циклов может создать проблемы при определении радиуса, так как можно бесконечно уменьшать расстояния, обходя циклы. Если граф содержит отрицательные циклы, алгоритмы нахождения радиуса могут не дать корректных результатов.

7. Граф должен быть взвешенным: Для определения радиуса требуется наличие весов на ребрах графа, которые указывают на стоимость перехода между вершинами. Веса ребер могут быть положительными, нулевыми или отрицательными, но должны быть определены.

8. Если граф успешно проходит все эти проверки, то можно найти радиус. Этот алгоритм работает для взвешенных ориентированных графов.

*Приведём пример работы алгоритма:*

Рассмотрим пример графа с помощью матрицы инцидентности.

Предположим, у нас есть граф с 3 вершинами и 4 ребрами.

Матрица инцидентности для этого графа будет иметь размерность 4x5, где строки соответствуют вершинам, а столбцы соответствуют ребрам. Значение n(n-число) в ячейке указывает, что вершина инцидентна ребру, а значение 0 указывает на отсутствие инцидентности.

Пример матрицы инцидентности:

![matrix](https://github.com/iis-32170x/RPIIS/blob/Свиридо_Е/РР/матрица.png)

Полученный граф:

![matrix](https://github.com/iis-32170x/RPIIS/blob/Свиридо_Е/РР/граф1.png)

После получения графа мы получаем матрицу смежности, которая и будет вставляться в код.

Полученная матрица смежности:

![mm](https://github.com/iis-32170x/RPIIS/blob/Свиридо_Е/РР/mm.png)

Алгоритм обрабатывает матрицу А. Именно в этой матрице будут находиться кратчайшие пути между парами вершин. Матрица А - это матрица смежности. Её размер nxn (где n - количество вершин графа). В нашем пример у графа 3 вершины, поэтому матрица имеет размеры 3x3. На главной диагонали всегда расположены нули. Исходя из веса и направления дуг получаем матрицу: 

![m1](https://github.com/iis-32170x/RPIIS/blob/Свиридо_Е/РР/m1.png)

На k-ой итерации мы подставляем k-ую вершину. Таким образом, если на существующем кратчайшим пути подставляется вершина k и этот путь оказывается короче, то мы его принимаем за кратчайший путь, изменяя значения матрицы А.

Рассмотрим 1-ую (k=1) итерацию:

![m2](https://github.com/iis-32170x/RPIIS/blob/Свиридо_Е/РР/m2.png)

Проходя через 1-ую вершину появились новые кратчайшие пути и новые значения вместо знака бесконечности.

Также делаем ещё 2 итерации:

k=2:

![m3](https://github.com/iis-32170x/RPIIS/blob/Свиридо_Е/РР/m3.png)

k=3:

![m4](https://github.com/iis-32170x/RPIIS/blob/Свиридо_Е/РР/m4.png)

После всех итераций мы нашли кратчайшие пути из одной вершины в другую.

Для нахождения радиуса выберем 1-ю вершину и в её строке выберем наибольшее число.

В 1-ой строке этим числом является число 7.

Также проверяем 2-ую и 3-ю строки.

Во 2-ой строке наибольшим числом является число 8.

В 3-й строке число 5.

Наименьшее из этих значений - 5. Таким образом, радиус этого графа равен 5.

## Реализация на C++

Код, выполняющий наш алгоритм:

``` c++
#include <iostream>
#include <vector>
#include <limits>

const int INF = std::numeric_limits<int>::max();


int findGraphRadius(const std::vector<std::vector<int>>& graph) {
    int n = graph.size();
    std::vector<std::vector<int>> dist(n, std::vector<int>(n));

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (i == j) {
                dist[i][j] = 0;
            }
            else if (graph[i][j] != 0) {
                dist[i][j] = graph[i][j];
            }
            else {
                dist[i][j] = INF;
            }
        }
    }

    for (int k = 0; k < n; ++k) {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }

    int radius = INF;
    for (int i = 0; i < n; ++i) {
        int maxDist = 0;
        for (int j = 0; j < n; ++j) {
            if (dist[i][j] > maxDist) {
                maxDist = dist[i][j];
            }
        }
        if (maxDist < radius) {
            radius = maxDist;
        }
    }

    return radius;
}

int main() {
    setlocale(0, "");
    int n;
    std::cout << "Введите количество вершин графа: ";
    std::cin >> n;

    std::vector<std::vector<int>> graph(n, std::vector<int>(n));

    std::cout << "Введите матрицу смежности графа:\n";
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            std::cin >> graph[i][j];
        }
    }

    int radius = findGraphRadius(graph);
    std::cout << "Радиус взвешенного ориентированного графа: " << radius << std::endl;

    return 0;
}
```

## Разбор кода:

``` c++
#include <iostream>
#include <vector>
#include <limits>
```
Включение необходимых заголовочных файлов для работы с вводом-выводом, векторами и представлением бесконечности.

``` c++
const int INF = std::numeric_limits<int>::max();
```
В этой строке кода определяется константа INF, которая представляет собой максимальное значение типа int и используется для представления бесконечности в матрице расстояний.

``` c++
int findGraphRadius(const std::vector<std::vector<int>>& graph) {
```
В этой строке кода объявляется функция findGraphRadius, которая принимает ориентированный граф в виде двумерного вектора graph в качестве аргумента и возвращает целочисленное значение радиуса графа.

``` c++
int n = graph.size();
```
В этой строке кода получается размер графа путем вызова функции size() на векторе graph. Результат сохраняется в переменную n.

```c++
std::vector<std::vector<int>> dist(n, std::vector<int>(n));
```
В этой строке кода создается двумерный вектор dist размером n x n. Каждый элемент dist[i][j] этого вектора представляет собой расстояние между вершинами i и j.

``` c++
for (int i = 0; i < n; ++i) {
    for (int j = 0; j < n; ++j) {
        if (i == j) {
            dist[i][j] = 0;
        } else if (graph[i][j] != 0) {
            dist[i][j] = graph[i][j];
        } else {
            dist[i][j] = INF;
        }
    }
}
```
- В этих строках кода итерируется по матрице расстояний dist и инициализируются значения:
    - Если индексы i и j равны, то расстояние между вершинами i и j устанавливается равным 0.
    - Если вес ребра между вершинами i и j в графе не равен 0, то этот вес используется в матрице расстояний dist.
    - Если вес ребра равен 0, то расстояние между вершинами i и j устанавливается равным INF.

    Пункт первый
    - Подпункт первый
    - Подпункт второй
    Пункт второй

``` c++
for (int k = 0; k < n; ++k) {
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {
                dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }
}
```
-В этих строках кода выполняется алгоритм Флойда-Уоршелла для нахождения кратчайших путей между всеми парами вершин в графе.
-Внешний цикл for перебирает вершину-посредника k.
-Внутренние циклы for перебирают вершины i и j.
-Если путь из i в k и путь из k в j имеют конечные расстояния (не равные INF) и сумма этих расстояний меньше текущегорасстояния dist[i][j], то значение dist[i][j] обновляется.

``` c++
int radius = INF;
```
В этой строке кода объявляется переменная radius и ей присваивается значение INF. Переменная radius будет использоваться для хранения радиуса графа.

``` c++
for (int i = 0; i < n; ++i) {
    int maxDist = 0;
    for (int j = 0; j < n; ++j) {
        if (dist[i][j] > maxDist) {
            maxDist = dist[i][j];
        }
    }
    if (maxDist < radius) {
        radius = maxDist;
    }
}
```
-В этих строках кода находится максимальное расстояние от каждой вершины до всех остальных вершин.
-Внешний цикл for перебирает вершины i.
-Внутренний цикл for перебирает вершины j и находит максимальное значение расстояния dist[i][j].
-Если максимальное расстояние maxDist меньше текущего радиуса radius, то значение radius обновляется.

``` c++
int main() {
    int n;
    std::cout << "Введите количество вершин графа: ";
    std::cin >> n;

    std::vector<std::vector<int>> graph(n, std::vector<int>(n));

    std::cout << "Введите матрицу смежности графа:\n";
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            std::cin >> graph[i][j];
        }
    }

    int radius = findGraphRadius(graph);
    std::cout << "Радиус взвешенного ориентированного графа: " << radius << std::endl;

    return 0;
}
```
-В этих строках кода находится функция main, которая является точкой входа в программу.
-Пользователю предлагается ввести количество вершин графа.
-Создается двумерный вектор graph размером n x n, который будет использоваться для хранения матрицы смежности графа.
-Пользователю предлагается ввести матрицу смежности графа.
-Вызывается функция findGraphRadius для нахождения радиуса графа на основе введенной матрицы смежности.
-Результат радиуса выводится на экран.
-Функция main завершается с возвращаемым значением 0.

## Вывод
 
В результате выполнения расчётной работы я:
- изучил основы теории графов
- изучил способы представления графов
- изучил базовые алгоритмы для работы с графами
- изучил базовые алгоритмы работы с векторами и пределами в C++

## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.

[7] База знаний по теории графов OSTIS GT [Электронный ресурс] / проект OSTIS, 2012. –
Режим доступа: http://ostisgraphstheo.sourceforge.net. — Дата доступа : 11.09.2012.

