# *Расчётная работа*
## Введение
### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами.
### Задание
5.4 Найти компоненты связности в неориентированном графе

Реализовать на C++ код, который находитъ компоненты связности

Граф(неориентированный) представляется в виде матрицы инцедентности.
### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Нериентированный граф` — Граф, ни одному ребру которого не присвоено направление.

`Матрица инцедентности` - одна из форм представления графа, в которой указываются связи между инцидентными элементами графа (ребро(дуга) и вершина).

`Компонента связности` - набор вершин графа, между любой парой которых существует путь.
## Алгоритм решения
Вводим граф в виде матрицы инцедентности. Производим поиск в глубину от первой вершины и следующих непроверенных. Выводим в консоль компоненты связности
## Реализация на С++
Код, выполняющий приведённый алгоритм:
```C++
#include <iostream>

using namespace std;

const int n = 13;
const int m = 14;

int Mas[n][m] = { 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				   1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				   0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				   0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
				   0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
				   0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0,
				   0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
				   0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
				   0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
				   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
				   0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1,
				   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
				   0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,};

bool used[n];

int a = 0;
int b = 0;
int d = 0;
int i = 0;
int k = 0;

void dfs(int t) 
{
	used[t] = true;
	for (int a = 0; a < m; a++)
	{
		if (Mas[t][a] == 1)
		{
			for (int b = 0; b < n; b++)
			{
				if (Mas[b][a] == 1 && used[b] == 0)
				{
					dfs(b);
					cout << b + 1 << " ";
				}
			}
		}
	}
}
int main()
{
	int from;
	for (int i = 0; i < n; i++)
	{
		used[i] = false;
		for (int k = 0; k < m; k++)
			cout << " " << Mas[i][k];
		cout << endl;
	}
	while (d < n)
	{
		if (used[d] == 0)
		{
			cout << d + 1 << " ";
			dfs(d);
			cout << endl;
		}
		d++;
	}
	return 0;
}
## Разбор кода
- 
## Тестирование
Все тесты и наглядные изображения графов, участвующих в них, можно посмотреть [здесь](https://github.com/iis-32170x/RPIIS/tree/%D0%90%D0%B1%D1%80%D0%B0%D0%BC%D0%BE%D0%B2_%D0%94/PP/%D0%A2%D0%B5%D1%81%D1%82%D1%8B).
## Вывод
В результате выполнения расчётной работы приобрёл следующие навыки:

- изучил основы теории графов
- изучил способы представления графов
- изучил базовые алгоритмы для работы с графами
