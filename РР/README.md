# Расчетная работа.
## Введение.
## Цель.
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами.
### Задание.
5.21 (Поиск в графе.)

Реализовать на C++, код который поможет найти простые цепи возвешенного графа указанной длины.

Граф представлен в виде списка инцидентности.

### Ключевые понятия.
- `Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.
- `Ориентированный граф` —  граф, рёбрам которого присвоено направление.
- `Возвешенный ориентированный граф` =  граф, в котором у каждого ребра и/или каждой вершины есть “вес” - некоторое число, которое может обозначать длину пути, его стоимость и т. п.
- `Список смежности` - один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

- `Поиск в глубину (Deep First Search, DFS)` — алгоритм обхода графа, который движется от начальной вершины как можно дальше сначала по первому ребру, потом по второму, и так далее.
- `Обход в ширину (breadth-first search, BFS)` - систематически обходит все вершины графа.

## Алгоритм решения.
Используя алгоритм Дейкстры, найдем кратчайшее расстояние от одной из вершин графа до всех остальных. 

Исходный граф: 

![graph1](https://github.com/iis-32170x/RPIIS/assets/144334182/bc746625-ce3b-4531-b2ae-5725474a7825)


1. Задается исходная вершина, для которой нужно найти кратчайшие пути до всех остальных вершин графа.
2. Исходная вершина помечается как посещенная, а расстояние до нее равно 0. Для всех остальных вершин расстояние устанавливается как бесконечность.
3. Для текущей вершины вычисляются расстояния до всех соседних вершин. Если новое расстояние меньше текущего, то оно обновляется.
4. После вычисления расстояний для всех соседних вершин текущая вершина помечается как посещенная.
5. Шаги 3 и 4 повторяются до тех пор, пока все вершины графа не будут посещены.
6. По окончании алгоритма для каждой вершины будет найдено кратчайшее расстояние от исходной вершины, а также путь до нее.

## Реализация на C++.
Код выполняющий алгоритм Дейкстры:
```c++
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#define size 6
int main()
{
    int a[size][size]; 
    int d[size];
    int v[size]; 
    int temp, minindex, min;
    int begin_index = 0;
    system("chcp 1251");
    system("cls");
    for (int i = 0; i < size; i++)
    {
        a[i][i] = 0;
        for (int j = i + 1; j < size; j++) {
            printf("Введите расстояние %d - %d: ", i + 1, j + 1);
            scanf("%d", &temp);
            a[i][j] = temp;
            a[j][i] = temp;
        }
    }
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
            printf("%5d ", a[i][j]);
        printf("\n");
    }
    for (int i = 0; i < size; i++)
    {
        d[i] = 10000;
        v[i] = 1;
    }
    d[begin_index] = 0;
    do {
        minindex = 10000;
        min = 10000;
        for (int i = 0; i < size; i++)
        { 
            if ((v[i] == 1) && (d[i] < min))
            { 
                min = d[i];
                minindex = i;
            }
        }
        if (minindex != 10000)
        {
            for (int i = 0; i < size; i++)
            {
                if (a[minindex][i] > 0)
                {
                    temp = min + a[minindex][i];
                    if (temp < d[i])
                    {
                        d[i] = temp;
                    }
                }
            }
            v[minindex] = 0;
        }
    } while (minindex < 10000);
    printf("\nКратчайшие расстояния до вершин: \n");
    for (int i = 0; i < size; i++)
        printf("%5d ", d[i]);

    int ver[size]; 
    int end = 4; 
    ver[0] = end + 1; 
    int k = 1; 
    int weight = d[end]; 

    while (end != begin_index) 
    {
        for (int i = 0; i < size; i++) 
            if (a[i][end] != 0)  
            {
                int temp = weight - a[i][end]; 
                if (temp == d[i]) 
                {                 
                    weight = temp; 
                    end = i;       
                    ver[k] = i + 1; 
                    k++;
                }
            }
    }
    printf("\nВывод кратчайшего пути\n");
    for (int i = k - 1; i >= 0; i--)
        printf("%3d ", ver[i]);
    getchar(); getchar();
    return 0;
}
```
## Разбор кода:
- `#define _CRT_SECURE_NO_WARNINGS`, `#include <stdio.h>`, `#include <stdlib.h>`, `#define size 6`: Отключение предупреждений компилятора о небезопасных функциях, две базовые библеотеки, вводит константу size, размер которой равен 6.
- `int a[size][size];`: Создание матрицы связей.
- `for (int i = 0; i < size; i++)`: Инициализация матрицы связей.
- `for (int i = 0; i < size; i++)`: Вывод матрицы связей.
- `for (int i = 0; i < size; i++)`: Инициализация вершин и расстояний.
- `do {`: Шаг алгоритма.
- `for (int i = 0; i < size; i++)`: Если вершину ещё не обошли и вес меньше минимального.
- `if ((v[i] == 1) && (d[i] < min))`: Переприсваивание значений.
- `if (minindex != 10000)`: Добавление минимального найденного веса к текущему весу вершины и сравнение с текущим минимальным.
- `printf("\nКратчайшие расстояния до вершин: \n");`: Вывод кратчайших растояний до вершин.
- `int ver[size];`: Массив посещенных вершин.
- `int end = 4;`: Индекс конечной вершины.
- `ver[0] = end + 1;`: Начальный элемент - конечная вершина.
- `int k = 1;`: Индекс предыдущей вершины.
- ` int weight = d[end];`: Вес конечной вершины.
- ` for (int i = 0; i < size; i++)`: Пока цикл не дошел до начальной вершины, он просматривает все вершины на наличие связи, если она есть - определяет вес пути из предыдущей вершины. Если вес совпал с расчитанным - из этой вершины был совершен переход. Цикл сохраняет вес и предыдущую вершину, записав её в массив.
- `printf("\nВывод кратчайшего пути\n");`: Вывод пути (начальная вершина оказалась в конце массива из k элементов).
## Тестирование.
Тесты работы программы и наглядные примеры находятся [здесь](https://github.com/iis-32170x/RPIIS/tree/%D0%91%D0%BE%D0%B3%D0%B4%D1%83%D1%81%D0%B5%D0%B2%D0%B8%D1%87_%D0%95/%D0%A0%D0%A0/tests).
## Вывод.
В ходе выполнения расчётной работы приобрел такие знания, как:
- Изучил основные понятия на тему "Графы".
- Изучил способы представления графов.
- Изучил базовые алгаритмы при работе с графами. К примеру Дейкстры.
- Изучил базвые алгоритмы работы с графами, векторами и файлами в языке программирования C++.
## Список литературы.
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.

[5] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории
графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[6] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В.
Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.

[7] База знаний по теории графов OSTIS GT [Электронный ресурс] / проект OSTIS, 2012. –
Режим доступа: http://ostisgraphstheo.sourceforge.net. — Дата доступа : 11.09.2012.
