# Расчетная работа на тему "Решение теоретико-графовой задачи"
**Цель:** Получить навыки формализации и обработки информации с использованием семантических сетей.

**Задача:** Реализовать на языке c++ код для нахождения диаметра взвешенного неориентированного графа.

----

# Список понятий:
`Граф`- объект,состоящий из множеств точек и линий, которые находятся между собой в некотором отношении. Множество точек графа называется `множеством вершин`. Множество линий, соединяющих любые пары вершин, называется `множеством ребер или дуг`.

`Нериентированный граф` - граф, вершины которого соединены ребрами.

`Взвешенный граф`- граф, каждому ребру которого поставлено в соответствие некое значение (вес ребра).

`Матрица инцидентности` - одна из форм представления графа, в которой указываются связи между инцидентными элементами графа (ребро(дуга) и вершина).

Например:

![matematicheskaya-model-igry-dobbl-29](https://github.com/iis-32170x/RPIIS/assets/148317821/87abe922-52a1-48f7-a605-9b3cdc0eb3f5)

`Список смежности(список инцидентности)` одной вершины графа включает номера вершин, смежных с ней.

Например:

![06f81](https://github.com/iis-32170x/RPIIS/assets/148317821/aaa55cff-4701-452f-bf8c-3d5bf08aea70)

`Эксцентриситетом вершины` называется расстояние до самой дальней вершины графа. 

`Диаметром` графа называется максимальный эксцентриситет среди всех вершин графа.

`Расстояние между вершинами` – это длина кратчайшего пути между вершинами.

`Связный граф` - граф, в котором между двумя любыми вершинами существует путь.

`Несвязный граф` - граф, в котором существует хотя бы одна пара вершин, между которыми нет пути.

`Пустой граф` - граф, не содержащий ребер.

----

# Алгоритм Беллмана-Форда

![289924312-a1f87b01-ba4f-4fc4-a01b-6b9ea8ef2ae7](https://github.com/iis-32170x/RPIIS/assets/148317821/22f27aac-a2fb-40be-91c2-0667669a62a2)


Широко используемый алгоритм в теории графов и сетевом анализе. Он используется для поиска кратчайшего пути от одной исходной вершины ко всем остальным вершинам взвешенного графа, даже если граф содержит ребра с отрицательным весом. 

**Ключевые идеи:**

 ⁃ Кратчайший путь из одного источника.
 
Беллман-Форд фокусируется на поиске кратчайшего пути от исходной вершины ко всем остальным вершинам графа.

 ⁃ Ребра с отрицательным весом.
 
В отличие от алгоритма Дейкстры, алгоритм Беллмана-Форда может обрабатывать графы с ребрами с отрицательным весом. Однако он не может обрабатывать графы с отрицательными весовыми циклами.

 ⁃ Релаксация
 
Основная операция Беллмана-Форда – это **релаксация**. Алгоритм применяемая к ребру графа, направленному от одной вершины к другой, с целью улучшения оценки кратчайшего пути между этими двумя вершинами.Основная идея заключается в том, чтобы проверить, можно ли улучшить текущую оценку длины пути до вершины, используя новое ребро.

Сложность: O(V*E)

----

----

# Алгоритм решения поставленной задачи:

1. **Инициализация:**
   - Для каждой вершины графа мы начинаем с предположения, что самое короткое расстояние до нее из начальной вершины - это "бесконечность", за исключением самой начальной вершины, до которой расстояние равно 0.

2. **Обход вершин:**
   - Мы начинаем с очереди, в которую помещаем начальную вершину.
   - Затем, пока у нас есть вершины в очереди, мы берем вершину из очереди и рассматриваем ее соседей.
   - Если мы можем добраться до соседа более коротким путем, чем тот, который мы ранее знали, мы обновляем это расстояние и добавляем соседа в очередь для дальнейшего рассмотрения.

3. **Нахождение диаметра:**
   - После обхода графа мы находим максимальное расстояние от данной вершины до любой другой вершины в графе.
   - Это максимальное расстояние и является эксцентриситетом текущей вершины.
   - Затем, чтобы найти диаметр графа, мы выбираем максимальный из всех найденных эксцентриситетов.

4. **Результат:**
   - Диаметр графа - это максимальный эксцентриситет среди всех вершин графа.
  
----

~~~C++
#include <iostream> 
#include <vector> 
#include <queue> 
#include <climits> 
#include <fstream> 
using namespace std;

struct Edge {
    int to;        // информация о конечной вершине *to* и весе *weight* ребра
    int weight;
};

/////////////вычисление эксцентриситета заданной вершины//////////
int findEccentricity(vector<vector<Edge>>& adjList, int start, int n) { //список смежности *adjList*, n-общее количество вершин
    vector<int> dist(n, INT_MAX);//вектор *dist* для хранения расстояний от заданной вершины до всех остальных вершин (изначально расстояние от вершины *start* до любой другой вершины ∞)
    dist[start] = 0; //расстояние вершины *start* до самой себя

    queue<int> q; //создаем очередь для хранения вершин, которые мы будем рассматривать
    q.push(start);

    while (!q.empty()) {
        int cur = q.front();
        q.pop();

        for (const Edge& edge : adjList[cur]) { // для каждого ребра *edge*, инцидентного текущей вершине cur (adjList[cur]-ребра, инцидентные вершине) выполняем:
            int neighbor = edge.to; // *neighbor*- номер соседней вершины для вершины *cur*
            int weight = edge.weight; //*weight* -вес ребра

            if (dist[neighbor] > dist[cur] + weight) { //Если найден новый более короткий путь к вершине *neighbor*, то его расстояние обновляется, и вершина добавляется в очередь для дальнейшего рассмотрения. Этот процесс продолжается до тех пор, пока не будут рассмотрены все возможные пути и найдены кратчайшие расстояния от стартовой вершины до всех других вершин в графе.
                dist[neighbor] = dist[cur] + weight;
                q.push(neighbor);
            }
        }
    }

    int maxDist = 0;
    for (int i = 0; i < n; ++i) { //находим эксцентриситет вершины (максимальное удаление(расстояние) от данной вершины)
        maxDist = max(maxDist, dist[i]); //в каждой итерации цикла используется функция max, которая возвращает большее из двух значений
    }

    return maxDist;
}
///////////////////////////////////////////////////////////////////////



/////////нахождение диаметра графа/////////////////////////////////////
int findGraphDiametr(vector<vector<Edge>>& adjList, int n) {
    int maxEccentricity = INT_MIN;

    for (int i = 0; i < n; ++i) { //проходим по всем вершинам графа и вычисляем эксцентриситет каждой вершины с помощью ф-ии *findEccentricity*
        int eccentricity = findEccentricity(adjList, i, n);
        maxEccentricity = max(maxEccentricity, eccentricity); //находим максимальный эксцентриситет, который и будет диаметром
    }

    if (maxEccentricity == INT_MIN) { //если граф пустой или несвязный
        return -1;
    }
    else {
        return maxEccentricity;
    }
}
/////////////////////////////////////////////////////////////////////



///////ввод значений и их обработка//////////////////////////////////
void run_testcase() {
    

    int n, m;
    cout << "Введите количество вершин, потом ребер: ";
    cin >> n >> m; //кол-во вершин n и кол-во ребер m

    vector<vector<Edge>> adjList(n);
    int matr[10][10];
    cout << "Введите матрицу инцидентности взвешенного ненаправленного графа:" << endl;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> matr[i][j];
        }
    }
    cout << "Список смежности: " << endl;
    int u, v, w; //вершины u и v, вес w 
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) { 
            if (matr[j][i] > 0) {
                for (int p = j + 1; p < n; p++) {
                    if (matr[p][i] == matr[j][i]) {
                        v = p; u = j; w = matr[j][i]; break;
                    }
                    else continue;
                }
            } 
            if (matr[j][i] == 0) continue;
        }

        Edge edge_to_v = { v, w }; //ребро, направленное к вершине v с весом w
        Edge edge_to_u = { u, w }; //ребро, направленное к вершине u с весом w

        adjList[u].push_back(edge_to_v); //добавляем созданное ребро *edge_to_v* в список смежности для вершины u
        adjList[v].push_back(edge_to_u); ////добавляем созданное ребро *edge_to_u* в список смежности для вершины v
        cout << u + 1 << "<->" << v + 1 << " " << w << endl; //выводим список смежности
        cout << endl;
        
    }

    int graphDiametr = findGraphDiametr(adjList, n);
    if (graphDiametr == -1) {
        cout << "Граф несвязанный или пустой " << endl;
    }
    else {
        cout << "Диаметр графа: " << graphDiametr << endl;
    }
    cout << "--------------------------------------------------\n";
}
//////////////////////////////////////////////////////////////////////////////



////////запуск тестовых случаев/////////////////////////////////////////////
int main() {
    setlocale(LC_ALL, "ru");

    // Run the test case
    run_testcase();

    return 0;
}
~~~
