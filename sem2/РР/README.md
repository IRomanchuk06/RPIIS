# Формализация алгоритма расчетной работы (РР)
### Задание РР 
2.13 Найти обхват орграфа


## Список используемых понятий:
1. **Граф** - математическая структура, состоящая из вершин и ребер, соединяющих некоторые пары вершин.
![img]()
2. **Неориентированный граф** - это геометрическая фигура, состоящая из точек (вершины графа) и линий, их соединяющих (рёбра графа)
![img]()
3. **Ориентированный граф** - это геометрическая фигура, состоящая из точек (вершины графа) и линий, их соединяющих (рёбра графа), причем эти линии имеют направление.
![img]()
4. **Обхват гарфа** - длина наименьшего цикла в графе.
   

## Алгоритм РР

1. Инициализация переменной mingirth значением `n + 1`, где `n` - количество узлов в графе. Это больше, чем максимально возможная длина цикла в графе, поэтому `mingirth` будет обновляться при нахождении более короткого цикла.
2. Для каждого узла `i` в графе (внешний цикл):
a. Инициализация вектора `visited` размером `n`, заполненного значениями `false`. Этот вектор будет отслеживать, какие узлы были посещены во время обхода в ширину (`BFS`).
b. Инициализация очереди `q` с начальным узлом `i` и расстоянием `0`.
c. Запуск `BFS`, пока очередь `q` не станет пустой:
d. Извлечение из очереди текущего узла `cur` и расстояния `dist`.
e. Для каждого столбца `j` в матрице `matrix`:
- Если `matrix[cur][j] == 1`, это означает, что в этом столбце есть ребро.
- Тогда код проверяет все узлы `neighbor` в этом столбце, где `matrix[neighbor][j] == -1`, что означает отсутствие ребра.
- Если `neighbor == i`, то это означает, что найден цикл, и `mingirth` обновляется до минимального значения между текущим `mingirth` и `dist + 1` (длина цикла).
- Если `neighbor != i` и `visited[neighbor] == false`, то neighbor добавляется в очередь `q` с расстоянием `dist + 1`.
3. После завершения `BFS` для всех узлов `i` проверяется значение `mingirth`:
- Если `mingirth` осталось равным `n + 1`, это означает, что в графе не было найдено ни одного цикла, поэтому функция возвращает `-1`.
- Иначе функция возвращает значение `mingirth` - минимальную длину цикла, найденную в процессе.


### Результат формализации алгоритма РР

1. Пользователь задает ориентированный граф.

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/sem2/%D0%A0%D0%A0/img/graph.png)


2. Выбирается вершина для начала обхода (допустим, A). Инициализируется переменная mingirth, которая будет хранить обхват орграфа, изначально равная `n`(количество вершин графа)+1.Также создаётся вектор  `visited`, который хранит посещённые вершины. И очередь `q`, которая хранит текущую вершину и дистанцию.

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/sem2/%D0%A0%D0%A0/img/wave1.png)


3. Используя обход в ширину двигаемся в вершину B, обновляя очередь `q` и занося её в вектор `visited`.

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/sem2/%D0%A0%D0%A0/img/wave2.png)


4. Продолжаем обход в ширину и все вышеперечисленные процессы.

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/sem2/%D0%A0%D0%A0/img/wave3.png)


5. Дойдя до вершины D, используем алгоритма обхода в ширину и получаем, что смежная вершина A является начальной вершиной. И получаем конечную дистанцию.

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/sem2/%D0%A0%D0%A0/img/wave4.png)


6. Прописывыаем алгоритм сравнения текущей дистанции с переменной `mingirth` для получения минимального значения. И потом переприсваиваем `mingirth` минимальное значение.
   
![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/sem2/%D0%A0%D0%A0/img/wave5.png)


7. Потворяя данный алгоритм для всех вершин получим обхват орграфа.

## Пример входных и выходных конструкций:
1. Входная:

   ![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/sem2/%D0%A0%D0%A0/img/test1.1.png)

   Выходная:

   ![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/sem2/%D0%A0%D0%A0/img/test1.2.png)

   
2. Входная:

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/sem2/%D0%A0%D0%A0/img/test2.1.png)


   Выходная:

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/sem2/%D0%A0%D0%A0/img/test2.2.png)

3. Входная:

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/sem2/%D0%A0%D0%A0/img/test3.1.png)


   Выходная:

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D0%B0%D0%BF%D1%87%D0%B8%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%92/sem2/%D0%A0%D0%A0/img/test3.2.png)


  
## Вывод
Формализовал алгоритм получения обхвата графа.Улучшил свои навыки работыы KBE.
 ## Список литературы
[1] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[2] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение
и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред.
Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Нечипуренко, М. И. Алгоритмы и программы решения задач на графах и сетях / М.И.
Нечипуренко, В.К. Попков, С.М. Майнагашев и др. – Новосибирск: Наука. Сиб. отд-ние,
1990. – 515 с.
