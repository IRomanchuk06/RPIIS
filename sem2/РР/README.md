# Формализация алгоритма расчетной работы (РР)
### Задание РР 
2.13 Найти обхват орграфа


## Список используемых понятий:
1. **Граф** - математическая структура, состоящая из вершин и ребер, соединяющих некоторые пары вершин.
2. **Неориентированный граф** - это геометрическая фигура, состоящая из точек (вершины графа) и линий, их соединяющих (рёбра графа).
3. **Ориентированный граф** - это геометрическая фигура, состоящая из точек (вершины графа) и линий, их соединяющих (рёбра графа), причем эти линии имеют направление.
4. **Обхват гарфа** - длина наименьшего цикла в графе.
   

## Алгоритм РР

1. Инициализируйте переменную `minCycle` значением `n + 1`, где `n` - количество вершин в графе.
2. Для каждой вершины `i` в графе (от 0 до `n-1`):
     - Создайте массив `visited` размером `n` для отслеживания посещенных вершин.
     - Создайте переменную `distance` и установите ее равной 0.
     - Создайте очередь `q` и добавьте в нее пару `{i, distance}`, где `i` - текущая вершина, `distance` - дистанция от начальной вершины.
     - Пока очередь `q` не пуста:
         - Извлеките вершину `cur` и дистанцию `dist` из очереди.
         - Для каждой соседней вершины `neighbor` текущей вершины `cur`:
             - Если `neighbor` равна начальной вершине `i`, обновите `minCycle`, если текущая дистанция (`dist + 1`) меньше текущего значения `minCycle`.
             - Если соседняя вершина еще не посещена, пометьте ее как посещенную и добавьте в очередь `q` с дистанцией `dist + 1`.
3. Если `minCycle` равно `n + 1`, верните -1, так как в графе нет циклов.
4. Иначе, верните `minCycle`, представляющий длину кратчайшего цикла в графе.


### Результат формализации алгоритма РР

1. Пользователь задает ориентированный граф.

![Снимок экрана 2024-05-19 164911](https://github.com/iis-32170x/RPIIS/assets/144383538/f25d6a8f-8fae-44dd-bef8-cbf1eb9b2111)

2. Выбирается вершину для начала обхода (допустим, A). Инициализируется переменная minCycle, которая будет хранить обхват орграфа, изначально равная `n`(колисеитво вершин графа)+1.Также создаётся вектор  `visited`, который хранит посещённые вершины. И очередь `q`, которая хранит текущую вершину и дистанцию.

![Снимок экрана 2024-05-19 164923](https://github.com/iis-32170x/RPIIS/assets/144383538/2dbb369c-b94e-46b0-9346-c251ae5e1bad)

3. Используя обход в ширину двигаемся в вершину B, обновляя очередь `q` и занося её в вектор `visited`.

![Снимок экрана 2024-05-19 165319](https://github.com/iis-32170x/RPIIS/assets/144383538/57f05efb-aae8-431c-80b5-8aaafac10c2d)

4. Продолжаем обход в ширину и все вышеперечисленные процессы.

![Снимок экрана 2024-05-19 165832](https://github.com/iis-32170x/RPIIS/assets/144383538/78134d46-0162-4809-b8a2-147144ec5444)

5. Дойдя до вершины F, используем алгоритма обхода в ширину и получаем, что смежная вершина A является начальной вершиной. И получаем конечную дистанцию.

![Снимок экрана 2024-05-19 171304](https://github.com/iis-32170x/RPIIS/assets/144383538/d036dc88-7c2a-4c97-8576-4a17a5ea2cc5)

6. Прописывыаем алгоритм сравнения текущей дистанции с переменной `minCycle` для получения минимального значения. И потом переприсваиваем `minCycle` минимальное значение.
   
![Снимок экрана 2024-05-19 172237](https://github.com/iis-32170x/RPIIS/assets/144383538/8a11a0e4-9d7a-40a7-b1c1-0474e4eafece)

7. Потворяя данный алгоритм для всех вершин получим обхват орграфа.
