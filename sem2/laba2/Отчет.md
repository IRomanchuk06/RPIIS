# Лабораторная 2 


### Цель

Цель работы - это придумать и реализовать алгоритим парсинга множества в заданном стандарте и выволнения индивидуального задания с ним.

### Задание

Реализовать код на выбранном языке, который по входным данным в заданном формате, будет считать разность 2 множеств (без учетности кратности элементов).

### Ключевые понятия

`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями. Граф как математический объект есть совокупность двух множеств — множества самих объектов, называемого множеством вершин, и множества их парных связей, называемого множеством рёбер.

`Дерево` - граф, который не имеет циклов.



## Идея решения

Данный код использует древовидную структуру данных для представления множеств. Каждый узел дерева (node) может быть одного из трех типов: базовый элемент (BASIC), кортеж (TUPLE) или неупорядоченное множество (SET). Базовый элемент представляет собой отдельное значение (например, число или строку), кортеж - упорядоченный набор элементов, а неупорядоченное множество - неупорядоченную коллекцию элементов.

Синтаксис входных строк

Входные строки, представляющие множества, должны соответствовать определенному синтаксису. Неупорядоченное множество записывается в фигурных скобках { }, а кортеж - в угловых скобках < >. Элементы множества или кортежа разделяются запятыми. Например, строка {1,<2,3>,{4,5}} представляет неупорядоченное множество, состоящее из базового элемента 1, кортежа <2,3> и другого неупорядоченного множества {4,5}.

Построение дерева

Метод parse_from_str анализирует входную строку и строит соответствующее дерево. Он перемещает указатель current по дереву, добавляя новые узлы в соответствующие места. Тип узла определяется по символу, встреченному в строке ({ для множества, < для кортежа, любой другой символ для базового элемента).

Проверка равенства

Функции check_equality_for_sets и check_equality рекурсивно проверяют равенство двух деревьев (множеств или кортежей). Для базовых элементов проверяется равенство значений. Для кортежей проверяется равенство количества элементов и рекурсивно проверяется равенство каждой пары соответствующих элементов. Для неупорядоченных множеств функция check_equality_for_sets использует вложенные циклы для проверки, что каждый элемент первого множества присутствует во втором множестве, и наоборот.
```
bool check_equality_for_sets(node* a, node* b);
void check_equality(node* a, node* b, bool& status);

bool check_equality_for_sets(node* a, node* b) {
	int counter_of_eq = 0;
	if (a->children.size() != b->children.size()) { return false; }
	for (auto i : a->children) {
		for (auto j : b->children) {
			bool st = true;
			check_equality(i, j, st);
			if (st == true) { counter_of_eq++; }
		}
	}
	if (counter_of_eq == a->children.size()) { return true; }
	return false;

}

void check_equality(node* a, node* b , bool &status) {

	if (a->type != b->type) { status = false; }
	//если типы все таки совпадают
	else {

		if (a->type == BASIC) { if (a->value != b->value) { status = false; } }// для базовых элементов 

		if (a->type == TUPLE) {
			if (a->children.size() != b->children.size()) { status = false; }
			else {
				for (int i = 0; i < a->children.size(); i++) { check_equality(a->children[i], b->children[i], status); }
			}
		}//для кортэжей
		if (a->type == SET) {
			status = check_equality_for_sets(a, b);
		}


	}

}
```

Нахождение разности

Для нахождения разности A \ B (все элементы из A, которые не присутствуют в B), в main реализован следующий алгоритм:

Для каждого элемента i в a.root.children: a. Проверить наличие i в b.root.children с помощью check_equality. b. Если i не найден в b.root.children, добавить i в c.root.children.

Установить тип c.root как SET.

Таким образом, в результирующем множестве c окажутся только те элементы из a, которые не имеют равных элементов в b.

Вывод результата

Функция print_tree рекурсивно обходит дерево и генерирует строковое представление множества или кортежа в соответствии с синтаксисом входных строк.

Дополнительные детали

Код использует пространство имен std.
В начале файла определены константы BASIC, TUPLE и SET для представления типов узлов.
Функция read_from_file считывает две строки из файла example.txt и возвращает их.
Этот код демонстрирует использование таких концепций, как структуры данных, рекурсия, обработка строк и работа с файлами. Он может быть полезен для изучения этих тем, а также для понимания реализации операций над множествами с использованием древовидных структур данных.


## Вывод
 
В результате выполнения данной работы были получены следующие практические навыки:
- изучены основы теории множеств
- изучены способы представления множеств
- изучены базовые алгоритмы для работы с множествами
