# Лабораторная работа по дисциплине ПиОИвИС №1, второй семестр
## Цель работы
Исследовать свойства структур данных и разработать библиотеку алгоритмов обработки структур данных.
## Индивидуальное задание №15
Квадродерево. Перевод матрицы в дерево. Перевод дерева в матрицу.
## Ключевые понятия
***Дерево*** — структура данных, эмулирующая древовидную структуру в виде набора связанных узлов. Является связным графом, не содержащим циклы.
***Корневой узел*** — самый верхний узел дерева.
***Лист*** (листовой или терминальный узел) — узел, не имеющий дочерних элементов.
***Внутренний узел*** — любой узел дерева, имеющий потомков, и таким образом, не являющийся листовым узлом.
***Квадродерево*** (также дерево квадрантов) — дерево, каждая внутренняя вершина которого содержит 4 потомка.
***Квадрант*** — любая из 4 областей, на которые делится некоторая плоскость (двумерное пространство).

---

## Выполнение задания
Деревья квадрантов в основном используются для рекурсивного разбиения двухмерного пространства по 4 квадранта (пример приведён на картинке ниже).
![[media/Quad_tree_bitmap.svg]]
Если квадрант состоит из одинаковых элементов, он является однородным, и, соответственно, в дереве он представлен листом. Таким образом, необходимо рекурсивно разбивать пространство до тех пор, пока либо квадрант не будет однородным, либо размер такого квадранта не станет равен минимальному. 

В некоторых источниках отсчёт квадрантов начинается с верхнего левого и идёт по часовой стрелке, в некоторых - аналогично порядку чтения текста (слева направо и сверху вниз). В данном отчете и исходном коде рассматривается второй способ.

Объявление структуры, описывающей один узел квадродерева:
```cpp
struct QuadTreeNode {
    bool isLeaf;
    int value;
    QuadTreeNode* topLeft;
    QuadTreeNode* topRight;
    QuadTreeNode* bottomLeft;
    QuadTreeNode* bottomRight;
};
```
Каждый узел описывается переменной `isLeaf` (является ли узел листом), значением этого узла и указателями на четыре дочерних узла.

Поскольку дерево само по себе является рекурсивной структурой данных, то и в алгоритмах преобразований будут использоваться рекурсии.

---

### Перевод матрицы в дерево
```cpp
bool isHomogeneous(int x, int y, int size, vector<vector<int>>& matrix) {
    int firstValue = matrix[x][y];
    for (int i = x; i < x + size; i++) {
        for (int j = y; j < y + size; j++) {
            if (matrix[i][j] != firstValue) {
                return false;
            }
        }
    }
    return true;
}
```
В функции `isHomogeneous` происходит проверка квадранта матрицы на однородность (состоит ли квадрант из одинаковых элементов). Параметры `х` и `у` описывают крайний элемент квадранта (впоследствии этот элемент будет перемещаться в зависимости от рассматриваемого квадранта), размер матрицы и саму матрицу. Специально нарекаем крайний элемент, относительно которого будет рассматриваться однородность. Если найдется хоть один элемент, не равный основному -> квадрант неоднороден, и возвращаем `false`.

```cpp
QuadTreeNode* convertToQuadTree(int x, int y, int size, vector<vector<int>>& matrix) {
    if (isHomogeneous(x, y, size, matrix)) {
        return new QuadTreeNode{true, matrix[x][y], nullptr, nullptr, nullptr, nullptr};
    }
    else {
        int newSize = size / 2;
        QuadTreeNode* node = new QuadTreeNode();
        node->isLeaf = false;
        node->value = -1;
        node->topLeft = convertToQuadTree(x, y, newSize, matrix);
        node->topRight = convertToQuadTree(x, y + newSize, newSize, matrix);
        node->bottomLeft = convertToQuadTree(x + newSize, y, newSize, matrix);
        node->bottomRight = convertToQuadTree(x + newSize, y + newSize, newSize, matrix);
        return node;
    }
}
```
В функции `convertToQuadTree`, как понятно из названия, происходит преобразование в дерево. Если квадрант однородный -> создаем лист (первый параметр = `true`). В ином же случае делим изначальный размер матрицы на 2, создаем новый узел, его параметр `isLeaf` указываем `false`, значение = `-1` (поскольку обычно для описания изображения используются `0` или `1`, то `-1` вряд ли описывает что-либо) и рекурсивно вызываем функцию для всех четырёх квадрантов. При первом вызове функции параметры `х` и `у` равны нулю, после чего с помощью переменной `newSize` эти параметры изменяются как раз на крайние элементы всех четырех квадрантов для последующей проверки на однородность.

---
### Перевод дерева в матрицу
```cpp
void convertToMatrix(QuadTreeNode* node, int x, int y, int size, vector<vector<int>>& matrix) {
    if (node->isLeaf) {
        for (int i = x; i < x + size; i++) {
            for (int j = y; j < y + size; j++) {
                matrix[i][j] = node->value;
            }
        }
    } else {
        int newSize = size / 2;
        if (node->topLeft) convertToMatrix(node->topLeft, x, y, newSize, matrix);
        if (node->topRight) convertToMatrix(node->topRight, x, y + newSize, newSize, matrix);
        if (node->bottomLeft) convertToMatrix(node->bottomLeft, x + newSize, y, newSize, matrix);
        if (node->bottomRight) convertToMatrix(node->bottomRight, x + newSize, y + newSize, newSize, matrix);
    }
}
```
В функции `convertToMatrix` происходит примерно всё то же самое, что и в `convertToQuadTree`, только наоборот: если узел - лист -> заполняем соответстввющий квадрант матрицы значением этого листа, в ином случае снова делим размер матрицы на 2 и рекурсивно вызываем функцию для всех четырех дочерних узлов, причём перемещая крайний элемент с помощью всё той же переменной `newSize` во все четыре квадранта.

---

### Тестирование
Для вывода дерева на экран будет использоваться функция `printQuadTree`
```cpp
void printQuadTree(QuadTreeNode* node, int depth = 0) {
    if (node == nullptr) return;
    if (node->isLeaf) {
        for (int i = 0; i < depth; i++) {
            cout << " ";
        }
        cout << node->value << endl;
    }
    printQuadTree(node->topLeft, depth + 1);
    printQuadTree(node->topRight, depth + 1);
    printQuadTree(node->bottomLeft, depth + 1);
    printQuadTree(node->bottomRight, depth + 1);
}
```
Матрица в дерево:

Входные данные:
```
1 1 1 1 0 0 0 0
1 1 1 1 0 0 0 0
1 0 1 1 0 0 0 0
1 1 1 1 0 0 0 0
1 1 1 1 1 1 1 1
1 1 1 1 1 0 1 1
1 0 1 1 1 1 1 1
1 1 1 1 1 1 1 1
```
Выходные данные:
```
-- 1
-- 1
--- 1
--- 0
--- 1
--- 1
-- 1
- 0
-- 1
-- 1
--- 1
--- 0
--- 1
--- 1
-- 1
--- 1
--- 1
--- 1
--- 0
-- 1
-- 1
-- 1
```

Остальные тестовые программы расположены в директории `/tests`.

---

## Вывод
В рамках данной лабораторной работы были изучены способы взаимодействия со структурой данных квадродерево. Реализовал библиотеку для перевода квадродерева в матрицу и матрицы в квадродерево.

---

## Источники
1. https://www.youtube.com/watch?v=dQw4w9WgXcQ
2. https://en.wikipedia.org/wiki/Quadtree
3. Фундаментальные алгоритмы на C++. Анализ / Структуры данных / Сортировка / Поиск: Пер. с англ. / Роберт Седжвик. – К. Издательство «ДиаСофт», 2001. – 688 с.