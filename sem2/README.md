# Лабороторная работа №1
##   Постановка задачи
1. Разработать библиотеку для работы со структурой данных, указанной в
индивидуальном задании, на любом императивнойм языке
программирования (Pascal, C\C++, Java, C#, Python и др.)
2. Разработать тестовую программу, которая демонстрирует
работоспособность реализованной библиотеки работы со структурой
данных.
3. Разработать систему тестов, которые продемонстрировали бы
работоспособность реализованной библиотеки. Система тестов должна
отвечать требованиям полноты, адекватности и непротиворечивости.
Система тестов должна учитывать не только корректную работу на
правильных данных, но и предусматривать корректное завершение
программы в случае некорректных данных.
4. По результатам выполнения задания составить отчет.
## Условие первой лабораторной работы (Вариант 20)
Дерево сумм. Поиск суммы чисел на отрезке массива. Изменение всех
чисел на отрезке массива на какое-то значение.
 ## Определения и понятия
  Дерево представляет собой набор объектов, называемых узлами. Узлы соединены ребрами. Каждый узел содержит значение или данные, и он может иметь или не иметь дочерний узел.Первый узел дерева называется корнем. Если этот корневой узел соединен с другим узлом, тогда корень является родительским узлом, а связанный с ним узел — дочерним. Лист — узел, не имеющий дочерних узлов на дереве.

  Дерево суммы (Sum Tree) - это структура данных, которая позволяет эффективно решать задачи по работе с отрезками массива или других последовательностей. Оно представляет собой бинарное дерево, в котором каждый узел содержит информацию о сумме значений на определенном отрезке массива. Сумма элементов на отрезке массива - это количество легко считается, как разность правой и левой границы интервала плюс единица.
  ##  *Разбор алгоритмов основных функций*
  ### 1)
  ``` c++
   void build_tree(int v, int tl, int tr, const int* a) {
    if (tl == tr) {
        tree[v] = a[tl];
    }
    else {
        int tm = (tl + tr) / 2;
        build_tree(v * 2, tl, tm, a);
        build_tree(v * 2 + 1, tm + 1, tr, a);
        tree[v] = tree[v * 2] + tree[v * 2 + 1];
    }
}
}
```
Данная функция build_tree является рекурсивной функцией для построения дерева суммы
### 2)
``` c++
 int get_sum(int l, int r, int v, int tl, int tr) {
    if (v >= 0 && v < 400004) {
        if (l <= tl && tr <= r) {
            return tree[v];
        }
        if (tr < l || r < tl) {
            return 0;
        }

        int tm = (tl + tr) / 2;
        return get_sum(l, r, v * 2, tl, tm)
            + get_sum(l, r, v * 2 + 1, tm + 1, tr);
    }
    return 0;
}
```
Данная функция get_sum предназначена для вычисления суммы элементов на заданном отрезке массива. Она оперирует сегментным деревом, построенным с помощью функции build_tree.

Функция get_sum принимает следующие аргументы:

l и r - левая и правая границы отрезка, для которого нужно вычислить сумму элементов.
v - индекс текущего узла в сегментном дереве.
tl и tr - левая и правая границы отрезка, соответствующего текущему узлу v.
Алгоритм функции get_sum работает следующим образом:

Если текущий узел v находится в допустимом диапазоне (от 0 до 400004), то выполняются следующие проверки:
Если отрезок, соответствующий текущему узлу v (от tl до tr), полностью содержится в заданном отрезке [l, r], то возвращается значение суммы элементов, хранящееся в узле v. Это означает, что текущий отрезок полностью находится внутри заданного отрезка, и мы можем просто вернуть значение суммы, которое уже рассчитано для этого отрезка.
Если текущий отрезок находится полностью левее или полностью правее заданного отрезка [l, r], то возвращается 0. Это означает, что текущий отрезок полностью находится вне заданного отрезка, и его сумма равна 0.
Если текущий отрезок пересекается с заданным отрезком [l, r], то функция рекурсивно вызывает себя для левого подотрезка и правого подотрезка текущего узла v. Результаты рекурсивных вызовов складываются и возвращаются как итоговая сумма элементов на заданном отрезке [l, r].
### 3
``` c++
void update_range(int l, int r, int val, int v, int tl, int tr) {
    if (v >= 0 && v < 400004) {
        if (l <= tl && tr <= r) {
            tree[v] += val * (tr - tl + 1);
            if (tl != tr) {
                tree[v * 2] += val;
                tree[v * 2 + 1] += val;
            }
            return;
        }
        if (tr < l || r < tl) {
            return;
        }

        int tm = (tl + tr) / 2;
        update_range(l, r, val, v * 2, tl, tm);
        update_range(l, r, val, v * 2 + 1, tm + 1, tr);
        tree[v] = tree[v * 2] + tree[v * 2 + 1];
    }
}
```
Данная функция update_range предназначена для обновления значения всех элементов на заданном отрезке массива a в сегментном дереве. Она также обновляет значения промежуточных узлов дерева, чтобы отражать изменения в листовых узлах.

Функция update_range принимает следующие аргументы:

l и r - левая и правая границы отрезка, который нужно обновить.
val - значение, на которое нужно обновить элементы на заданном отрезке.
v - индекс текущего узла в сегментном дереве.
tl и tr - левая и правая границы отрезка, соответствующего текущему узлу v.
Алгоритм функции update_range работает следующим образом:

Если текущий узел v находится в допустимом диапазоне (от 0 до 400004), то выполняются следующие проверки:
Если текущий отрезок, соответствующий текущему узлу v (от tl до tr), полностью содержится в заданном отрезке [l, r], то значения всех элементов на этом отрезке увеличиваются на val * (tr - tl + 1). Это означает, что все элементы на текущем отрезке должны быть обновлены на одно и то же значение val.
Если текущий узел v имеет детей (т.е., tl != tr), то значения детей текущего узла также увеличиваются на val, чтобы отразить изменения на листовых узлах.
Если текущий отрезок полностью находится левее или полностью правее заданного отрезка [l, r], то никаких изменений не производится.
Если текущий отрезок пересекается с заданным отрезком [l, r], то функция рекурсивно вызывает себя для левого подотрезка и правого подотрезка текущего узла v. Это позволяет обновить значения элементов на соответствующих подотрезках.
После обновления значений в подотрезках, значение узла v пересчитывается как сумма значений его дочерних узлов (tree[v] = tree[v * 2] + tree[v * 2 + 1]).

 ##  *Пример выполнения*
  #### 1
 <img src="images/p (39).png">
  #### 2
  <img src="images/p (40).png">
  #### 3
  <img src="images/p (41).png">
  В результате выполнения данной работы были получены следующие практические навыки:

+ изучение структуры дерево суммы
+ умение работать с header-файлами
+ изучение базовых алгоритмов для работы со структурами типа дерево суммы
  # Thank you for your attention!
