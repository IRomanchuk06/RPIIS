
# Расчётная работа

## Задача
5.15 Найти мосты в неоринетированном графе.

## Цель
Продемонстрировать работу алгоритма поиска мостов при помощи графов.

## Список ключевых понятий
* ***Граф*** - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.
* ***Неориентированный граф*** - граф, рёбра которого не имеют определённого направление.
* ***Мост*** - ребро в теории графов, удаление которого увеличивает число компонентов связности.

## Алгоритм

1. Берём начальную вершину.
2. Назначаем переменной `parent` значение взятой вершины.
3. Одну из вершин, смежной с начальной, присваиваем переменной `child`.
4. Все вершины, кроме занесённой в переменную `parent` добавляем во множество непосещённых вершин `not_checked_vertex`.
5. Запускаем волну, которая по умолчанию включает вершину из переменной `parent`.
6. Запускается новая волна, включающая значение вершины, смежной с `parent`, но не являющейся `child`. Вершина, включённая в волну, удаляется из множества непосещённых вершин. Если таковой вершины не существует, то создаём структуру и добавляем в неё ребро `child`-`parent`, которое будет являться мостом.
7. Продолжаем запускать волны уже без ограничения на смежную вершину (теперь волна может включать в себя вершину `child`). После каждой волны проверяем: есть ли во множестве `not_checked_vertex` вершина `child`.
   + Если она там есть, запускаем следующую волну пока вершина `child` не исчезнет из множества или пока смежных вершин не останется.
   + Если же вершины `child` во множестве непосещённых нет, то считаем ребро `parent`-`child` проверенным и назначаем переменной `child` другую вершину, смежную с `parent`.
     - Если же другой смежной вершины нет, то назначаем `parent` другую вершину.
   + Если смежных вершин нет, а вершина `child` всё ещё находится во множестве непосещённых вершин, считаем ребро `parent`-`child` мостом.
  
### Графодинамическая демонстрация алгоритма

Шаг 1.
На в программу приходит неориентированный граф. Выбираем вершину A, назначаем её в переменную `parent`. Назначаем одну из вершин, смежных А, переменной `child`, в этом случае вершину С.

Фактически, мы будем проверять: является ли ребро `parent`-`child` мостом.

![шаг 1](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/1.png)
  
Шаг 2.
Добавляем все вершины, кроме вершины `parent` (A) во множество непосещённых вершин `not_checked_vertex`.
  
![шаг 2](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/2.png)
  
Шаг 3.
Запускаем первую волну, принимаюшую значение вершины A.
  
![шаг 3](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/3.png)
  
Шаг 4.
Запускаем сдедующую волну, принимающую значение одной из вершин, смежных с предыдущей, но не являющейся `child` и находящейся во множестве непосещённых вершин. Волна получает значение вершины B. Удаляем эту вершину из множества непосещённых вершин.

![шаг 4](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/4.png)

Шаг 5.
Запускаем следующую волну, принимающую значение одной из вершин, смежных с вершиной B, уже без ограничений, кроме того, что вершина должна находится во множестве непосещённых вершин.

Волна получает значение C. Удаляем эту вершину из множества непосещённых вершин.

Так как вершина `child` (C) пропадает из множества непосещённых вершин, то можно считать ребро A-C проверенным и переходить к следующему.

![шаг 5](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/5.png)

Шаг 6.
Запускаем новую первую волну. Назначаем теперь переменной `child` значение вершины B.

Таким образом начинаем проверку ребра A-B. Обновляем множество непосещённых вершин.
  
![шаг 6](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/6.png)

Шаг 7.
Запускаем сдедующую волну, принимающую значение одной из вершин, смежных с предыдущей, но не являющейся `child` и находящейся во множестве непосещённых вершин.

Волна получает значение вершины C. Удаляем эту вершину из множества непосещённых вершин.
  
![шаг 7](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/7.png)

Шаг 8.
Запускаем следующую волну, принимающую значение одной из вершин, смежных с вершиной С.

Волна получает значение B. Удаляем эту вершину из множества непосещённых вершин.

Так как вершина `child` (B) пропадает из множества непосещённых вершин, то можно считать ребро A-B проверенным и переходить к следующему.
  
![шаг 8](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/8.png)

Шаг 9.
Запускаем новую первую волну. Назначаем теперь переменной `parent` значение вершины B, а переменной `child` значение вершины C.

Таким образом начинаем проверку ребра B-C. Обновляем множество непосещённых вершин.
  
![шаг 9](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/9.png)

Шаг 10.
Запускаем сдедующую волну, принимающую значение одной из вершин, смежных с предыдущей, но не являющейся `child` и находящейся во множестве непосещённых вершин.

Волна получает значение вершины A. Удаляем эту вершину из множества непосещённых вершин.
  
![шаг 10](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/10.png)

Шаг 11.
Запускаем следующую волну, принимающую значение одной из вершин, смежных с вершиной A.

Волна получает значение C. Удаляем эту вершину из множества непосещённых вершин.

Так как вершина `child` (C) пропадает из множества непосещённых вершин, то можно считать ребро B-C проверенным и переходить к следующему.
  
![шаг 11](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/11.png)

Шаг 12.
Запускаем новую первую волну. Назначаем теперь переменной `parent` значение вершины C, а переменной `child` значение вершины D.

Таким образом начинаем проверку ребра C-D. Обновляем множество непосещённых вершин.
  
![шаг 12](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/12.png)

Шаг 13.
Запускаем сдедующую волну, принимающую значение одной из вершин, смежных с предыдущей, но не являющейся `child` и находящейся во множестве непосещённых вершин.

Волна получает значение вершины B. Удаляем эту вершину из множества непосещённых вершин.
  
![шаг 13](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/13.png)

Шаг 14.
Запускаем следующую волну, принимающую значение одной из вершин, смежных с вершиной B.

Волна получает значение A. Удаляем эту вершину из множества непосещённых вершин.
  
![шаг 14](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/14.png)

Шаг 15.
Так как смежных вершин более не осталось, а вершина `child`(D) всё ещё остаётся во множестве непосещённых вершин, то можно сделать вывод, что ребро C-D является мостом.

Добавим ребро C-D в результат работы алгоритма.
  
![шаг 15](https://github.com/iis-32170x/RPIIS/blob/%D0%93%D0%B5%D1%82%D0%BC%D0%B0%D0%BD_%D0%94/sem2/PP/screenshots/15.png)
## Вывод
Формализовал алгоритма поиска мостов в неоринетированном графе.
