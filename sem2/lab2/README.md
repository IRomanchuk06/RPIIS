# Лабораторная работа №2 

![image](https://github.com/iis-32170x/RPIIS/assets/135509020/9ca8fe90-2c49-48a1-ad03-49b7ef0d6d61)

# Задача:

Реализовать разность двух множеств, с учетом кратных вхождений элементов.

# Цель:

Разность двух мультимножеств (Вариант 13).

## Список ключевых понятий:
* <em>Множество</em> - одно из ключевых понятий математики, представляющее собой набор, совоку́пность каких-либо (вообще говоря любых) объектов — элементов этого множества.
* <em>Мультимножество</em> - модификация понятия множества, допускающая включение одного и того же элемента в совокупность по нескольку раз.
* <em>Функция кратности элемента</em> - число, определяющее количество вхождений одного элемента в мультимножество. Если функция кратности равна 0, то говорят что элемент не входит в это мульимножество
* <em>Разность множеств с учетом кратных вхождений</em> - (так же арифметическая разность мультимножеств) - мультимножество, состоящее из тех элементов мультимножества A, кратность которых превышает кратность соответствующих элементов в мультимножестве B. Кратность каждого элемента результирующего множества равна разности кратностей соответствующих элементов в вычитаемых мультимножествах.

## Алгоритм разности множеств с учетом кратных вхождений элементов:

Для каждого одного элемента первого множества (1), мы проверяем все элементы второго множества (2) на равность. Если мы находим какую либо пару одинаковых элементов, то записываем в результирующее множество найденный элемент с функцией кратности, равной разности кратности элемента первого множества (1) и кратности элементов второго множества (2) и переходим к следующему элементу первого множества (1). Если разность кратностей меньше, либо равна числа 0, то не записываем и переходим к следующему элементу первого множества (1). Алгоритм работает до тех пор, пока не будут рассмотрены все элементы первого (1) и второго (2) множеств.

## Программная реализация и пример работы

```c++
vector<pair<int, char>> Set::SetDifference(int polarity) {
    int uno;
    int dos;
    if (polarity == 1) {
         uno = 0;
         dos = 1;
    }
    else {
         uno = 1;
         dos = 0;
    }
    switch (polarity) {
    default: {
        cout << "There is no such option." << '\n';
        return result;
        break;
    }
    case 1:
    case 2: {
        for (int i = 0;i < SETS[uno].size();i++) {

            for (int j = 0;j < SETS[dos].size();j++) {

                if (SETS[uno][i].second == SETS[dos][j].second) {

                    if (SETS[uno][i].first > SETS[dos][j].first) {

                        result.push_back(make_pair(SETS[uno][i].first - SETS[dos][j].first, SETS[uno][i].second));
                        break;
                    }
                    else {
                        break;
                    }
                }
                else {
                    if (j == SETS[dos].size() - 1 && SETS[uno][i].second != SETS[dos][j].second) {
                        result.push_back(make_pair(SETS[uno][i].first, SETS[uno][i].second));
                    }
                }
            }
        }
        return result;
    }
    }
}
```
Программа выполняется в соответствии с описанным алгоритмом.

### Пример:

![image](https://github.com/iis-32170x/RPIIS/assets/135509020/1fb562d0-d034-47e4-9c9b-5e6cc2087c88)
