# Лабораторная работа №2
## Условие задания (вариант 10)
Реализовать программу, формирующую множество равное объединению произвольного количества исходных множеств (с учётом кратных вхождений элементов).

**Цель:** Создать множество, которое будет содержать все элементы из всех исходных множеств, включая повторяющиеся элементы.

**Задача:** Принять произвольное количество исходных множеств.Объединить все исходные множества в одно множество, учитывая кратные вхождения элементов. Вывести полученное множество на экран.

----

# Список понятий:

`Множество` – простейшая информационная конструкция и математическая структура, позволяющая рассматривать какие-то объекты как целое, связывая их.
Объекты, связываемые некоторым множеством, называются `элементами` этого множества.

`Объединением` неориентированных множеств A и B `с учётом кратных вхождений` элементов будем называть неориентированное множество S тогда и только тогда, когда для любого x истинно S|x| = max{A|x|, B|x|}.

# Алгоритм 

1. **Определение файла:**
   - Вывести пользователю список файлов и запросить выбор.
   - Считать выбор пользователя.
   - Определить путь к выбранному файлу.

2. **Чтение данных из файла (функция run_testcase):**
   - Открыть выбранный файл.
   - Если файл не открыт, вывести сообщение об ошибке.
   - Иначе считать количество множеств данных из файла.
   - Инициализировать векторы для хранения множеств данных.
   - Для каждого множества данных:
     - Считать строку из файла.
     - Разделить строку на элементы и добавить их в соответствующее множество данных.

3. **Подсчет количества вхождений каждого элемента (функция CountMultiplicities):**
   - Инициализировать вектор для хранения подсчетов вхождений для каждого множества данных.
   - Для каждого множества данных:
     - Инициализировать вектор для хранения уникальных элементов и их количества в множестве.
     - Для каждого элемента в множестве:
       - Если элемент уже встречался, увеличить его счетчик в векторе элементов.
       - Иначе добавить элемент в вектор уникальных элементов и установить его счетчик в 1.
     - Добавить вектор уникальных элементов и их счетчиков в вектор подсчетов.

4. **Нахождение максимального количества вхождений для каждого элемента (функция FindMaxMultiplicities):**
   - Инициализировать вектор для хранения максимальных количеств вхождений для каждого элемента.
   - Для каждого множества данных:
     - Для каждой пары элемента и его количества:
       - Если элемент уже встречался, обновить его счетчик максимального количества вхождений.
       - Иначе добавить пару в вектор максимальных количеств вхождений.

5. **Вывод результатов (функция OutputResult):**
   - Вывести объединение всех множеств данных, используя элементы с максимальным количеством вхождений.
  
  
# Тестирование работы программы с помощью GTests


1. **EmptyFileTest:** 
   - Проверяет, что при открытии пустого файла функция `run_testcase` корректно устанавливает количество наборов и вектор наборов как пустые.

2. **SingleSetTest:** 
   - Проверяет функцию `CountMultiplicities` на одном наборе элементов. 
   - Сравнивает ожидаемый результат с фактическим количеством вхождений каждого элемента в набор.

3. **MultipleSetsTest:** 
   - Проверяет функцию `CountMultiplicities` на нескольких наборах элементов. 
   - Сравнивает ожидаемый результат с фактическим количеством вхождений каждого элемента в каждом наборе.

4. **SingleSetTest:** 
   - Проверяет функцию `FindMaxMultiplicities` на одном наборе пар (элемент, количество вхождений). 
   - Сравнивает ожидаемый результат с фактическим максимальным количеством вхождений для каждого уникального элемента.

5. **MultipleSetsTest:** 
   - Проверяет функцию `FindMaxMultiplicities` на нескольких наборах пар (элемент, количество вхождений). 
   - Сравнивает ожидаемый результат с фактическим максимальным количеством вхождений для каждого уникального элемента из всех наборов.

6. **OutputResultTest:** 
   - Проверяет функцию `OutputResult`, которая выводит объединение всех наборов с учетом повторений элементов. 
   - Проверяет корректность вывода на основе заданных максимальных количеств вхождений для каждого элемента.


# Результаты тестирования

Приведем пример выполнения программы для файла set1.txt.

![Снимок экрана 2024-03-13 094135](https://github.com/iis-32170x/RPIIS/assets/145226586/a84b55f5-1c5e-4e68-a29e-86f21f060263)

![Снимок экрана 2024-03-13 100231](https://github.com/iis-32170x/RPIIS/assets/145226586/9147814f-925f-4cc6-9a11-7d60aadc0e91)


# Источники
[Написание GTests](https://habr.com/ru/articles/667880/)
[Использование библиотеки STL vector]([https://habr.com/ru/articles/667880/](https://learn.microsoft.com/ru-ru/cpp/standard-library/vector-class?view=msvc-170)https://learn.microsoft.com/ru-ru/cpp/standard-library/vector-class?view=msvc-170)
[Использование библиотеки STL pair]([https://habr.com/ru/articles/667880/](https://informatics.msk.ru/mod/book/view.php?id=492&chapterid=206))

# Вывод
Реализовала в C++ программу для нахождения объединения множеств.
