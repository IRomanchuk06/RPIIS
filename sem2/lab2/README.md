# Лабораторная работа №2

Вариант 1. Реализовать программу, формирующую множество равное объединению произвольного
количества исходных множеств (без учёта кратных вхождений элементов).

## Цели лабораторной работы:
1. Разработать программу по объединению множеств.
2. Создать тестовую программу для демонстрации функциональности разработанной программы.
3. Разработать систему тестов для проверки работоспособности и корректности программы, учитывая требования полноты, адекватности и непротиворечивости.
4. Обеспечить обработку некорректных данных, предусмотрев сообщениие о некорректности входных данных, программа не должна терять управления в результате ошибки исполнения.
5. Составить отчет по выполнению лабораторной работы.
   
## Задачи лабораторной работы:
1. Изучить спецификацию задачи по работе с объединением множеств и с чтением формализованной информации из файла.
2. Разработать и реализовать программу для объединения множеств(без учёта кратных вхождений), чтения из файла и записи в файл информации в заданном формате.
4. Разработать систему тестов, включающую тест-кейсы для проверки различных аспектов работы библиотеки, включая корректность, производительность и обработку ошибок.
5. Провести тестирование разработанной библиотеки, убедившись в ее правильной работе на различных входных данных.
6. Составить подробный отчет, включая описание решения задачи, архитектуры библиотеки, результаты тестирования и выводы.

## Список используемых понятий:
1. `Библиотека программного обеспечения (Библиотека кода):` в программировании библиотека представляет собой совокупность программного кода, предназначенного для решения определенных задач. Этот код может содержать функции, классы, процедуры или другие компоненты, которые разработчики могут повторно использовать в своих программных проектах. Библиотеки упрощают разработку, так как они предоставляют готовые решения для типовых задач.
2. `Библиотека fstream:` содержит инструменты для работы с файлами.
3. `Библиотека string:` позволяет удобно работать со строками.
4. `Библиотека regex:` необходима для для поиска и осуществления манипуляций с подстроками в тексте.
5. `Библиотека gtest/gtest.h:` библиотека для модульного тестирования на языке С++.
6. `Библиотека vector:` открывает доступ удобной работы с динамическим массивом.
7. `Множество:` простейшая информационная конструкция и математическая структура, позволяющая рассматривать какие-то объекты как целое, связывая их.
8. `Объединение неориентированных множеств A и B без учёта кратных вхождений
элементов:` будем называть неориентированное множество S тогда и только тогда, когда для
любого x истинно S|x|=min{max{A|x|, B|x|}, 1}.

## Формат данных:
![Снимок экрана от 2024-03-05 18-00-01](https://github.com/iis-32170x/RPIIS/assets/146863499/df942b3c-78b2-4f5e-9696-c107e0277757)

## Структура данных:
В программе используется следующая структура для множеств:
```cpp
struct myset{
    string name;
    vector<string> elements;
    bool poradok;
};
```
Любое множество имеет имя, свойство порядка (орентированное/неорентированное) и вектор элементов, при этом любой элемент представлен именем, а значит в программе может быть представлен любой уровень вложенности множеств.

## Описание используемых алгоритмов:
### Функция проверки формата(`bool format(string name, vector<myset> &mnojestva, string &all_file)`):
К сожалению, я не нашел сопособ представить рекурсивное регулярное выражения на с++, поэтому данная функция не только проверяет формат но и создает имена для вложенных множеств.

Функция принимает три параметра:
- `name` --- имя файла;
- `mnojestva` --- вектор всех известных множеств;
- `all_file` --- строковое представление файла;

##
1. Открываем файл;
2. Записываем его в переменную `all_file`;
3. Закрываем файл;
4. Создаем регулярное выражение для всей строки(`regular1`);
5. Создаем регулярное выражение для вложенного множества(`regular2`);
6. Запучкаем цикл пока строка не находиться с помощью `regular1`:
    
    - Находим все подстроки подходящие под `regular2`(если таких нет, выходим из функции со значением `false`);
    - С помощью функции `replace_na_names` заменяем найденные подмножества на имена.
7. Возвращаем `true`

```cpp
bool format(string name, vector<myset> &mnojestva, string &all_file){
    ifstream fin;
    fin.open(name);
    if (fin.is_open()){
        string temp;
        while (getline(fin, temp))
            all_file += temp + "\n";
        fin.close();

        const regex regular1(FORMA_1);
        const regex regular2(FORMA_2);
        
        while (!regex_match(all_file.c_str(), regular1)){

            const vector<smatch> matches{
                sregex_iterator{C_ALL(all_file), regular2},
                sregex_iterator{}
            };

            if (matches.size() == 0)
                return false;

            string *temps{new string[matches.size()]};
            for (int i{0}; i < matches.size(); i++)
                temps[i] = matches[i].str();
            for (int i{0}; i < matches.size(); i++)
                replace_na_names(all_file, temps[i], add_set(temps[i], mnojestva));

            delete[] temps;
        }
        return regex_match(all_file.c_str(), regular1);
    }
    else
        return false;
}
```

### Функция представления всех множеств(`void make_sets(string &all_file, vector<myset> &mnojestva)`):
Данная функция представляет все множества из файла ввиде вектора структур `myset`.

Функция принимает два параметра:
- `mnojestva` --- вектор всех известных множеств;
- `all_file` --- строковое представление файла;

##
Алгоритм выполняется для каждой строки из `all_file`.
1. Записываем в `new_name` все что до "=" ;
2. Записываем в `elements` все что после "=" ;
3. Раскладываем `elements` на вектор имен `new_elements` с помощью функции `razbil_na_names`;
4. Записываем в `set_or_kortj` порядок множества с помощью функции `poradoc`;
5. Если уже существует множество в `mnojestva` с параметрами (..., `new_elements`, `set_or_kortj`), то везде меняем его имя на `new_name`(логично использовать имена написанные человеком, а не пргораммой) при помощи функций `replace_na_names`;

```cpp
void make_sets(string &all_file, vector<myset> &mnojestva){
    bool ravno_nextstroka{true};
    string new_name, elements;
    for (int number{0}; number < all_file.size(); number++){
        if (all_file[number] == '='){
            ravno_nextstroka = false;
            continue;
        }
        else if (all_file[number] == '\n'){
            ravno_nextstroka = true;
            bool flag{true}, set_or_kortj{poradoc(elements)};;
            vector<string> new_elements{razbil_na_names(elements)};
            for (int i{0}; i < mnojestva.size(); i++){
                if (set_or_kortj == mnojestva[i].poradok && new_elements == mnojestva[i].elements){
                    flag = false;
                    replace_na_names(mnojestva, mnojestva[i].name, new_name);
                    replace_na_names(all_file, mnojestva[i].name, new_name);
                    mnojestva[i].name = new_name;
                    break;
                }       
            }
            if (flag)
                mnojestva.push_back({new_name, new_elements, set_or_kortj});
            new_name = elements = "";
            continue;
        }
        if (ravno_nextstroka)
            new_name += all_file[number];
        else
            elements += all_file[number];
    }
}
```

### Функция представления всех множеств(`void union_sets(myset &result_set, vector<myset> &mnojestva)`):
Данная функция объединяет множества из файла, результат записывает в `result_set`.

Функция принимает два параметра:
- `mnojestva` --- вектор всех известных множеств;
- `result_set` --- множество результат;

##
Алгоритм выполняется для всех элементов из каждого множества из файла.
1. Если данный элемент не равен никакому элементу в `result_set`, то добавляем его туда;
2. Переходим к следующему элементу;
```cpp
void union_sets(myset &result_set, vector<myset> &mnojestva){
    for (int i{0}; i < mnojestva.size(); i++){
        if(mnojestva[i].name.substr(0,4) != "NEW_")
            for (string new_element: mnojestva[i].elements){
                bool flag{true};
                for (string element: result_set.elements){
                    if (new_element == element){
                        flag = false;
                        break;
                    }
                }
                if (flag){
                    result_set.elements.push_back(new_element);
                }
            }
    }
}
```

### Функция записи в файл(`void write(myset &result_set, vector<myset> &mnojestva, string name)`):
Данная функция записывает множество (в данном случае результирующее) в файл.

Функция принимает два параметра:
- `mnojestva` --- вектор всех известных множеств;
- `result_set` --- множество результат;
- `name` --- имя файла (из которого брались множества);
```cpp
void write(myset &result_set, vector<myset> &mnojestva, string name){
    ofstream fout;
    name.pop_back(); name.pop_back(); name.pop_back(); name.pop_back();
    fout.open("../sets/RESULT(" + name.substr(8) + ").txt");
    if (fout.is_open()){
        fout << result_set.name << "=";
        write_recursiv(result_set, mnojestva, fout);
        fout.close();
    }
    else{
        cout << "Ошибка???\n";
    }
}
```
##
Алгоритм выполняется для всех элементов из каждого множества из файла.
1. Создаем результ файл;
2. Записываем туда имя множества и знак равно;
3. При помощи функции `write_recursiv` записываем эелементы через запятую (все множества, кроме бесконечных, раскрываются на элементы).
4. Закрываем файл.
```cpp
void write(myset &result_set, vector<myset> &mnojestva, string name){
    ofstream fout;
    name.pop_back(); name.pop_back(); name.pop_back(); name.pop_back();
    fout.open("../sets/RESULT(" + name.substr(8) + ").txt");
    if (fout.is_open()){
        fout << result_set.name << "=";
        write_recursiv(result_set, mnojestva, fout);
        fout.close();
    }
    else{
        cout << "Ошибка???\n";
    }
}
```

### Вспомагательные функции:
- Функция `add_set` --- добовляет новое множество в вектор всех множеств или находит подобное ему, возращает имя множества.
- Функция `razbil_na_names` --- преобразует сплошную строку элементов в ветктор имен.
- Функция `replace_na_names` --- заменяет информацию в строке или векторе всех множеств (зависит от параметров).
- Функция `poradoc` --- возврашает информацию о порядке множества (орентированное/неорентированное).
- Функция `write_recursiv` --- записывает в файл элементы и раскрывает имена множеств.
- Функция `do_all` --- собирает все остальные функции и выполняет поставленную задачу.

## Результаты тестирования
Тестирование проводилось с помощью `gtest.h`.
Результат выполнения:
![Снимок экрана от 2024-03-05 16-35-55](https://github.com/iis-32170x/RPIIS/assets/146863499/7c6b7b12-40d9-484b-b19a-5c86fc67b0b5)

## Вывод:
В ходе выполнения работы на практике применил регулярные выражения в С++, закрепил в голове концепцию реализация в .срр файлах, декларация -- в .hpp, закрепил навыки работы со структурами данных, продолжтл работу с Google C++ Testing Framework, реализоавал программу для объединения множеств(без учёта кратных вхождений), чтения из файла и записи в файл информации в заданном формате,а также создал систему тестов,которая проверяет корректность созданной программы, закрепил работу с cmake.
## Используемые источники:
честно не помню...
