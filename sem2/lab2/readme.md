# *Лабораторная работа №2*
## *Вариант 6*
***
### Задача:
Реализовать программу, формирующую множество равное декартовому произведению произвольного количества исходных множеств.
### Цель:
1. Разработать библиотеку для работы с одномерным массивом. (например, C++, Java, Python).
2. Создать тестовую программу для демонстрации функциональности разработанной библиотеки.
3. Разработать систему тестов для проверки работоспособности и корректности библиотеки, учитывая требования полноты, адекватности и непротиворечивости.
4. Обеспечить обработку некорректных данных, предусмотрев корректное завершение программы при возникновении ошибок.
5. Составить отчет по выполнению лабораторной работы.
### Ключевые понятия: 
___Множество___ – простейшая информационная конструкция и математическая структура,
позволяющая рассматривать какие-то объекты как целое, связывая их.

___Декартовым произведением___ неориентированных множеств A и B называют неориентированное множество S тогда и только тогда, когда для любого z истинно: если S|z| > 0, то z = <x, y>; S|z| = A|x|*B|y| и наоборот.

### Функции и алгоритмы программы
Функция setData предназначена для чтения данных из файла и заполнения вектора множеств sets.
1. Открывается файл с указанным путем filepath. Если файл не удается открыть, выводится сообщение об ошибке и функция завершается.
2. Читается число num_sets из файла, которое указывает количество множеств.
3. Пропускается символ новой строки после числа, чтобы перейти на следующую строку.
4. Вектор sets изменяется в размере, чтобы содержать num_sets пустых множеств.
5. Для каждого множества выполняется следующее:
    * Считывается строка из файла и сохраняется в переменной line.
    * Удаляются пробелы из строки, чтобы удалить лишние пробелы.
    * Строка разбивается на элементы множества с использованием разделителя ",".
    * Если элемент начинается с символа "{", это означает, что есть вложенное множество. Элементы объединяются в один элемент до закрывающей скобки "}". Все объединенные элементы добавляются в текущее множество sets[i].
    * Если элемент не начинается с "{", он считается обычным элементом и добавляется в текущее множество sets[i].
6. Файл закрывается.
```c++
void setData(const string& filepath, int& num_sets, vector<vector<string>>& sets)
{
    setlocale(LC_ALL, "RU");
    ifstream file;
    file.open(filepath);

    if (!file.is_open())
    {
        cout << "Не удалось открыть файл";
        return;
    }

    file >> num_sets;
    file.ignore(numeric_limits<streamsize>::max(), '\n');

    sets.resize(num_sets);

    for (int i = 0; i < num_sets; ++i)
    {
        string line;
        getline(file, line);

        // Удаляем пробелы из строки
        line.erase(remove(line.begin(), line.end(), ' '), line.end());
        // Разделяем строку на элементы множества
        stringstream ss(line);
        string element;
        while (getline(ss, element, ','))
        {
            // Если элемент начинается с {, объединяем все элементы до закрывающей }
            if (element[0] == '{')
            {
                string combined_element = element;
                while (element[element.length() - 1] != '}')
                {
                    getline(ss, element, ',');
                    combined_element += ',' + element;
                }
                sets[i].push_back(combined_element);
            }
            else
            {
                sets[i].push_back(element);
            }
        }
    }

    file.close();
}
```
Функция cartesianProducts выполняет вычисление декартова произведения (произведения всех возможных комбинаций) множеств, переданных вектором sets. Вот краткое описание этой функции:
1. Функция принимает следующие параметры:
    * sets: вектор множеств, для которых нужно вычислить декартово произведение.
    * cur: текущий индекс множества, которое обрабатывается.
    * num_sets: общее количество множеств.
    * combinations: вектор для сохранения всех комбинаций декартова произведения.
    * elements: временный вектор для хранения текущей комбинации элементов.
2. В цикле проходятся все элементы текущего множества sets[cur].
3. Текущий элемент добавляется в вектор elements, представляющий текущую комбинацию элементов.
4. Если cur указывает на последнее множество (cur == num_sets - 1), то текущая комбинация elements считается завершенной и добавляется в вектор combinations.
5. В противном случае вызывается рекурсивно функция cartesianProducts с увеличенным значением cur, чтобы перейти к следующему множеству.
6. После каждой рекурсивного вызова элементы из elements удаляются с помощью elements.pop_back(). Это выполняется для того, чтобы очистить текущую комбинацию и дать место для новых элементов при следующих итерациях цикла.
```c++
void cartesianProducts(const vector<vector<string>>& sets, int cur, int& num_sets, vector<vector<string>>& combinations, vector<string>& elements)
{
    for (int i = 0; i < sets[cur].size(); i++)
    {
        elements.push_back(sets[cur][i]);

        if (cur == num_sets - 1)
        {
            combinations.push_back(elements);
        }
        else
        {
            cartesianProducts(sets, cur + 1, num_sets, combinations, elements);
        }

        elements.pop_back();
    }
}
```
Вывод результата на экран:
1. Функция принимает путь к файлу в качестве параметра filepath.
2. Объявляются переменные num_sets для хранения количества множеств, sets для хранения множеств, comb для хранения комбинаций декартова произведения и el для временного хранения текущей комбинации элементов.
3. Вызывается функция setData, которая читает данные из файла и заполняет вектор sets и переменную num_sets.
4. Вызывается функция cartesianProducts, которая вычисляет декартово произведение множеств и сохраняет результаты в векторе comb.
5. Выводится открывающая фигурная скобка "{", чтобы обозначить начало вывода комбинаций.
6. В цикле проходятся все комбинации вектора comb.
7. Для каждой комбинации выводится символ "<", а затем элементы комбинации из каждого множества.
8. Если индекс j не равен 0, то выводится символ "; " перед каждым элементом множества для разделения элементов.
9. Закрывающая фигурная скобка "}" выводится после завершения цикла комбинаций.
10. Функция возвращает 0.
```c++
int print(const std::string& filepath){
    int num_sets;
    vector<vector<string>> sets, comb;
    vector<string> el;
    setData(filepath, num_sets, sets);
    cartesianProducts(sets, 0, num_sets, comb, el);
    cout << endl << "{";
    for (int i = 0; i < comb.size(); i++)
    {

        cout << " <";
        for (int j = 0; j < num_sets; j++)

        {
            if (j != 0) cout << "; ";
            cout << comb[i][j];

        }

        cout << ">";
    }
    cout << "}";
    return 0;
}
```
### Тест программы
Данные для теста находятся в файлах test1.txt, test2.txt, test3.txt, test4.txt. Тестовая программа test.cpp.

Пример результата работы программы:
![тест](https://github.com/iis-32170x/RPIIS/assets/146451109/7ba9cf9e-5b3d-4e00-82e2-3f35ee705a66)
***
### Вывод
Создана библиотека с функциями для нахождения декартова произведения множеств

### Источники 
[Создание библиотеки Visual Studio C++](https://www.youtube.com/watch?v=5mD-rhaYF4U )
