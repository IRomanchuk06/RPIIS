# <p align="center">Лабораторная работа №1</p>

Вариант 26. Неориентированный граф. Вставка вершины. Удаление вершины.
Вставка дуги. Удаление дуги. Построение дерева обхода в глубину.

## <p align="center">Цели лабораторной работы:</p>
1. Разработать библиотеку для работы с неориентированным графом на выбранном императивном языке программирования (например, C++, Java, Python).
2. Создать тестовую программу для демонстрации функциональности разработанной библиотеки.
3. Разработать систему тестов для проверки работоспособности и корректности библиотеки, учитывая требования полноты, адекватности и непротиворечивости.
4. Обеспечить обработку некорректных данных, предусмотрев корректное завершение программы при возникновении ошибок.
5. Составить отчет по выполнению лабораторной работы.
   
## <p align="center">Список используемых понятий и алгоритмов:</p>
1. **Библиотека программного обеспечения (Библиотека кода):**
В программировании библиотека представляет собой совокупность программного кода, предназначенного для решения определенных задач. Этот код может содержать функции, классы, процедуры или другие компоненты, которые разработчики могут повторно использовать в своих программных проектах. Библиотеки упрощают разработку, так как они предоставляют готовые решения для типовых задач.

2. **Граф** – совокупность двух множеств — множества самих объектов и множества их парных связей.

3. **Нериентированный граф**  — граф, рёбрам которого не присвоено направление.

4. **Ребро графа** — это то, что соединяет две вершины.

5. **Список смежности** — один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

6. **Поиск в глубину (Deep First Search, DFS)** — алгоритм обхода графа, который движется от начальной вершины как можно дальше сначала по первому ребру, потом по второму, и так далее.

## <p align="center">Описание используемых алгоритмов:</p>
Для представления графа используется *список смежности* для более удобной работы. Реализация списка основана на библиотеках map и set на С++.

```cpp
map<int, std::set<int>> graph;
```
где `int` - вершина, а в `set<int>` записаны все соседи вершины.

1. **Вставка вершины :** добавление в список новую вершину, если таковой не имелось.

```cpp
void Ngraph::AddVertex(int a) {
    if ((graph.find(a) == graph.end())&&a>0) {
        graph[a] = std::set<int>();
    }
}
```

2. **Вставка ребра:** добавление ребра в списки смежностей обеих вершин, если вершины существуют в графе. Ошибка если вершины не существует.

```cpp
void Ngraph::AddEdge(int a, int b) {
    if (!VertexExists(a) || !VertexExists(b)) {
        throw std::invalid_argument("This vertex(es) is not exist");
    }
    graph[a].insert(b);
    graph[b].insert(a);
}
```
   
3. **Удаление вершины:** удаление вершины из списка, а так же всех связанных рёбер.

```cpp
void Ngraph::DeleteVertex(int a)
{
    graph.erase(a);
    
    for (auto& kv : graph) {
        kv.second.erase(a);
    }
}
```

4. **Удаление ребра:** удаление ребра, если таковое имелось.

```cpp
void Ngraph::DeleteEdge(int a, int b)
{
    if (graph.find(a) == graph.end() || graph.find(b) == graph.end() || graph[a].find(b) == graph[a].end()) {
        return;

    }
        graph[a].erase(b);
        graph[b].erase(a);
}
 ```
5. **Дерево обхода в ширину:**

5.1 *Вспомогательная функция DFS* - сама функция обхода в ширину.

```cpp
   void Ngraph::DFS(int a, std::map<int, bool>& visited)
{
    visited[a] = true; 
    std::cout << a << " ";
    for (int neighbor : graph[a]) {
        if (!visited[neighbor]) {
           DFS(neighbor, visited); 
        }
    }
    for (const auto& kv : graph) {
        if (!visited[kv.first]) {
            DFS(kv.first, visited);
        }
    }
}
 ```

Создание контейнера для записи посещенных вершин - `std::map<int, bool>& visited`. Отмечаем первую вершину и после рекурсивно вызываем функцию для соседа. Предусмотрено условие для несвязного графа - если есть хоть одна непосещённая вершина, то DFS запускается из не снова.

5.2 *Функция DFSTree* - Вывод дерева пользователю.

```cpp
void Ngraph::DFSTree(int first)
{
    std::map<int, bool> visited;
    DFS(first, visited);
    std::cout << std::endl;
}
 ```


## <p align="center">Результаты тестирования:</p>
Тестирование проводилось с помощью фреймворка Google test. Система тестов состоит из 6 тестов: 5 тестов на работу всех функций и 1 на ожидаемую ошибку. Все тесты прошли успешно.

<p align="center">
   
  ![tests](https://github.com/iis-32170x/RPIIS/assets/147048129/c8080879-0aba-4a4e-8886-221105d3fdf4)

</p>

**Система тестов:**

```cpp
#include "pch.h"
#include <gtest/gtest.h>
#include "../priorituQueue/priorityQueue.h"
using namespace std;

//базовый тест на вставку и извлечение
TEST(PriorityQueueTest, InsertAndExtract1) {
    PriorityQueue pq;

    EXPECT_TRUE(pq.isEmpty());

    pq.insert(10);
    pq.insert(5);
    pq.insert(20);

    EXPECT_FALSE(pq.isEmpty());

    EXPECT_EQ(pq.extract(), 20);
    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), 5);

    EXPECT_TRUE(pq.isEmpty());
}

//базовый тест на вставку и извлечение
TEST(PriorityQueueTest, InsertAndExtract2) {
    PriorityQueue pq;

    pq.insert(10);
    pq.insert(5);
    pq.insert(20);
    pq.insert(15);
    pq.insert(25);

    EXPECT_EQ(pq.extract(), 25);
    EXPECT_EQ(pq.extract(), 20);
    EXPECT_EQ(pq.extract(), 15);
    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), 5);

    EXPECT_TRUE(pq.isEmpty());
}

//тест на вставку и извлечение с одинаковыми элементами
TEST(PriorityQueueTest, InsertAndExtractWithDuplicates) {
    PriorityQueue pq;
    pq.insert(10);
    pq.insert(5);
    pq.insert(10);
    pq.insert(8);

    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), 8);
    EXPECT_EQ(pq.extract(), 5);
    EXPECT_TRUE(pq.isEmpty());
}

//тест на извлечение из пустой очереди
TEST(PriorityQueueTest, ExtractFromEmptyQueue) {
    PriorityQueue pq;

    EXPECT_THROW(pq.extract(), std::out_of_range);
}

//тест на вставку и извлечение с отрицательными элементами
TEST(PriorityQueueTest, InsertWithNegativeNumbers) {
    PriorityQueue pq;
    
    pq.insert(10);
    pq.insert(-5);
    pq.insert(25);
    pq.insert(-10);
    pq.insert(-2);

    EXPECT_EQ(pq.extract(), 25);
    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), -2);
    EXPECT_EQ(pq.extract(), -5);
    EXPECT_EQ(pq.extract(), -10);
    EXPECT_TRUE(pq.isEmpty());
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```
## <p align="center">Вывод:</p>

В результате выполнения лабораторной работы были углублены знания в области принципов работы приоритетных очередей, основанных на max-heap. Освоена методика "подъема" и "опускания" элементов, что позволило эффективно управлять структурой данных с максимальным элементом в корне. Также приобретены навыки применения стандартных контейнеров C++, в частности, использование `std::vector` для представления бинарной кучи.

Реализована библиотека для приоритетной очереди, включающая грамотные операции вставки, извлечения и проверки на пустоту, обеспечив эффективность и корректность работы структуры данных. Написаны тесты с использованием Google Test, что позволило убедиться в надежности и правильности реализации.

Лабораторная работа предоставила глубокое понимание проектирования и реализации приоритетных очередей. Опыт работы с тестовыми фреймворками, в данном случае с Google Test, был ценен для проверки функциональности кода и обеспечения его корректности. Использование стандартных исключений для обработки ошибок стало неотъемлемой частью опыта в создании надежных программных решений.

## <p align="center">Используемые источники:</p>
1. Алгоритмы: построение и анализ, 2-е издание. : Пер. с англ. – М. :
Издательский дом «Вильямс», 2005. – 1296 с.
2. Лекции М. Густокашина по олимпиадному программированию
3. Олимпиадное программирование в Бресте и Беларуси: [Электронный ресурс]. URL: https://brestprog.by/.
