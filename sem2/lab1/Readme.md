# Лабораторная работа №1

## Задача:
- Разработать библиотеку для работы со структурой данных, указанной в
индивидуальном задании, на любом императивнойм языке
программирования (Pascal, C\C++, Java, C#, Python и др.)
- Разработать тестовую программу, которая демонстрирует
работоспособность реализованной библиотеки работы со структурой
данных.
- Разработать систему тестов, которые продемонстрировали бы
работоспособность реализованной библиотеки
- По результатам выполнения задания составить отчет.
# Вариант 8:
Декартово дерево. Вставка. Поиск. Удаление. Построение дерева из
массива значений. Объединение двух деревьев. Пересечение двух
деревьев.
## Цель:
Исследовать свойства структур данных и разработать
библиотеку алгоритмов обработки структур данных.

## Список ключевых понятий:
- *Декартово дерево* или *дерамида* (англ. *Treap*) — это структура данных, объединяющая в себе *бинарное дерево поиска* и *бинарную кучу* (отсюда и второе её название: *treap* (tree + heap) и *дерамида* (дерево + пирамида), также существует название *курево* (куча + дерево).
- *Бинарное дерево поиска* (англ. *binary search tree*, *BST*) — структура данных для работы с упорядоченными множествами.
- *Двоичная куча* представляет собой полное бинарное дерево, для которого выполняется основное свойство кучи: приоритет каждой вершины больше приоритетов её потомков.
## Свойства:
- Проще реализуется по сравнению, например, с настоящими самобалансирующимися деревьями вроде красно-чёрного.
- Хорошо ведёт себя «в среднем», если ключи y раздать случайно.
- Типичная для сортирующего дерева операция «разделить по ключу x на „меньше x0“ и „не меньше x0“» работает за O(h), где h — высота дерева. На красно-чёрных деревьях придётся восстанавливать балансировку и окраску узлов.
## Недостатки:
- Большие накладные расходы на хранение: вместе с каждым элементом хранятся два-три указателя и случайный ключ y.
- Скорость доступа O(n) в худшем, хотя и маловероятном, случае. Поэтому декартово дерево недопустимо, например, в ядрах ОС.
## Реализация:
Создадим класс Node, в которой будем хранить ключ и приоритет, а также указатели на левого и правого сына. Указателя на корень дерева достаточно для идентификации всего дерева. Поэтому, когда мы будем говорить «функция принимает два дерева» на самом деле будут иметься в виду указатели на их корни. К нулевому указателю же мы будем относиться, как к «пустому» дереву. Также создадим конструкторы для добавления «узлов» (указателей на поддеревья).
```cpp
class Node {
public:
    int key;
    int priority;
    Node* left;
    Node* right;
    bool rev;
    Node(int _key)
    {
        key = _key;
        srand((_key * 4 + 234) % 20 + 23);
        priority = rand() % 21;
        if (priority < 0) priority *= -1;
    }
    Node(int _key, int _priority)
    {
        key = _key;
        priority = _priority;
    }
};
```

## Результаты тестирования
```cpp
#include "Header.h"
using namespace std;
int main()
{
	system("chcp 1251 > nul");
	Treap tree;
	//Tест 1:
	if (!tree.root) cout << "Тест 1 пройден\n";
	// Тест 2:
	vector <int> keys = {1,3, 2, 4 };
	tree.buildTree(keys);
	tree.outTree(tree.root,0);
	for (int i = 0; i < 100; i++)
	{
		cout << '-';
	}
	cout << endl;
	for (int key: keys)
	{
		if (tree.search(tree.root, key)-> key!= key)
		{
			cout << "Ошибка";
			return 0;
		}
	}
	cout << "Тест 2 пройден\n";
	// Тест 3:
	for (int key : keys)
	{
		tree.erase(tree.root, key);
	}
	if(tree.root == nullptr) cout << "Тест 3 пройден\n";
	//Тест 4:
	tree.insert(9, 5);
	if (tree.search(tree.root, 9)->key == 9) cout << "Тест 4 пройден\n";
	tree.erase(tree.root, 9);
	//Тест 5:
	vector <int> keys2 = { 3, 5, 7, 8};
	vector <int> prioritys = { 5, 11, 4, 2};
	Treap tree2;
	tree2.buildTree(keys2, prioritys);
	for (int key : keys2)
	{
		if (tree2.search(tree2.root, key)->key != key)
		{
			cout << "Ошибка";
			return 0;
		}
	}
	tree2.outTree(tree2.root, 0);
	for (int i = 0; i < 100; i++)
	{
		cout << '-';
	}
	cout << endl;
	cout << "Тест 5 пройден\n";
	//Тест 6:
	Treap uniontree,tree1;
	tree1.buildTree(keys);
	uniontree.root = uniontree.unite(tree1.root, tree2.root);
	uniontree.outTree(uniontree.root,0);
	for (int i = 0; i < 100; i++)
	{
		cout << '-';
	}
	cout << endl;
	cout << "Тест 6 пройден\n";
	//Тест 7:
	Treap intersection,tree3;
	tree3.buildTree(keys);
	tree3.insert(5);
	tree3.insert(7);
	intersection.root = intersection.intersect(tree2.root, tree3.root);
	intersection.outTree(intersection.root,0);
	for (int i = 0; i < 100; i++)
	{
		cout << '-';
	}
	cout << endl;
	cout << "Тест 7 пройден\n";
}
```
![C__Users_ilyad_OneDrive_Рабочий стол_Священная лаба_x64_Debug_Project23 exe 27 02 2024 01_54_55](https://github.com/iis-32170x/RPIIS/assets/144374775/c6592c65-34bc-4e29-9913-bed076cbda6f)


