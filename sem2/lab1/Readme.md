# <p align="center">Лабораторная работа №1</p>

Вариант 26. Неориентированный граф. Вставка вершины. Удаление вершины.
Вставка дуги. Удаление дуги. Построение дерева обхода в глубину.

## <p align="center">Цели лабораторной работы:</p>
1. Разработать библиотеку для работы с неориентированным графом на выбранном императивном языке программирования (например, C++, Java, Python).
2. Создать тестовую программу для демонстрации функциональности разработанной библиотеки.
3. Разработать систему тестов для проверки работоспособности и корректности библиотеки, учитывая требования полноты, адекватности и непротиворечивости.
4. Обеспечить обработку некорректных данных, предусмотрев корректное завершение программы при возникновении ошибок.
5. Составить отчет по выполнению лабораторной работы.
   
## <p align="center">Список используемых понятий и алгоритмов:</p>
1. **Библиотека программного обеспечения (Библиотека кода):**
В программировании библиотека представляет собой совокупность программного кода, предназначенного для решения определенных задач. Этот код может содержать функции, классы, процедуры или другие компоненты, которые разработчики могут повторно использовать в своих программных проектах. Библиотеки упрощают разработку, так как они предоставляют готовые решения для типовых задач.

2. **Приоритетная очередь:**
   Приоритетная очередь (англ. priority queue) — это абстрактная структура данных наподобие стека или очереди, где у каждого элемента есть приоритет. Элемент с более высоким приоритетом находится перед элементом с более низким приоритетом.

3. **Двоичная куча (Binary Heap):**
   Двоичная куча представляет собой вид двоичного дерева, которое соответствует следующим трем условиям:
   - **Сортировка значений:** Значение в каждой вершине не меньше, чем значения её потомков. В случае мин-кучи, значение в каждой вершине не больше значений её потомков, в макс-куче — не меньше.
   - **Балансировка глубины:** Разница в глубине листьев (расстояние от корня до листа) не превышает 1 слой. Это обеспечивает сбалансированность дерева и эффективное использование памяти.
   - **Заполнение слоев слева направо:** Последний слой дерева заполняется слева направо, без пропусков. Это обеспечивает эффективное хранение данных в виде массива.

4. **Операции вставки и извлечения:**
   - **Вставка (insert):** Операция добавления нового элемента в структуру данных. В контексте приоритетной очереди, элемент вставляется с учетом его приоритета.
   - **Извлечение (extract):** Операция удаления и возврата элемента с наивысшим приоритетом из структуры данных.

5. **Методы поддержки структуры данных:**
   - **Метод `up(i)`:** Поднимает элемент вверх по дереву, обеспечивая корректность структуры данных после вставки.
   - **Метод `down(i)`:** Спускает элемент вниз по дереву, обеспечивая корректность структуры данных после извлечения.

6. **Исключение `std::out_of_range`:**
   Исключение, используемое в C++, чтобы сигнализировать о выходе индекса за пределы допустимого диапазона. В данном контексте, используется для обработки попыток извлечения из пустой приоритетной очереди.

7. **Тестирование с использованием Google Test:**
   Google Test — это фреймворк для написания тестов в языке программирования C++. Тестирование с его использованием обеспечивает автоматизацию проверок и обеспечивает надежность кода.

## <p align="center">Описание используемых алгоритмов:</p>
1. **Бинарная куча (Heap):**
В своей библиотеке я реализовывал бинарную (двоичную) кучу через `std::vector`. Где n-ому элементу, соответствовали элементы 2n+1 и 2n+2.

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/binaryheap.png" alt="Двоичная куча через вектор">
</p>

2. **Метод вставки (insert):**
Отвечает за вставку нового элемента в приоритетную очередь. Этот метод добавляет элемент в конец вектора и затем вызывает метод up, который поднимает элемент вверх по дереву для обеспечения соблюдения условий бинарной кучи.
    - **Вспомогательный метод up:**
    Отвечает за подъем элемента вверх по дереву для восстановления условий бинарной кучи после вставки. Этот метод выполняет цикл, сравнивая значение текущего элемента с его родителем и меняя их местами при необходимости до тех пор, пока элемент не достигнет правильной позиции.

```cpp
void PriorityQueue::insert(int value) {
	a.push_back(value);
	up(a.size() - 1);
}

void PriorityQueue::up(int i) {
	while (a[i] > a[(i - 1) / 2] && i != 0) {
		swap(a[(i - 1) / 2], a[i]);
		i = (i - 1) / 2;
	}
}
```

3. **Метод извлечения (extract):**
Отвечает за извлечение элемента с наивысшим приоритетом из приоритетной очереди. Этот метод извлекает значение из корня, заменяет корень последним элементом вектора, а затем вызывает метод down, который опускает новый корень вниз по дереву для восстановления условий бинарной кучи. Также учитыется случай, когда происходит попытка извлечения из пустой очереди, для этого случая создано исключение `std::out_of_range` 
    - **Вспомогательный метод down:**
    Отвечает за опускание элемента вниз по дереву для восстановления условий бинарной кучи после извлечения. Этот метод выполняет цикл, сравнивая значение текущего элемента с его потомками и меняя его место с наибольшим из потомков, если это необходимо, до тех пор, пока элемент не достигнет правильной позиции.

```cpp
int PriorityQueue::extract() {
	if (isEmpty()) {
		throw out_of_range("Priority queue is empty");
	}

	int value = a[0];
	a[0] = a[a.size() - 1];
	a.pop_back();
	down(0);
	return value;
}

void PriorityQueue::down(int i) {
	while (2 * i + 1 < a.size()) {
		int maxChild = 2 * i + 1;
		if (maxChild + 1 < a.size() && a[maxChild] < a[maxChild + 1])
			maxChild++;
		if (a[i] >= a[maxChild])
			break;
		swap(a[maxChild],a[i]);
		i = maxChild;
	}
}
```
   
4. **Метод проверки пустой очереди (isEmpty):**
Проверяет, пуста ли приоритетная очередь. Возвращает true, если вектор a пуст, и false в противном случае.

```cpp
bool PriorityQueue::isEmpty() const {
	return a.empty();
}
```

5. **Алгоритм работы очереди с приоритетом:**

    1. **Инициализация:**
       - Создание экземпляра класса `PriorityQueue`.
       - Внутренний вектор `a` используется для хранения элементов в виде бинарной кучи.
    
    2. **Вставка элемента:**
       - Новый элемент добавляется в конец вектора.
       - Вызывается метод `up` для восстановления условий бинарной кучи.
    
    3. **Извлечение элемента:**
       - Проверка наличия элементов в куче.
       - Извлечение значения из корня (с наивысшим приоритетом).
       - Замена корня последним элементом вектора.
       - Вызов метода `down` для восстановления условий бинарной кучи.
    
    4. **Подъем элемента вверх:**
       - Пока текущий элемент больше родителя и не достигнут корень:
         - Меняем местами текущий элемент и его родителя.
         - Обновляем индекс текущего элемента.
    
    5. **Опускание элемента вниз:**
       - Пока есть хотя бы один потомок текущего элемента:
         - Выбираем максимального из потомков.
         - Если текущий элемент меньше выбранного потомка, меняем их местами.
         - Обновляем индекс текущего элемента.
    
    6. **Проверка наличия элементов:**
       - Проверка, пуста ли куча, основываясь на пустоте вектора `a`.

## <p align="center">Результаты тестирования:</p>
Тестирование проводилось с помощью фреймворка Google test. Система тестов состоит из 5 тестов: 2 базовых теста на вставку и извлечение, тест на вставку и извлечение с одинаковыми элементами, тест на вставку и извлечение с отрицательными элементами, тест на извлечение из пустой очереди. Все тесты прошли успешно.

<p align="center">
  <img src="https://github.com/IRomanchuk06/PriorityQueue/blob/main/TestPriorityQueue.png?raw=true" alt="Тесты библиотеки">
</p>

**Система тестов:**

```cpp
#include "pch.h"
#include <gtest/gtest.h>
#include "../priorituQueue/priorityQueue.h"
using namespace std;

//базовый тест на вставку и извлечение
TEST(PriorityQueueTest, InsertAndExtract1) {
    PriorityQueue pq;

    EXPECT_TRUE(pq.isEmpty());

    pq.insert(10);
    pq.insert(5);
    pq.insert(20);

    EXPECT_FALSE(pq.isEmpty());

    EXPECT_EQ(pq.extract(), 20);
    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), 5);

    EXPECT_TRUE(pq.isEmpty());
}

//базовый тест на вставку и извлечение
TEST(PriorityQueueTest, InsertAndExtract2) {
    PriorityQueue pq;

    pq.insert(10);
    pq.insert(5);
    pq.insert(20);
    pq.insert(15);
    pq.insert(25);

    EXPECT_EQ(pq.extract(), 25);
    EXPECT_EQ(pq.extract(), 20);
    EXPECT_EQ(pq.extract(), 15);
    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), 5);

    EXPECT_TRUE(pq.isEmpty());
}

//тест на вставку и извлечение с одинаковыми элементами
TEST(PriorityQueueTest, InsertAndExtractWithDuplicates) {
    PriorityQueue pq;
    pq.insert(10);
    pq.insert(5);
    pq.insert(10);
    pq.insert(8);

    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), 8);
    EXPECT_EQ(pq.extract(), 5);
    EXPECT_TRUE(pq.isEmpty());
}

//тест на извлечение из пустой очереди
TEST(PriorityQueueTest, ExtractFromEmptyQueue) {
    PriorityQueue pq;

    EXPECT_THROW(pq.extract(), std::out_of_range);
}

//тест на вставку и извлечение с отрицательными элементами
TEST(PriorityQueueTest, InsertWithNegativeNumbers) {
    PriorityQueue pq;
    
    pq.insert(10);
    pq.insert(-5);
    pq.insert(25);
    pq.insert(-10);
    pq.insert(-2);

    EXPECT_EQ(pq.extract(), 25);
    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), -2);
    EXPECT_EQ(pq.extract(), -5);
    EXPECT_EQ(pq.extract(), -10);
    EXPECT_TRUE(pq.isEmpty());
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```
## <p align="center">Вывод:</p>

В результате выполнения лабораторной работы были углублены знания в области принципов работы приоритетных очередей, основанных на max-heap. Освоена методика "подъема" и "опускания" элементов, что позволило эффективно управлять структурой данных с максимальным элементом в корне. Также приобретены навыки применения стандартных контейнеров C++, в частности, использование `std::vector` для представления бинарной кучи.

Реализована библиотека для приоритетной очереди, включающая грамотные операции вставки, извлечения и проверки на пустоту, обеспечив эффективность и корректность работы структуры данных. Написаны тесты с использованием Google Test, что позволило убедиться в надежности и правильности реализации.

Лабораторная работа предоставила глубокое понимание проектирования и реализации приоритетных очередей. Опыт работы с тестовыми фреймворками, в данном случае с Google Test, был ценен для проверки функциональности кода и обеспечения его корректности. Использование стандартных исключений для обработки ошибок стало неотъемлемой частью опыта в создании надежных программных решений.

## <p align="center">Используемые источники:</p>
1. https://neerc.ifmo.ru/wiki/index.php?title=Приоритетные_очереди#.D0.A0.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B8 (определения понятий).
2. https://www.youtube.com/watch?v=5mD-rhaYF4U&t=209s (создание библиотеки).
3. https://www.youtube.com/watch?v=o1ZDXf7NGN4&t=868s (реализация алгоритмов на C++).
4. https://github.com/google/googletest (про Google test: установка, использование).
5. https://chat.openai.com (помощь в освоении материала)
