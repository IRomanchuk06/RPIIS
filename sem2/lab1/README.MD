# Лабораторная работа №1 

## Задача:
Реализовать AVL-дерево как динамическую структуру данных. Вставка. Удаление. Поиск. Поиск минимума, максимума, ближайшего большего и ближайшего меньшего.
## Цель:
Исследовать свойства структур данных и разработать
библиотеку алгоритмов обработки структур данных.

## Список ключевых понятий:

`АВЛ-дерево`- это прежде всего двоичное дерево поиска, ключи которого удовлетворяют стандартному свойству: ключ любого узла дерева не меньше любого ключа в левом поддереве данного узла и не больше любого ключа в правом поддереве этого узла. 

Особенностью АВЛ-дерева является то, что оно является сбалансированным в следующем смысле: для любого узла дерева высота его правого поддерева отличается от высоты левого поддерева не более чем на единицу. 

**Преимущества такой организации данных**
Балансировка: АВЛ-деревья являются сбалансированными, что означает, что высота поддеревьев отличается не более чем на 1. Это обеспечивает эффективные операции вставки, удаления и поиска, так как время выполнения этих операций остается логарифмическим.

Эффективность: Благодаря балансировке АВЛ-деревья обеспечивают быстрый доступ к данным. Время выполнения операций вставки, удаления и поиска в АВЛ-деревьях составляет O(log n), где n - количество элементов в дереве.

Гарантированная сложность: Благодаря балансировке АВЛ-деревья гарантируют сложность операций поиска, вставки и удаления, что делает их предпочтительным выбором в ситуациях, где необходимо гарантировать эффективность операций.

Подходят для поиска: АВЛ-деревья хорошо подходят для реализации структур данных, требующих эффективного поиска, таких как словари, множества и базы данных.

**СВОЙСТВА:**
Балансировка: Высота левого и правого поддеревьев каждого узла отличается не более чем на 1. Это свойство гарантирует, что дерево остается сбалансированным после каждой операции вставки или удаления.

Гарантированная высота: Для АВЛ-дерева высота любого поддерева с корнем в узле i равна |h(левого поддерева i) - h(правого поддерева i)|, где h(x) - высота поддерева с корнем в узле x. Таким образом, высота любого поддерева в АВЛ-дереве ограничена логарифмически.

Уникальность ключей: Все ключи в дереве должны быть уникальными, то есть не могут существовать два узла с одинаковым ключом.

Структура двоичного дерева поиска: Для каждого узла x все ключи в левом поддереве меньше ключа x, а все ключи в правом поддереве больше ключа x. Это свойство обеспечивает эффективность операций поиска.

Рекурсивная структура: АВЛ-дерево является рекурсивной структурой данных, так как каждое поддерево также является АВЛ-деревом.

Эффективность операций: Благодаря сбалансированности и гарантированной высоте, операции вставки, удаления и поиска в АВЛ-дереве имеют временную сложность O(log n), где n - количество узлов в дереве.
## Алгоритм 

Для выполнения поиска в АВЛ-дереве необходимо пройти через узлы дерева, сравнивая ключ, который вы ищете, с ключами узлов. Алгоритм поиска в АВЛ-дереве обычно выполняется рекурсивно или итеративно и состоит из следующих шагов:

Начните с корня дерева.
Если ключ, который вы ищете, равен ключу текущего узла, то поиск завершен, и вы нашли нужный узел.
Если ключ, который вы ищете, меньше ключа текущего узла, перейдите к левому поддереву и повторите шаги с 1 по 3 для этого поддерева.
Если ключ, который вы ищете, больше ключа текущего узла, перейдите к правому поддереву и повторите шаги с 1 по 3 для этого поддерева.
Продолжайте рекурсивно или итеративно повторять эти шаги, пока не найдете узел с нужным ключом или пока не дойдете до листового узла, который указывает на то, что ключ отсутствует в дереве.
Этот алгоритм использует свойства АВЛ-дерева (структура двоичного дерева поиска и балансировка) для эффективного поиска нужного ключа.


## Функции :

### Задание дерева 
Эта структура предоставляет основу для построения АВЛ-дерева, которое обеспечивает эффективные операции вставки, удаления и поиска благодаря сбалансированной структуре.
``` c++
struct node 
{
	int info; // значения
	node* left; // указатель на левое поддерево
	node* right; // указатель на правое поддерево
	int balance; // баланс: высота правого поддерева минус высота левого поддерева
};
```

### Функция вставка
Эта функция добавляет новый узел в дерево поиска. Она рекурсивно определяет место для вставки нового узла, учитывая порядок ключей, и затем балансирует дерево, если это необходимо.
``` c++
void insert(node* (&root), int d) // добавление узла в дерево поиска
{
	if (root == NULL) // нашли пустой указатель(пустое место)
	{ // создаём новый узел дерева на найденном месте
		root = new node;
		root->info = d;
		root->balance = 0;
		root->left = NULL;
		root->right = NULL;
	}
	else // если текущий узел не пусто, то...
	{
		if (d > root->info) // идём в правое поддерево
		{
			insert(root->right, d); // добавляем узел в правое поддерево
			if (Height(root->right) - Height(root->left) > 1) // если баланс АВЛ-дерева нарушен, то...
			{
				if (Height(root->right->right) < Height(root->right->left)) // а если были еще проблемы в поддеревьях у правого поддерева 
					TurnRight(root->right); // то предварительно поворачиваем правое поддерево
				TurnLeft(root); // поворот дерева влево
			}
		}
		else
			if (d < root->info) // идем в левое поддерево
			{
				insert(root->left, d); // добавляем узел в левое поддерево
				if (Height(root->left) - Height(root->right) > 1) //если баланс АВЛ - дерева нарушен, то...
				{
					if (Height(root->left->left) < Height(root->left->right)) //а если были еще проблемы в поддеревьях у левого поддерева 
						TurnLeft(root->left); // то предварительно поворачиваем левое  поддерево
					TurnRight(root); // поворот дерева вправо
				}
			}
		SetBalance(root); // пересчитываем значение баланса
	}
}
```

### Функция поиск
Эта функция выполняет поиск узла с заданным ключом в дереве. Она рекурсивно сравнивает ключи узлов с заданным значением и возвращает найденный узел или NULL, если узел не найден.
``` c++
node* search(node* root, int value) // поиск нужной ячейки
{
	node* current = root;
	while (current != nullptr && current->info != value) {
		if (value < current->info) {
			current = current->left;
		}
		else {
			current = current->right;
		}
	}
	return current;
}
```

### Функция удаления
Данная функция удаляет узел с заданным ключом из дерева. Она рекурсивно находит узел для удаления, сохраняет баланс дерева и выполняет операции удаления.
``` c++
node* deleteNode(node* root, int key) // удаление узла дерева 
{
	if (root == NULL) {
		return root;
	}
	if (key < root->info) {
		root->left = deleteNode(root->left, key);
	}
	else if (key > root->info) {
		root->right = deleteNode(root->right, key);
	}
	else {
		if ((root->left == NULL) || (root->right == NULL)) {
			node* temp = root->left ? root->left : root->right;
			if (temp == NULL) {
				temp = root;
				root = NULL;
			}
			else {
				*root = *temp;
			}
			delete temp;
		}
		else {
			node* temp = minValueNode(root->right);
			root->info = temp->info;
			root->right = deleteNode(root->right, temp->info);
		}
	}
	if (root == NULL) {
		return root;
	}
	SetBalance(root);
	if (root->balance > 1) {
		if (root->right->balance < 0) {
			TurnRight(root->right);
		}
		TurnLeft(root);
	}
	else if (root->balance < -1) {
		if (root->left->balance > 0) {
			TurnLeft(root->left);
		}
		TurnRight(root);
	}
	return root;
}
```

### Функция поиска минимума(максимума)
Эта функция находит узел с минимальным(максимальным) ключом в дереве путем рекурсивного спуска влево от корня до листового узла.
``` c++
node* minValueNode(node* root)  // поиск минимума
{
	node* current = root;
	while (current->left != NULL) {
		current = current->left;
	}
	return current;
}
node* maxValueNode(node* root) // поиск максимума
{
	node* current = root;
	while (current->right != NULL) {
		current = current->right;
	}
	return current;
}
```

### Функция поиска ближайшего большего(меньшего)
Данная функция находит узел с ключом, ближайшим к указанному значению, но не меньшим(большим). Она рекурсивно обходит дерево, чтобы найти ближайший больший(меньший) ключ.
```c++
node* findClosestMin(node* root, int value) // поиск ближайшего меньшего
{
	node* closest = nullptr;
	node* current = root;

	while (current != nullptr) {
		if (current->info < value) {
			closest = current;
			current = current->right;
		}
		else {
			current = current->left;
		}
	}

	return closest;
}

node* findClosestMax(node* root, int value) // поиск ближайшего большего
{
	node* closest = nullptr;
	node* current = root;

	while (current != nullptr) {
		if (current->info > value) {
			closest = current;
			current = current->left;
		}
		else {
			current = current->right;
		}
	}

	return closest;
} 
```

### Функция проверки на баланс поддеревьев
Данная функция вычисляет баланс текущего узла, вычитая высоты его правого и левого поддеревьев. Результат сохраняется в поле balance узла для использования при балансировке дерева.
``` c++
void SetBalance(node* (&root)) //нахождение значение баланса для текущего узла
{
	if (root != NULL)
		root->balance = Height(root->right) - Height(root->left);
}
```

### Функция поворота вправо(влево) в случае отсутствия баланса
Эта функция выполняет левый(правый) поворот дерева. При этом происходит переназначение указателей, чтобы сбалансировать дерево.
``` c++
void TurnLeft(node* (&root)) // левый поворот дерева
{
	node* rightSubtree, * rightSubtreeLeftSubtree;
	rightSubtree = root->right;
	rightSubtreeLeftSubtree = rightSubtree->left;

	rightSubtree->left = root;
	root->right = rightSubtreeLeftSubtree;
	root = rightSubtree;
	SetBalance(root->left);
	SetBalance(root);
}

void TurnRight(node* (&root)) //правый поворот АВЛ-дерева
{
	node* leftSubtree, * leftSubtreeRightSubtree;
	leftSubtree = root->left;
	leftSubtreeRightSubtree = leftSubtree->right;

	leftSubtree->right = root;
	root->left = leftSubtreeRightSubtree;
	root = leftSubtree;
	SetBalance(root->right);
	SetBalance(root);
} 
```

### Функция вывода дерева в консоль
анная функция выводит значения узлов дерева по уровням, начиная с корня и последовательно двигаясь на следующий уровень.
``` c++
void print_n(const node* p, int n, int level, int prob) // печать n-ого уровня дерева
{
	if (p)
	{
		if (level == n)
		{
			for (int i = 0; i <= prob; i++)
				cout << " ";
			cout << p->info;
		}
		else
		{
			print_n(p->left, n, level + 1, prob);
			print_n(p->right, n, level + 1, prob);
		}
	}
}

void print(node* p) // распечатка дерева по уровням
{
	int h = Height(p);
	int prob = 3;
	if (p)
	{
		for (int i = 0; i <= h; i++) // задаём номера уровней
		{
			print_n(p, i, 0, prob * (h - i)); // вызывается функция печати n-ого уровня дерева
			cout << endl;
		}
	}
}
```

## Пример выполнения(представлен в консоли):
![Image alt](https://github.com/iis-32170x/RPIIS/blob/Кадиков_П/sem2/lab1/images/resultsOfLaba.png)					
Все работает как следует.

## Вывод
Реализовал структуру данных АВЛ-дерево.

## Источники
https://www.youtube.com/watch?v=0BUX_PotA4c&t=256s

https://www.youtube.com/watch?v=IL7zbyBD_w4

https://www.youtube.com/watch?v=WoNeKNXC3aU&t=3s
