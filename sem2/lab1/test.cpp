#include "rbtree.h"
#include <cassert>

int main() {

	setlocale(LC_ALL, "russian");

	Node* root = new Node{ 20, nullptr, nullptr, nullptr, 0 };

	printInorder(root);

	/*1й тест*/ 
	insertNode(root, 25);	 //В случае вставки первой некорневой вершины, она всегда остаётся красной
	assert(find(root, 25)->IsRed);

	cout << "Первый тест пройден успешно.\n";

	/*2й тест*/
	insertNode(root, 17);
	insertNode(root, 23); //В случае вставки таких вершин в таком порядке, вершина 25 перекрасится в чёрный
	insertNode(root, 28);
	assert(!find(root, 25)->IsRed);

	cout << "Второй тест пройден успешно.\n";

	/*3й тест*/
	insertNode(root, 12);
	insertNode(root, 8); //После вставки вершин с ключами 12 и 8, левым потомком главного узла должен стать узел с ключом 12
	assert(root ->left-> key == 12);

	cout << "Третий тест пройден успешно.\n";

	/*4й тест*/
	insertNode(root, 19); //После вставки узла с ключом 19, левый потомок от главного узла должен перекраситься в красный цвет
	assert(root->left->IsRed = 1);

	cout << "Четвёртый тест пройден успешно.\n";

	/*5й тест*/
	assert(find_max(root) == 28 ); //Поиск максимального элемента в дереве, в нашем случае это - 28
	cout << "Пятый тест пройден успешно.\n";

	/*6й тест*/
	assert(find_min(root) == 8); //Поиск минимального элемента в дереве, в нашем случае это - 8
	cout << "Шестой тест пройден успешно.\n";

	/*7й тест*/
	assert(find_nearest_min(root, 20) == 19); //Поиск ближайшего меньшего элемента для вершины 20, в нашем этим элементом будет 19
	cout << "Седьмой тест пройден успешно.\n";

	/*8й тест*/
	assert(find_nearest_max(root, 20) == 23); //Поиск ближайшего большего элемента для вершины 20, в нашем этим элементом будет 23
	cout << "Восьмой тест пройден успешно.\n";

	/*9й тест*/
	assert(find(root, 40) == nullptr); //Поиск несуществующей вершины в дереве, ожидая получить nullptr
	cout << "Девятый тест пройден успешно.\n";

	return 0;
}