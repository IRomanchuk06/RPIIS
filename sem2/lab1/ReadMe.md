# <p align="center">Лабораторная работа №1</p>

Вариант 1. N-арное дерево. Вставка узла в дерево. Удаление узла из дерева..

## <p align="center">Цели лабораторной работы:</p>
1. Разработать библиотеку для работы с  N-арным деревом на выбранном императивном языке программирования (например, C++, Java, Python).
2. Создать тестовую программу для демонстрации функциональности разработанной библиотеки.
3. Разработать систему тестов для проверки работоспособности и корректности библиотеки, учитывая требования полноты, адекватности и непротиворечивости.
4. Обеспечить обработку некорректных данных, предусмотрев корректное завершение программы при возникновении ошибок.
5. Составить отчет по выполнению лабораторной работы.
   
## <p align="center">Задачи лабораторной работы:</p>
1. Изучить спецификацию задачи по работе с n-арным деревом
2. Выбрать язык программирования для реализации библиотеки (например, C++, Java, Python) в соответствии с индивидуальным заданием.
3. Разработать и реализовать библиотеку для работы с n-арным деревом, включая операции вставки и удаления узлов.
4. Написать тестовую программу, которая демонстрирует основные сценарии использования библиотеки.
5. Разработать систему тестов, включающую тест-кейсы для проверки различных аспектов работы библиотеки, включая корректность, производительность и обработку ошибок.
6. Провести тестирование разработанной библиотеки, убедившись в ее правильной работе на различных входных данных.
7. Составить подробный отчет, включая описание решения задачи, архитектуры библиотеки, результаты тестирования и выводы.

## <p align="center">Список используемых понятий и алгоритмов:</p>
1. **Библиотека программного обеспечения (Библиотека кода):**
В программировании библиотека представляет собой совокупность программного кода, предназначенного для решения определенных задач. Этот код может содержать функции, классы, процедуры или другие компоненты, которые разработчики могут повторно использовать в своих программных проектах. Библиотеки упрощают разработку, так как они предоставляют готовые решения для типовых задач.

2. **N-арное дерево**
   N-арное дерево (неориентированное) — это дерево (обычное, неориентированное), в котором степени вершин не превосходят N+1.
   N-арное дерево (ориентированное) — это ориентированное дерево, в котором исходящие степени вершин (число исходящих рёбер) не превосходят N.
  
3. **Операции вставки и извлечения:**
   - **Вставка узла(addchild)** Функция добавления нового узла в дерево(в параметры принимает дерево
   - **Удаление узла(deletenode):** Функция удаления узла из дерева.
   - 1) Если введенный на удаление узел не найден,то выведет " Node with data __ not found".
     2) Если введенный узел есть корень, то программа завершит работу.
     3) если узел является крайним, то он просто удалится из дерева. 4) если у удаленного узла уровна n есть дети уровня (n-1), то они продвинутся на уровень n.
4. **Ввод и вывод дерева**
   -**Ввод дерева с клавиатуры (BuildTreeFromInputt())** - Функция, позволяющая вводить пользователю свое дерево с клавиатуры. Последовательный ввод узлов выведет их цепочку. Чтобы задать несколько детей одному родителю нужно после каждого  введенного узла ввести (-1).
   
   -**Вставка узла(addchild)** - Функция, позволяющая вставить какой-либо еще узел в дерево.
   ОТЧЕТ В ДОРАБОТКЕ))




## <p align="center">Описание используемых алгоритмов:</p>
1) Структура treenode: объявляем структуру дерева, содержащую информацию о узлах(data) и вектор указателей на детей(`vector <treenode*>`) и  указатель родителей(`treenode* parent`)
 ```cpp
struct treenode {
    int data;
    vector<treenode*> children;
    treenode* parent;
};
```
2) Функция getnewnode: Выделяем память под новые узлы дерева и присваиваем им значение(data)
```cpp
treenode* getnewnode(int data) {
    treenode* newnode = new treenode();
    newnode->data = data;
    return newnode;
}
```
3) Функция addchild:  Получаем новый узел(`newnode`) с помощью `getnewnode` и устанавливаем указатель родительского узла на новый узел
```cpp
void addchild(treenode* node, int data) {
    treenode* newnode = getnewnode(data);
    newnode->parent = node;
    node->children.push_back(newnode);
}
```
4) Функция вывода дерева в консоль printTree: Выводим структуру дерева с помощью рекурсии
```cpp
void printTree(treenode* root, int depth = 0) {
    if (root == nullptr)
        return;

    // Print the current node
    for (int i = 0; i < depth; i++)
        cout << "  ";
    cout << "|--" << root->data << endl;

    // Print each child
    for (treenode* child : root->children)
        printTree(child, depth + 1);
}
```
5) Функция поиска узла findnode: Ищет узел в дереве с указанными данными(`data`),используя рекурсию, и возвращает указатель на него.
 ```cpp
treenode* findnode(treenode* node, int a) {
    if (node == nullptr)
        return nullptr;

    if (node->data == a)
        return node;

    treenode* foundnode = nullptr;
    for (treenode* child : node->children) {
        foundnode = findnode(child, a);
        if (foundnode != nullptr)
            break;
    }

    return foundnode;
}
```
6)Функция освобождения память deleteTree: Рекурсивно удаляет все дерево.
```cpp
void deleteTree(treenode* root) {
    if (root == nullptr)
        return;

    for (treenode* child : root->children) {
        deleteTree(child);
    }

    delete root;
}
```


## <p align="center">Используемые источники:</p>
1) Помощь в создании библиотеки https://www.youtube.com/watch?v=ZwaE-JM7smI.
2) Помощь в реализации N-ary tree 1.https://www.youtube.com/watch?v=bADJ2IjFsWs 2. https://youtu.be/6j4Nz_ZLz9w?si=8LDzmKlT6VuEUftl
3) Помощь в освоении материала https://chat.openai.com
