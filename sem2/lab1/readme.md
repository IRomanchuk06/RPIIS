# Лабораторная работа №1 - Дерево сумм
___
## Постановка задачи:
***Реализовать алгоритм дерева сумм, который должен включать:***
- Изменение элементов дерева на определённом отрезке на какое-то значение.
- Подсчёт суммы элементов на отрезке массива.
- Вывод дерева.
___
## Определение понятий: 

- ***Дерево сумм*** -  структура данных, представляющая собой бинарное дерево, в котором каждый узел содержит числовое значение. Значение каждого узла равно сумме значений всех узлов в его левом и правом поддеревьях.
___
## Алгоритм

### Построение дерева:
Пусть дан следующий массив: [3, 6, 9, 2, 2, 1]. Корень дерева – сумма всех элементов [0..5] (23). Делим элементы пополам и составляем сумму детей корня – [0..2] (18) и [3..5] (5) соответственно. Далее каждую из этих сумм делим опять пополам – [0..1] (9), [2..2] (9), [3..4] (4), [5..5] (1). Те суммы, у которых левая граница не равна правой, делим ещё раз, получаем соответствующие элементы массива. Вот, как это выглядит:

![image](https://github.com/iis-32170x/RPIIS/assets/144333910/c8781ac7-56b1-4d90-8546-e42daaab4a6e)

у каждого элемента есть своё отдельное место, и никакая пара элементов не пересекается, поэтому все элементы мы можем записать в массив: рассматриваемая вершина имеет индекс v, а его потомки – индексы 2 * v + 1 и 2 * v + 2 для левого и правого потомка соответственно. Расход памяти дерева отрезков будет составлять 4n

Пусть у нас есть массив tree[4 * n] и есть вершина tree[v], которая должна хранить сумму диапазона [L..R]. Если L == R, то очевидно, что tree[v] = a[L]. В противном случае мы не можем сразу сказать, чему равна сумма. Для этого нам нужно передать запрос суммы потомкам, а затем записать в tree[v] результат сложения сумм потомков. Пусть M = середина диапазона [L..R], тогда левый потомокt[2 * v + 1]соответствует диапазону [L..M], а правый t[2 * v + 2] – [M..R]
### Подсчёт суммы на отрезке:
Пусть дан массив a, q запросов с данными l, r. Необходимо для каждого запроса найти сумму на отрезке [l..r]. Поскольку в данной реализации мы всё индексируем с нуля, l мы рассматриваем включительно (предварительно уменьшив l на единицу), а r – не включительно.

Утверждается, что в рекурсивной функции подсчёта суммы может быть обработано три ситуации.

[l..r] не пересекается с [L..R] → возвращаем нейтральное значение для суммы;
[L..R] ∈ [l..r] → возвращаем значение текущей вершины;
Третий случай, когда ни один из предыдущих не работает. Нужно получить суммы от потомков текущей вершины. Запрос аналогичен с запросом в функции build_sum_tree. Мы должны получить два слагаемых от двух потомков соответственно и вернуть их сумму. При этом стоит заметить, что рекурсия не будет разрастаться: каждый запрос будет обрабатываться за 2*logN, что асимптотически верно O(logN), поскольку одна из двух вызываемых рекурсий всегда будет возвращать либо 0, либо tree[v]. 
### Изменения на отрезке:
Имеем всё тот же массив a, q запросов, дерево суммы tree. Необходимо создать изменение элементов (прибавить x) на запрашиваемом отрезке [l..r].

Создадим вспомогательный массив tree_add[2 * SIZE]. Если в tree[v] хранилось значение суммы на отрезке [L..R], то в tree_add[v]будет хранится значение, добавляемое всем элементам на отрезке [L..R]. Тогда нам придётся переписать некоторые методы, поскольку сумма на отрезке будет вычисляться по другой формуле, а именно:

tree[v] + tree_add[v] * (R - L).

Но есть ещё одна проблема: когда запрос на изменение отрезка приходит в определённый отрезок [L..R], он может не дойти ниже (см. иллюстрацию в начале статьи). Представьте, что дан запрос на изменение отрезка [3..5]. Тогда, исходя из нашей логики, отрезок [3..5] может быть "проинформирован" о том, что его сумма поменялась, а отрезки [3..4], [5..5] и прочие – нет.

Эта проблема решается "ленивым проталкиванием изменений" (lazy propogation). Вкратце опишем алгоритм:

Если tree_add[v] != 0, то пересчитываем tree[v];
Передаём tree_add[v] потомкам, если таковые имеются;
Меняем значение tree_add[v] на нейтральное. В случае суммы это ноль.
___
## Скриншоты выполения задания:

![Снимок экрана 2024-06-08 125425](https://github.com/iis-32170x/RPIIS/assets/144333910/f5fd8b71-44d5-41d9-8314-ce051c22fc57)
![Снимок экрана 2024-06-08 125450](https://github.com/iis-32170x/RPIIS/assets/144333910/7c4ed801-e40e-4c6d-afa2-5695483765ff)
![Снимок экрана 2024-06-08 125509](https://github.com/iis-32170x/RPIIS/assets/144333910/2f535852-55ae-4903-b2b1-60cf15db0da3)
![Снимок экрана 2024-06-08 125534](https://github.com/iis-32170x/RPIIS/assets/144333910/1af75a1c-7fae-4de9-89a4-5dd151ae6a2c)
![Снимок экрана 2024-06-08 125555](https://github.com/iis-32170x/RPIIS/assets/144333910/7fd48573-e667-48e3-b973-be072e1b6b6e)
___
## Вывод
 Реализовал ***дерево сумм*** и выполнил все поставление задачи, указанные выше
___
## Источник:
https://proglib.io/p/algoritmy-i-struktury-dannyh-na-c-derevya-otrezkov-2019-10-11?ysclid=lx5ue40h77831229278
