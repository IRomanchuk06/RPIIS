# *Лабораторная работа №1*
## *Вариант 9*
***
### Задача:
Разработать библиотеку для работы с AVL-дерево. Вставка. Удаление. Поиск. Поиск минимума, максимума, ближайшего большего и ближайшего меньшего.
### Цель:
1. Разработать библиотеку для работы с одномерным массивом. (например, C++, Java, Python).
2. Создать тестовую программу для демонстрации функциональности разработанной библиотеки.
3. Разработать систему тестов для проверки работоспособности и корректности библиотеки, учитывая требования полноты, адекватности и непротиворечивости.
4. Обеспечить обработку некорректных данных, предусмотрев корректное завершение программы при возникновении ошибок.
5. Составить отчет по выполнению лабораторной работы.
### Ключевые понятия: 
___АВЛ-дерево___ — сбалансированное по высоте двоичное дерево поиска: для каждой его вершины высота её двух поддеревьев различается не более чем на 1.
Относительно АВЛ-дерева балансировкой вершины называется операция, которая в случае разницы высот левого и правого поддеревьев = 2, изменяет связи предок-потомок в поддереве данной вершины так, что разница становится <= 1, иначе ничего не меняет. Указанный результат получается вращениями поддерева данной вершины. 
АВЛ — аббревиатура, образованная первыми буквами создателей (советских учёных) Адельсон-Вельского Георгия Максимовича и Ландиса Евгения Михайловича.

Относительно АВЛ-дерева ___балансировкой___ вершины называется операция, которая в случае разницы высот левого и правого поддеревьев = 2, изменяет связи предок-потомок в поддереве данной вершины так, что разница становится <= 1, иначе ничего не меняет. Указанный результат получается вращениями поддерева данной вершины.

___Фактор баланса___ — разница в высоте между правым и левым под-деревом.

### Функции и алгоритмы программы
   ___Создание нового узла дерева с заданным ключом и инициализация его поля:___
1. Функция createNode выделяет память для нового узла с помощью оператора new Node()
2. Инициализирует поля нового узла: key устанавливается равным заданному ключу key, left и right устанавливаются в nullptr, так как новый узел не имеет дочерних узлов, и height устанавливается равным 1, так как новый узел находится на самом нижнем уровне дерева.
3. Возвращает указатель на новый узел, который может быть использован для добавления в AVL-дерево.
```c++
Node* createNode(int key) {
    Node* newNode = new Node;
    newNode->key = key;
    newNode->left = nullptr;
    newNode->right = nullptr;
    newNode->height = 1;
    return newNode;
}
```
***
 ___Возвращает высоту узла node. Если узел node равен nullptr, то высота считается равной 0.___
1. Проверить, является ли указатель node равным nullptr. Если это так, то это означает, что текущий узел пуст, и его высота равна 0. В этом случае функция возвращает 0.
2. Если node не является нулевым указателем, то функция возвращает значение поля height узла node. Поле height содержит текущую высоту поддерева с корнем в узле node.
```c++
int getHeight(Node* node) {
    if (node == nullptr) {
        return 0;
    }
    return node->height;
}
```
***
 ___Вычисляет баланс фактор узла node, который определяется как разность высоты его левого поддерева и высоты его правого поддерева.___
 1. Проверить, является ли указатель node равным nullptr. Если это так, то это означает, что текущий узел пуст, и его баланс-фактор равен 0. В этом случае функция возвращает 0.
2. Если node не является нулевым указателем, то функция вычисляет высоту левого поддерева узла node с помощью функции getHeight(node->left) и высоту правого поддерева с помощью функции getHeight(node->right). Затем функция возвращает разницу между высотой левого поддерева и высотой правого поддерева, что и является баланс-фактором.
```c++
int getBalanceFactor(Node* node) {
    if (node == nullptr) {
        return 0;
    }
    return getHeight(node->left) - getHeight(node->right);
}
```
***
___Обновляет высоту узла node в соответствии с высотами его левого и правого поддеревьев.___
1. Вычислить высоту левого поддерева узла node с помощью функции getHeight(node->left) и сохранить результат в переменной leftHeight.
2. Вычислить высоту правого поддерева узла node с помощью функции getHeight(node->right) и сохранить результат в переменной rightHeight.
3. Обновить высоту узла node путем присвоения переменной node->height значения максимальной высоты между leftHeight и rightHeight, увеличенной на 1. То есть, node->height будет равно max(leftHeight, rightHeight) + 1.
```c++
void updateHeight(Node* node) {
    int leftHeight = getHeight(node->left);
    int rightHeight = getHeight(node->right);
    node->height = (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;
}
```
***
___Выполняет правый поворот вокруг узла node. Этот поворот сохраняет свойство AVL-дерева и поддерживает его баланс.___
1. Создать новую переменную newRoot и присвоить ей значение левого дочернего узла node (предполагается, что левый дочерний узел существует).
2. Обновить связи между узлами:
    * Правому дочернему узлу node присвоить левого дочернего узла newRoot.
    * Правому дочернему узлу newRoot присвоить node.
3. Обновить высоты узлов:
    * Вызвать функцию updateHeight для узла node, чтобы обновить его высоту.
    * Вызвать функцию updateHeight для узла newRoot, чтобы обновить его высоту.
3. Вернуть newRoot как новый корень поддерева после поворота.
```c++
Node* rotateRight(Node* node) {
    Node* newRoot = node->left;
    node->left = newRoot->right;
    newRoot->right = node;

    updateHeight(node);
    updateHeight(newRoot);

    return newRoot;
}
```
***
___Проверяет баланс узла node и, при необходимости, выполняет повороты, чтобы восстановить баланс в соответствии с правилами AVL-дерева.___
1. Обновить высоту узла node с помощью функции updateHeight(node).
2. Проверить баланс-фактор узла node с помощью функции getBalanceFactor(node):
    * Если баланс-фактор равен 2, то левое поддерево узла node имеет больший размер по сравнению с правым поддеревом. В этом случае нужно выполнить дополнительные проверки.
        * Если баланс-фактор левого поддерева node->left равен -1, то это означает, что левое поддерево имеет правый наклон. Для исправления этого, выполняется левый поворот для левого поддерева с помощью функции rotateLeft(node->left).
        * Затем выполняется правый поворот для узла node с помощью функции rotateRight(node) для окончательной балансировки.
    * Если баланс-фактор равен -2, то правое поддерево узла node имеет больший размер по сравнению с левым поддеревом. В этом случае также нужно выполнить дополнительные проверки.
        * Если баланс-фактор правого поддерева node->right равен 1, то это означает, что правое поддерево имеет левый наклон. Для исправления этого, выполняется правый поворот для правого поддерева с помощью функции rotateRight(node->right).
        * Затем выполняется левый поворот для узла node с помощью функции rotateLeft(node) для окончательной балансировки.
3. Если баланс-фактор узла node не равен 2 или -2, то это означает, что узел node уже сбалансирован и никакие дополнительные операции не требуются.
4. Возвращаем узел node, который может быть изменен или остаться неизменным после балансировки.
```c++
Node* balance(Node* node) {
    updateHeight(node);

    if (getBalanceFactor(node) == 2) {
        if (getBalanceFactor(node->left) < 0) {
            node->left = rotateLeft(node->left);
        }
        return rotateRight(node);
    }

    if (getBalanceFactor(node) == -2) {
        if (getBalanceFactor(node->right) > 0) {
            node->right = rotateRight(node->right);
        }
        return rotateLeft(node);
    }

    return node;
}
```
***
___Вставляет узел с ключом key в дерево, начиная с узла node. При необходимости выполняется балансировка дерева. Вставляет узел с ключом key в дерево, указанное указателем root. Если дерево пустое, устанавливает новый узел в качестве корня.___
1. Идет проход по пути поиска от корня дерева вниз до листового узла или до узла, у которого ключ совпадает с вставляемым ключом. Если достигнут листовой узел или найден узел с совпадающим ключом, вставка прекращается, и возвращается ссылка на этот узел без изменений.
2. Если найденный узел имеет ключ, отличный от вставляемого ключа, то происходит вставка нового узла в соответствующее место в дереве. Вставка выполняется рекурсивно для левого или правого поддерева в зависимости от отношения ключей.
3. После вставки нового узла происходит "отступление" назад по пути поиска от вставленного узла к корню. При этом в каждой вершине проверяется показатель сбалансированности. Если показатель сбалансированности равен 2 или -2, то выполняется балансировка узла.
4. Балансировка узла включает в себя проверку и выполнение необходимых поворотов (левых или правых) для восстановления баланса. После поворотов обновляются высоты узлов.
```c++
Node* insertNode(Node* node, int key) {
    if (node == nullptr) {
        return createNode(key);
    }

    if (key < node->key) {
        node->left = insertNode(node->left, key);
    }
    else if (key > node->key) {
        node->right = insertNode(node->right, key);
    }
    else {
        return node;
    }

    return balance(node);
}

void insert(Node** root, int key) {
    *root = insertNode(*root, key);
}
```
***
___Ищет узел с ключом key в дереве, начиная с корня root. Возвращает true, если узел найден, и false в противном случае.___
1. Инициализировать указатель current как корень дерева (root).
2. Пока current не равен nullptr, повторять следующие шаги:
    * Если ключ key равен ключу текущего узла current->key, вернуть true, так как искомый узел найден.
    * Если ключ key меньше ключа текущего узла current->key, перейти к левому поддереву: установить current равным current->left.
    * Если ключ key больше ключа текущего узла current->key, перейти к правому поддереву: установить current равным current->right.
3. Если цикл завершается (текущий узел current равен nullptr), вернуть false, так как искомый узел с ключом key не найден в дереве.
```c++
bool search(Node* root, int key) {
    Node* current = root;

    while (current != nullptr) {
        if (key == current->key) {
            return true;
        }
        else if (key < current->key) {
            current = current->left;
        }
        else {
            current = current->right;
        }
    }

    return false;
}
```
***
___Удаляет узел с ключом key из дерева, начиная с узла node. При необходимости выполняется балансировка дерева. Удаляет узел с ключом key из дерева, указанного указателем root. Если узел найден и удален, выполняется балансировка дерева.___
1. Если node равен nullptr, то возвращается nullptr, так как дерево пустое и узел с ключом key не может быть удален.
2. Если key меньше ключа текущего узла node->key, вызывается рекурсивный вызов removeNode для левого поддерева. Результат присваивается node->left, чтобы обновить указатель на левое поддерево после удаления.
3. Если key больше ключа текущего узла node->key, вызывается рекурсивный вызов removeNode для правого поддерева. Результат присваивается node->right, чтобы обновить указатель на правое поддерево после удаления.
4. Если key равен ключу текущего узла node->key, проверяются следующие случаи:
    * Если узел node является листовым узлом (не имеет потомков), он удаляется с помощью оператора delete, а затем возвращается nullptr для обновления ссылки на родительский узел.
    * Если узел node имеет только одного потомка (левого или правого), он заменяется этим потомком. Узел node удаляется с помощью оператора delete, а затем возвращается ссылка на потомка для обновления ссылки на родительский узел.
    * Если узел node имеет оба потомка, находится узел с минимальным ключом в правом поддереве, назовем его minRight. Значение ключа minRight->key копируется в node->key, чтобы заменить ключ текущего узла. Затем рекурсивно вызывается removeNode для правого поддерева с ключом minRight->key, чтобы удалить узел minRight из правого поддерева.
5. В конце функции вызывается функция balance для балансировки дерева после удаления. Возвращается сбалансированный корень поддерева.
```c++
Node* removeNode(Node* node, int key) {
    if (node == nullptr) {
        return nullptr;
    }

    if (key < node->key) {
        node->left = removeNode(node->left, key);
    }
    else if (key > node->key) {
        node->right = removeNode(node->right, key);
    }
    else {
        if (node->left == nullptr && node->right == nullptr) {
                delete node;
            return nullptr;
        }
        else if (node->left == nullptr) {
            Node* temp = node->right;
            delete node;
            return temp;
        }
        else if (node->right == nullptr) {
            Node* temp = node->left;
            delete node;
            return temp;
        }
        else {
            Node* minRight = findMinNode(node->right);
            node->key = minRight->key;
            node->right = removeNode(node->right, minRight->key);
        }
    }

    return balance(node);
}

bool remove(Node** root, int key) {
    if (*root == nullptr) {
        return false;
    }

    bool keyExists = search(*root, key);

    if (keyExists) {
        *root = removeNode(*root, key);
    }

    return keyExists;
}
```
***
___Находит узел с минимальным ключом в дереве, начиная с узла node. Возвращает минимальный ключ в дереве, указанном корнем root.___
1. Инициализируется указатель current как node.
2. В цикле while проверяется, существует ли левый потомок у текущего узла current->left. Если существует, current обновляется, устанавливая его равным левому потомку, и цикл продолжается.
3. Когда левый потомок больше не существует (равен nullptr), текущий узел current является узлом с минимальным ключом в поддереве.
4. Возвращается указатель на узел current, содержащий минимальный ключ.
5. Инициализировать указатель current как корень дерева (root).
6. Если current равен nullptr, генерировать исключение std::runtime_error с сообщением "The tree is empty".
7. Пока существует левый потомок у текущего узла current->left, обновлять current, устанавливая его равным левому потомку.
8. Возврат ключа текущего узла current->key, который будет содержать минимальный ключ во всем дереве.
```c++
Node* findMinNode(Node* node) {
    Node* current = node;

    while (current->left != nullptr) {
        current = current->left;
    }

    return current;
}

int findMin(Node* root) {
    if (root == nullptr) {
        throw std::runtime_error("The tree is empty");
    }

    Node* minNode = findMinNode(root);
    return minNode->key;
}
```
***
___Находит узел с наименьшим ключом, который больше заданного ключа key в дереве, начиная с узла node. Возвращает наименьший ключ, который больше заданного ключа key в дереве, указанном корнем root.___
1. Инициализируются указатели closestGreater и current как nullptr и node соответственно.
2. В цикле while проверяется, пока текущий узел current не станет равным nullptr.
3. Внутри цикла выполняется проверка: если ключ текущего узла current->key больше заданного ключа key, то текущий узел current становится наилучшим найденным узлом с большим ключом closestGreater, и движение продолжается влево, переходом к левому потомку current->left.
4. Если ключ текущего узла current->key меньше или равен заданному ключу key, движение продолжается вправо, переходом к правому потомку current->right.
5. По завершении цикла возвращается наилучший найденный узел closestGreater, который будет узлом с наименьшим ключом, большим заданного ключа, или nullptr, если такого узла не найдено.
6. Вызывается функция findClosestGreaterNode с указателем на корень root и заданным ключом key, чтобы найти узел с наименьшим ключом, большим key.
7. Если наилучший найденный узел closestGreaterNode равен nullptr, генерируется исключение std::runtime_error с сообщением "No greater key found".
8. Возвращается значение ключа наилучшего найденного узла closestGreaterNode->key.
```c++
Node* findClosestGreaterNode(Node* node, int key) {
    Node* closestGreater = nullptr;
    Node* current = node;

    while (current != nullptr) {
        if (current->key > key) {
            closestGreater = current;
            current = current->left;
        }
        else {
            current = current->right;
        }
    }

    return closestGreater;
}

int findClosestGreater(Node* root, int key) {
    Node* closestGreaterNode = findClosestGreaterNode(root, key);

    if (closestGreaterNode == nullptr) {
        throw std::runtime_error("No greater key found");
    }

    return closestGreaterNode->key;
}
```
***
___Освобождение памяти, занятой узлами дерева.___
1. Проверяется, если указатель node равен nullptr, что означает, что нет узлов для освобождения. В таком случае функция завершается без выполнения дополнительных действий.
2. Рекурсивно вызывается функция clear для левого поддерева node->left, чтобы освободить память для всех узлов в левом поддереве.
3. Рекурсивно вызывается функция clear для правого поддерева node->right, чтобы освободить память для всех узлов в правом поддереве.
4. Узел node освобождается с помощью оператора delete, чтобы освободить память, занятую этим узлом.
```c++
void clear(Node* node) {
    if (node == nullptr) {
        return;
    }

    clear(node->left);
    clear(node->right);
    delete node;
}
```
*** 
___Печать AVL-дерева в виде дерева с отступами.___
1. Вычислить высоту дерева h с помощью функции getHeight.
2. Установить значение prob для отступа (например, 3).
3. Проверить, если указатель на корень p не равен nullptr (то есть, если есть дерево для печати).
4. Вызвать функцию print_n(p, 0, 0, prob * h) для печати всего дерева. Передать указатель на корень p, начальный уровень 0, начальное значение отступа 0 и вычисленное значение отступа prob * h для корня.
5. В функции print_n:
    * Проверить, если указатель p не равен nullptr (то есть, если есть узел для печати).
    * Проверить, если текущий уровень level равен заданному уровню n.
        * Если равны, вывести отступы prob и значение ключа текущего узла p->key.
    * Если текущий уровень level не равен заданному уровню n, вызвать рекурсивно функцию print_n для левого поддерева p->left с увеличенным уровнем level + 1 и сохраненным значением отступа prob, затем вызвать рекурсивно функцию print_n для правого поддерева p->right с тем же уровнем level + 1 и тем же значением отступа prob.
6. После вызова print_n вывести символ новой строки endl.
```c++
void print_n(const Node* p, int n, int level, int prob) {
    if (p) {
        if (level == n){
            for (int i = 0; i <= prob; i++)
                cout << " ";
            cout << p->key;
            }
        else
        {
            print_n(p->left, n, level + 1, prob);
            print_n(p->right, n, level + 1, prob);
        }
    }
}

void print(Node* p) {
    int h = getHeight(p);
    int prob = 3;
    if (p)
    {
        for (int i = 0; i <= h; i++) 
        {
            print_n(p, i, 0, prob * (h - i)); 
            cout << endl;
        }
    }
```

### Тест программы 
В файле _test.cpp_ находится код тестовой программы, который демонстрирует работу функций вставки, удаления, поиска наибольшего и наименьшего, поиска ближайшего наименьшего и ближайшего наибольшего, поиска заданного, а также визуализирует получившееся дерево.

__Результат работы программы:__

![тест](https://github.com/iis-32170x/RPIIS/assets/146451109/a68b8fa9-f3a2-4ce6-a645-e0a0dcc7b4d3)

### Вывод:
Цель достигнута. Поставленная задача решена.
***
### Источники: 
[АВЛ-дерво Википедия](https://ru.wikipedia.org/wiki/%D0%90%D0%92%D0%9B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE#%D0%91%D0%B0%D0%BB%D0%B0%D0%BD%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)

[Создание библиотеки Visual Studio C++](https://www.youtube.com/watch?v=5mD-rhaYF4U )
