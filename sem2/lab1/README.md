# AVLTreeLib
## Тема
Структура данных
## Цель
Целью данной работы является разработка библиотеки для работы с AVL-деревом в C++, что позволит исследовать свойства структур данных и оптимизировать процессы поиска, вставки и удаления элементов.

## Задача
Задачей проекта является разработка и реализация ключевых алгоритмов для работы с AVL-деревом, включая вставку, удаление, поиск узлов(минимального, максимального, ближайшиих большего и меньшего), а также разработка системы тестирования для проверки корректности библиотеки.

## Список используемых понятий
- **AVL-дерево**: Древовидная структура данных с быстрым доступом к информации. Она представляет собой бинарное дерево — иерархическую схему из вершин и путей между ними, где у одной вершины может быть не более двух потомков. АВЛ-дерево – модифицированное, у него оптимизирована структура.
[[Источник: skillfactory.ru]](https://blog.skillfactory.ru/glossary/avl-derevo/)
- **Балансировка узлов**: Операция, которая делает дерево более сбалансированным. В случае с АВЛ-деревьями ее применяют, если нарушается главное правило структуры: поддеревья-потомки одного узла начинают различаться больше чем на один уровень. Если разница в количестве уровней становится равна 2 или –2, запускается балансировка: связи между предками и потомками изменяются и перестраиваются так, чтобы сохранить правильную структуру.
[[Источник: skillfactory.ru]](https://blog.skillfactory.ru/glossary/avl-derevo/)
- **Вращение**: Операции над узлами дерева, используемые для его балансировки. Различают правое и левое вращения, а также их комбинации (большое левое и большое правое вращение).
[[Источник: habr.com]](https://habr.com/ru/articles/150732/)
- **Фактор баланса**: Разница между высотами правого и левого поддеревьев узла. Используется для определения необходимости балансировки.
[[Источник: habr.com]](https://habr.com/ru/articles/150732/)
- **Высота дерева**: Максимальная длина пути от корня до листа. В контексте AVL-деревьев высота используется для определения балансировочного фактора и нужды в балансировке.
[[Источник: habr.com]](https://habr.com/ru/articles/150732/)
- **Бинарное дерево поиска**: Структура данных, в которой каждый узел имеет не более двух потомков, причём левый потомок меньше родителя, а правый — больше.**[Источник: Фундаментальные алгоритмы на C++. Анализ / Структуры данных /
Сортировка / Поиск: Пер. с англ. / Роберт Седжвик. – К.
Издательство «ДиаСофт», 2001.]**
- **Predecessor(Предшественник) и Successor(Преемник)**: Соответственно, ближайший меньший и ближайший больший элементы относительно заданного узла в бинарном дереве поиска.
[[Источник: neerc.ifmo.ru]](https://neerc.ifmo.ru/wiki/index.php?title=AA-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)
- **Рекурсия**: Метод в программировании, при котором функция вызывает саму себя. Широко используется в операциях с AVL-деревом, таких как вставка, удаление и балансировка. **[Источник: Дискретная математика для программистов / Ф.А. Новиков – СПб:Питер, 2000.]**
- **Лист дерева**: Узел дерева, не имеющий потомков.
[[Источник: ru.hexlet.io]](https://ru.hexlet.io/qna/glossary/questions/chto-takoe-avl-derevo)
## Описание алгоритмов

### Вставка ключа
Вставка нового ключа в АВЛ-дерево выполняется, по большому счету, так же, как это делается в простых деревьях поиска: спускаемся вниз по дереву, выбирая правое или левое направление движения в зависимости от результата сравнения ключа в текущем узле и вставляемого ключа. Единственное отличие заключается в том, что при возвращении из рекурсии (т.е. после того, как ключ вставлен либо в правое, либо в левое поддерево, и это дерево сбалансировано) выполняется балансировка текущего узла.
[[Источник: habr.com]](https://habr.com/ru/articles/150732/)
![Alt text](flowchart_insert.png)
### Обновление высоты узла
Вспомогательный алгоритм **fixHeight** обновляет высоту узла AVL-дерева. Он вычисляет высоты левого и правого поддеревьев, выбирает максимальную из них и устанавливает высоту текущего узла на один больше максимальной. 
[[Источник: habr.com]](https://habr.com/ru/articles/150732/)
![Alt text](flowchart_fixHeight.png)
### Балансировка узла
Особенность АВЛ-деревьев тут в том, что после вставки надо проверить соотношение длин поддеревьев и, если нужно, провести балансировку. Причем балансировку может понадобиться проводить для нескольких уровней дерева — это нормально. Алгоритм для балансирования может спускаться вниз из начального узла или подниматься вверх от свежедобавленного, по ходу движения пересчитывать разницу высот и совершать повороты, если где-то обнаружилась разница в два уровня. Балансировка продолжается, пока все значения высот не пересчитаются, а дисбаланс не будет устранен.
[[Источник: skillfactory.ru]](https://blog.skillfactory.ru/glossary/avl-derevo/)
![Alt text](flowchart_balance.png)
### Поворот влево и вправо
Программная реализация поворота сводится к перестановке ссылок, соединяющих между собой элементы дерева. После этого пересчитываются числовые значения, которые показывают разницу между высотами.
[[Источник: skillfactory.ru]](https://blog.skillfactory.ru/glossary/avl-derevo/)

**rotateLeft**

![Alt text](flowchart_rotateLeft.png)

**rotateRight**

![Alt text](flowchart_rotateRight.png)
### Удаление ключа
Алгоритм удаления узла из AVL-дерева начинается с поиска узла по ключу, при этом спускаясь влево или вправо в зависимости от сравнения ключей. При нахождении узла, если у него нет потомков, он просто удаляется. Если у узла один потомок, он заменяет удаляемый узел. При наличии двух потомков удаляемый узел заменяется минимальным узлом из его правого поддерева, который затем удаляется методом removeMin. В любом случае, после удаления узла проводится балансировка для поддержания свойств AVL-дерева.
[[Источник: habr.com]](https://habr.com/ru/articles/150732/)
![Alt text](flowchart_remove.png)
### Поиск ключа
Алгоритм поиска узла в AVL-дереве рекурсивно проверяет каждый узел, сравнивая искомый ключ с ключом текущего узла. Если искомый ключ меньше, продолжает поиск в левом поддереве; если больше — в правом. Поиск завершается возвратом узла, если ключ найден, или nullptr, если такого ключа в дереве нет.
**[Источник: Фундаментальные алгоритмы на C++. Анализ / Структуры данных /
Сортировка / Поиск: Пер. с англ. / Роберт Седжвик. – К.
Издательство «ДиаСофт», 2001.]**
![Alt text](flowchart_find.png)
### Поиск минимума и максимума
Методы findMin и findMax в AVL-дереве идентифицируют минимальный и максимальный элементы соответственно, путем последовательного перехода в самые крайние левые или правые узлы дерева начиная от корня. Минимальный элемент находится путем движения влево до тех пор, пока не будет достигнут узел без левого потомка, а максимальный — движением вправо до узла без правого потомка.
**[Источник: Фундаментальные алгоритмы на C++. Анализ / Структуры данных /
Сортировка / Поиск: Пер. с англ. / Роберт Седжвик. – К.
Издательство «ДиаСофт», 2001.]**
![Alt text](flowchart_findMin.png)

![Alt text](flowchart_findMax.png)
### Поиск ближайшего меньшего и ближайшего большего
Алгоритмы findSuccessor и findPredecessor в AVL-дереве начинают с поиска узла по заданному ключу. Если узел найден, findSuccessor ищет минимальный элемент в правом поддереве этого узла, если оно существует, для определения ближайшего большего значения. В отсутствие правого поддерева, алгоритм идет вверх к корню дерева, пока не найдет переход, где текущий узел был бы левым потомком, определяя таким образом ближайший больший узел. Аналогично, findPredecessor ищет максимальный элемент в левом поддереве для определения ближайшего меньшего значения. Если левое поддерево отсутствует, алгоритм поднимается к корню, пока не обнаружит ситуацию, где текущий узел является правым потомком, что указывает на ближайший меньший узел.
**[Источник: Фундаментальные алгоритмы на C++. Анализ / Структуры данных /
Сортировка / Поиск: Пер. с англ. / Роберт Седжвик. – К.
Издательство «ДиаСофт», 2001.]**

![Alt text](flowchart_findSuccessor.png)

![Alt text](flowchart_findPredecessor.png)

## Результаты тестирования
### Тестирование визуализации структуры дерева

**Входные узлы [3,1,4,2,5]**
<img width="443" alt="test1" src="https://github.com/iis-32170x/RPIIS/assets/144939061/4f8b864f-1f93-4488-9e33-547de7940cec">

### Тестирование вставки узлов
![Alt text](test2.png)
### Тестирование удаления узлов
![Alt text](test3.png)
### Тестирование поиска минимального и максимального узлов
![Alt text](test4.png)
### Тестирование поиска ближайших меньшего и большего узлов
![Alt text](test5.png)

## Вывод
Проект по реализации и тестированию AVL-дерева представляет собой комплексную задачу, включающую в себя не только программную реализацию структуры данных, но и её тщательное тестирование. Работа над этим проектом позволила глубже понять принципы работы с балансируемыми бинарными деревьями поиска, а также освоить методы их оптимизации и эффективного использования. В результате были достигнуты следующие ключевые моменты:

- Разработка и тестирование AVL-дерева способствовали углублённому пониманию механизмов самобалансировки деревьев и их влияния на эффективность операций поиска, вставки и удаления.

- В процессе работы над проектом были успешно реализованы и применены различные алгоритмы, связанные с балансировкой узлов, вращениями и поиском элементов в дереве, что улучшило навыки алгоритмического программирования.

- Тестирование реализации с помощью разнообразных сценариев показало важность комплексного подхода к проверке корректности работы структур данных и их методов. Визуализация структуры дерева после каждой операции была ключевым элементом в отладке и оптимизации реализации.

- Создание подробной документации и использование визуализации для демонстрации работы дерева обеспечили лучшее понимание структуры и логики AVL-дерева, а также способствовали облегчению процесса отладки и оптимизации.

- Реализованные методы и подходы к работе с AVL-деревом могут быть применены и адаптированы для других типов балансируемых бинарных деревьев, что делает код проекта полезным ресурсом для будущих разработок.
