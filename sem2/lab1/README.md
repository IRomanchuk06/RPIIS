# <p align="center">Лабораторная работа №1</p>

Вариант 3. Одномерный массив. Сортировка массива. Вставка элемента в отсортированный массив. Поиск элемента в отсортированном массиве. 
Объединение двух отсортированных массивов. Пересечение двух отсортированных массивов.

## <p align="center">Цели лабораторной работы:</p>
1. Разработать библиотеку для работы с одномерным массивом. (например, C++, Java, Python).
2. Создать тестовую программу для демонстрации функциональности разработанной библиотеки.
3. Разработать систему тестов для проверки работоспособности и корректности библиотеки, учитывая требования полноты, адекватности и непротиворечивости.
4. Обеспечить обработку некорректных данных, предусмотрев корректное завершение программы при возникновении ошибок.
5. Составить отчет по выполнению лабораторной работы.
   
## <p align="center">Задачи лабораторной работы:</p>
1. Изучить спецификацию задачи по работе с одномерным массивом и операциями над ним.
2. Выбрать язык программирования для реализации библиотеки (например, C++, Java, Python) в соответствии с индивидуальным заданием.
3. Разработать и реализовать библиотеку для работы с очередью с приоритетом, включая операции вставки и извлечения элементов.
4. Написать тестовую программу, которая демонстрирует основные сценарии использования библиотеки.
5. Разработать систему тестов, включающую тест-кейсы для проверки различных аспектов работы библиотеки, включая корректность, производительность и обработку ошибок.
6. Провести тестирование разработанной библиотеки, убедившись в ее правильной работе на различных входных данных.
7. Составить подробный отчет, включая описание решения задачи, архитектуры библиотеки, результаты тестирования и выводы.

## <p align="center">Список используемых понятий и алгоритмов:</p>
1. **Библиотека программного обеспечения (Библиотека кода):**
В программировании библиотека представляет собой совокупность программного кода, предназначенного для решения определенных задач. Этот код может содержать функции, классы, процедуры или другие компоненты, которые разработчики могут повторно использовать в своих программных проектах. Библиотеки упрощают разработку, так как они предоставляют готовые решения для типовых задач.

2. **Одномерный массив:**
   Одномерный массив - это структура данных, которая представляет собой последовательность элементов одного типа, расположенных в памяти последовательно.

3. **Бинарный поиск(Binary Search):**
   Бинарный поиск - это эффективный алгоритм поиска элемента в упорядоченном массиве или списке. Он работает путем деления массива на две части и сравнения искомого элемента с элементом в середине массива. Если искомый элемент равен элементу в середине, то поиск успешен.
   Основные шаги бинарного поиска:
    1.Определение начального и конечного индексов диапазона поиска.
    2.Нахождение индекса среднего элемента внутри диапазона.
    3.Сравнение искомого элемента с элементом в середине.
    4.Если искомый элемент найден, возвращается его индекс.
    5.Если искомый элемент меньше элемента в середине, поиск продолжается в первой половине массива.
    6.Если искомый элемент больше элемента в середине, поиск продолжается во второй половине массива.
    7.Процесс повторяется до тех пор, пока искомый элемент не будет найден или диапазон сужается до пустого.

4. **Сортировка выбором(Selection Sort):**
   Selection Sort - это один из наиболее эффективных алгоритмов сортировки, который основан на принципе "разделяй и властвуй". Он относится к семейству сортировок обменом.
   **Алгоритм сортировки выбором ботает следующим образом:**
    1.Из неотсортированной части массива находится наименьший (или наибольший) элемент.
    2.Этот элемент меняется местами с первым элементом неотсортированной части массива, помещая его в отсортированную часть.
    3.Повторяются шаги 1 и 2 для оставшейся неотсортированной части массива до тех пор, пока весь массив не будет отсортирован.
  

5. **Тестирование с использованием Google Test:**
   Google Test — это фреймворк для написания тестов в языке программирования C++. Тестирование с его использованием обеспечивает автоматизацию проверок и обеспечивает надежность кода.

## <p align="center">Описание используемых алгоритмов:</p>
1. **Одномерный массив:**
В своей библиотеке я реализовывала одномерный массив через `vector<int> arr;`.


2. **Бинарный поиск(Binary Search):**
Используется для выполнения одной из функций библиотеки - поиск элемента одномерного массива.
```cpp
int MyStructure::poisk(int left, int right, int index_k) {
    if (left >= right) {
        return arr[left];
    }

    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[index_k] == arr[mid]) {
            return arr[mid];
        }
        if (arr[index_k] < arr[mid]) {
            return poisk(left, mid - 1, index_k);
        }
        else {
            return poisk(mid + 1, right, index_k);
        }
    }
    return -1;
}
```

3. **Сортировка выбором(Selection Sort):**
Использутся в таких функциях библиотеки как "Поиск элемента в отсортированном массиве, добавление элемента в отсортированный массив".

```cpp
void MyStructure::dsort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        int minind = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minind]) {
                minind = j;
            }
        }
         swap(arr[i], arr[minind]);
    }
}
```
   

4. **Алгоритм работы библиотеки с одномерным массивом:**

    1. **Инициализация:**
       - Создание экземпляра структуры `OMassive`.
       - Внутренний вектор `arr` используется для хранения элементов в виде отсортированного массива.
    
    2. **Сортировка вектора:**
       - Вектор arr сортируется в порядке возрастания с использованием алгоритма сортировки выбором.
       
    
    3. **Объединение двух векторов:**
       - Создается новый вектор answer.
       - Копируются все элементы из вектора arr в answer.
       - Копируются все элементы из arr2 в answer.
       - Вызывается функция dsort для сортировки вектора answer.
       -Возвращается вектор answer.
    
    4. **Пересечение двух векторов:**
       - Создается новый вектор answer.
        - Для каждого элемента arr[i] в векторе arr:
        - Для каждого элемента arr2[j] в векторе arr2:
        - Если arr[i] равен arr2[j] и arr[i] еще не содержится в answer:
        - Добавить arr[i] в answer.
        - Вызывается функция dsort для сортировки вектора answer.
        - Возвращается вектор answer.Пока текущий элемент больше родителя и не достигнут корень:
         
    
    5. **Поиск элемента в векторе:**
       - Рекурсивная функция poisk принимает границы left и right вектора arr и индекс index_k элемента, который необходимо найти.
        - Если left больше или равно right, возвращается значение arr[left].
        - Иначе, выполняется бинарный поиск:
        - Вычисляется середина mid между left и right.
        - Если arr[index_k] равен arr[mid], возвращается значение arr[mid].
        - Если arr[index_k] меньше arr[mid], вызывается рекурсивно функция poisk для левой половины вектора.
        - Иначе, вызывается рекурсивно функция poisk для правой половины вектора.
        - Если элемент не найден, возвращается -1.Пока есть хотя бы один потомок текущего элемента:
         
    
    6. **Вставка элемента в массив:**
       - Новый элемент добавляется в вектор arr.
       - Вызывается функция dsort для сортировки вектора arr.



## <p align="center">Результаты тестирования:</p>
Тестирование проводилось с помощью фреймворка Google test. Система тестов состоит из 4 тестов, по 3 значения каждого теста, итого 12 тестов. Тест на сортировку массива, тест на добавление элемента в массив, тест на объединение двух массивов и тест на пересечение двух массивов. Все тесты прошли успешно.

<p align="center">
  <img src="![image](https://github.com/iis-32170x/RPIIS/assets/148707516/3095ba7a-baf9-4692-b3a1-6a9dc3705c37)="Тесты библиотеки">
</p>

**Система тестов:**

```cpp
#include "pch.h"
#include <gtest/gtest.h>
using namespace std;

TEST(OMassiveTest, DsortTest1) {
    OMassive myStruct;
    myStruct.arr = { 1, 5, 3, 8, 2 };
    myStruct.dsort(myStruct.arr);
     vector<int> expected = { 1, 2, 3, 5, 8 };
    ASSERT_EQ(myStruct.arr, expected);
}

TEST(OMassiveTest, DsortTest2) {
    OMassive myStruct;
    myStruct.arr = { 10, 6, 4, 7, 9 };
    myStruct.dsort(myStruct.arr);
     vector<int> expected = { 4, 6, 7, 9, 10 };
    ASSERT_EQ(myStruct.arr, expected);
}

TEST(OMassiveTest, DsortTest3) {
    OMassive myStruct;
    myStruct.arr = { 100, 50, 30, 80, 20 };
    myStruct.dsort(myStruct.arr);
     vector<int> expected = { 20, 30, 50, 80, 100 };
    ASSERT_EQ(myStruct.arr, expected);
}

TEST(OMassiveTest, AddTest1) {
    OMassive myStruct;
    myStruct.arr = { 1, 5, 3 };
    myStruct.add(8);
     vector<int> expected = { 1, 3, 5, 8 };
    ASSERT_EQ(myStruct.arr, expected);
}

TEST(OMassiveTest, AddTest2) {
    OMassive myStruct;
    myStruct.arr = { 10, 6, 4 };
    myStruct.add(7);
     vector<int> expected = { 4, 6, 7, 10 };
    ASSERT_EQ(myStruct.arr, expected);
}

TEST(OMassiveTest, AddTest3) {
    OMassive myStruct;
    myStruct.arr = { 100, 50, 30 };
    myStruct.add(80);
     vector<int> expected = { 30, 50, 80, 100 };
    ASSERT_EQ(myStruct.arr, expected);
}

TEST(OMassiveTest, ObjedinenieTest1) {
    OMassive myStruct;
    myStruct.arr = { 1, 5, 3 };
     vector<int> arr2 = { 8, 2, 6 };
     vector<int> result = myStruct.objedinenie(arr2);
     vector<int> expected = { 1, 2, 3, 5, 6, 8 };
    myStruct.dsort(expected); 
    ASSERT_EQ(result, expected);
}

TEST(OMassiveTest, ObjedinenieTest2) {
    OMassive myStruct;
    myStruct.arr = { 10, 6, 4 };
     vector<int> arr2 = { 7, 9, 11 };
     vector<int> result = myStruct.objedinenie(arr2);
     vector<int> expected = { 4, 6, 7, 9, 10, 11 };
    myStruct.dsort(expected); 
    ASSERT_EQ(result, expected);
}

TEST(OMassiveTest, ObjedinenieTest3) {
    OMassive myStruct;
    myStruct.arr = { 100, 50, 30 };
     vector<int> arr2 = { 80, 120, 70 };
     vector<int> result = myStruct.objedinenie(arr2);
     vector<int> expected = { 30, 50, 70, 80, 100, 120 };
    myStruct.dsort(expected); 
    ASSERT_EQ(result, expected);
}

TEST(OMassiveTest, Perese4enieTest1) {
    OMassive myStruct;
    myStruct.arr = { 1, 5, 3, 8, 2 };
     vector<int> arr2 = { 2, 4, 6 };
     vector<int> result = myStruct.perese4enie(arr2);
     vector<int> expected = { 2 };
    ASSERT_EQ(result, expected);
}

TEST(OMassiveTest, Perese4enieTest2) {
    OMassive myStruct;
    myStruct.arr = { 10, 6, 4, 7, 9 };
     vector<int> arr2 = { 5, 7, 9, 11 };
     vector<int> result = myStruct.perese4enie(arr2);
     vector<int> expected = { 7, 9 };
    ASSERT_EQ(result, expected);
}

TEST(OMassiveTest, Perese4enieTest3) {
    OMassive myStruct;
    myStruct.arr = { 100, 50, 30, 80, 20 };
     vector<int> arr2 = { 10, 20, 30, 40, 50 };
     vector<int> result = myStruct.perese4enie(arr2);
     vector<int> expected = { 20, 30, 50 };
    ASSERT_EQ(result, expected);
}


int main(int argc, char** argv) {
	::testing::InitGoogleTest(&argc, argv);
	return RUN_ALL_TESTS();
}
```
## <p align="center">Вывод:</p>

В результате выполнения лабораторной работы были углублены знания в области работы с одномерными массивами и реализации основных операций, таких как поиск элемента, добавление элемента, пересечение и объединение двух массивов.

Была разработана библиотека, которая предоставляет эффективные и надежные операции работы с одномерными массивами. В частности, были реализованы функции для поиска элемента в массиве, добавления элемента в массив, а также операции пересечения и объединения двух массивов.

При разработке библиотеки использовались стандартные контейнеры C++, такие как std::vector, для представления одномерного массива. Это позволило обеспечить удобство использования и эффективность операций.

Для проверки корректности работы библиотеки были написаны тесты с использованием Google Test. Тестирование позволило убедиться в правильности реализации операций и обнаружить возможные ошибки или недочёты.

Лабораторная работа предоставила ценный опыт в разработке библиотек для работы с одномерными массивами и использовании стандартных контейнеров C++. Также были получены навыки работы с тестовыми фреймворками, что позволило обеспечить надежность и корректность разработанной библиотеки.

## <p align="center">Используемые источники:</p>
1. https://ru.hexlet.io/courses/basic-algorithms/lessons/binary-search/theory_unit (Бинарный поиск).
2. https://www.youtube.com/watch?v=5mD-rhaYF4U&t=209s (создание библиотеки).
3. https://www.youtube.com/watch?v=o1ZDXf7NGN4&t=868s (реализация алгоритмов на C++).
4. https://github.com/google/googletest (про Google test: установка, использование).
5. https://ru.hexlet.io/courses/basic-algorithms/lessons/binary-search/theory_unit (сортировка выбором) 
6. https://chat.openai.com (помощь в освоении материала)
