# AVLTreeLib
## Цель
Целью работы является разработка библиотеки для работы с AVL-деревом в C++, что позволит исследовать свойства структур данных и оптимизировать процессы поиска, вставки и удаления элементов.

## Задача
Задачей лабораторной работы является разработка и реализация ключевых алгоритмов для работы с AVL-деревом, включая вставку, удаление, поиск узлов (минимального, максимального, ближайшиих большего и меньшего), а также разработка системы тестирования для проверки корректности библиотеки.

## Список используемых понятий
---
- [**AVL-дерево**](https://blog.skillfactory.ru/glossary/avl-derevo/) — древовидная структура данных с быстрым доступом к информации. Она представляет собой бинарное дерево — иерархическую схему из вершин и путей между ними, где у одной вершины может быть не более двух потомков. АВЛ-дерево – модифицированное, у него оптимизирована структура.
[Источник: skillfactory.ru]
- [**Балансировка узлов**](https://blog.skillfactory.ru/glossary/avl-derevo/) — операция, которая делает дерево более сбалансированным. В случае с АВЛ-деревьями ее применяют, если нарушается главное правило структуры: поддеревья-потомки одного узла начинают различаться больше чем на один уровень. Если разница в количестве уровней становится равна 2 или –2, запускается балансировка: связи между предками и потомками изменяются и перестраиваются так, чтобы сохранить правильную структуру.
[Источник: skillfactory.ru]
- [**Вращение**](https://habr.com/ru/articles/150732/) - операции над узлами дерева, используемые для его балансировки. Различают правое и левое вращения, а также их комбинации (большое левое и большое правое вращение).
[Источник: habr.com]
- [**Фактор баланса**](https://habr.com/ru/articles/150732/) — разница между высотами правого и левого поддеревьев узла. Используется для определения необходимости балансировки.
[Источник: habr.com]
- [**Высота дерева**](https://habr.com/ru/articles/150732/) — максимальная длина пути от корня до листа. В контексте AVL-деревьев высота используется для определения балансировочного фактора и нужды в балансировке.
[Источник: habr.com]
- **Бинарное дерево поиска** — структура данных, в которой каждый узел имеет не более двух потомков, причём левый потомок меньше родителя, а правый — больше. **[Источник: Фундаментальные алгоритмы на C++. Анализ / Структуры данных /
Сортировка / Поиск: Пер. с англ. / Роберт Седжвик. – К.
Издательство «ДиаСофт», 2001.]**
- [**Predecessor(Предшественник) и Successor(Преемник)**](https://neerc.ifmo.ru/wiki/index.php?title=AA-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE) — соответственно, ближайший меньший и ближайший больший элементы относительно заданного узла в бинарном дереве поиска.
[Источник: neerc.ifmo.ru]
- **Рекурсия** — метод в программировании, при котором функция вызывает саму себя. Широко используется в операциях с AVL-деревом, таких как вставка, удаление и балансировка. **[Источник: Дискретная математика для программистов / Ф.А. Новиков – СПб:Питер, 2000.]**
- [**Лист дерева**](https://ru.hexlet.io/qna/glossary/questions/chto-takoe-avl-derevo) — узел дерева, не имеющий потомков.
[Источник: ru.hexlet.io]

## Описание алгоритмов

### Вставка ключа
Вставка нового ключа в АВЛ-дерево выполняется, по большому счету, так же, как это делается в простых деревьях поиска: спускаемся вниз по дереву, выбирая правое или левое направление движения в зависимости от результата сравнения ключа в текущем узле и вставляемого ключа. Единственное отличие заключается в том, что при возвращении из рекурсии (т.е. после того, как ключ вставлен либо в правое, либо в левое поддерево, и это дерево сбалансировано) выполняется балансировка текущего узла.
[[Источник: habr.com]](https://habr.com/ru/articles/150732/)
```cpp
void AVLTree::insert(int key) {
    root = insert(root, key);
}

Node* AVLTree::insert(Node* node, int key) {
    if (node == nullptr) {
        return new Node(key);
    }
    if (key < node->key) {
        node->left = insert(node->left, key);
    }
    else if (key > node->key) {
        node->right = insert(node->right, key);
    }
    else {
        // Ключ уже существует, вставка не производится
        return node;
    }

    // Обновляем высоту узла
    fixHeight(node);

    // Выполняем балансировку
    return balance(node);
}
```
### Обновление высоты узла
Вспомогательный алгоритм **fixHeight** обновляет высоту узла AVL-дерева. Он вычисляет высоты левого и правого поддеревьев, выбирает максимальную из них и устанавливает высоту текущего узла на один больше максимальной. 
[[Источник: habr.com]](https://habr.com/ru/articles/150732/)
```cpp
// Обновление высоты узла
void AVLTree::fixHeight(Node* node) {
    unsigned char heightLeft = node->left ? node->left->height : 0;
    unsigned char heightRight = node->right ? node->right->height : 0;
    node->height = (heightLeft > heightRight ? heightLeft : heightRight) + 1;
}
```
### Балансировка узла
Особенность АВЛ-деревьев тут в том, что после вставки надо проверить соотношение длин поддеревьев и, если нужно, провести балансировку. Причем балансировку может понадобиться проводить для нескольких уровней дерева — это нормально. Алгоритм для балансирования может спускаться вниз из начального узла или подниматься вверх от свежедобавленного, по ходу движения пересчитывать разницу высот и совершать повороты, если где-то обнаружилась разница в два уровня. Балансировка продолжается, пока все значения высот не пересчитаются, а дисбаланс не будет устранен.
[[Источник: skillfactory.ru]](https://blog.skillfactory.ru/glossary/avl-derevo/)
```cpp
// Метод для балансировки узла
Node* AVLTree::balance(Node* node) {
    fixHeight(node);

    int balanceFactor = getBalanceFactor(node);

    if (balanceFactor == 2) {
        if (getBalanceFactor(node->right) < 0) {
            node->right = rotateRight(node->right);
        }
        return rotateLeft(node);
    }
    if (balanceFactor == -2) {
        if (getBalanceFactor(node->left) > 0) {
            node->left = rotateLeft(node->left);
        }
        return rotateRight(node);
    }

    return node; // Балансировка не требуется
}
```
### Поворот влево и вправо
Программная реализация поворота сводится к перестановке ссылок, соединяющих между собой элементы дерева. После этого пересчитываются числовые значения, которые показывают разницу между высотами.
[[Источник: skillfactory.ru]](https://blog.skillfactory.ru/glossary/avl-derevo/)

**rotateLeft**

```cpp
// Левое вращение вокруг узла
Node* AVLTree::rotateLeft(Node* node) {
    Node* leftNode = node->left;
    node->left = leftNode->right;
    leftNode->right = node;
    fixHeight(node);
    fixHeight(leftNode);
    return leftNode;
}
```
**rotateRight**
```cpp
// Правое вращение вокруг узла
Node* AVLTree::rotateRight(Node* node) {
    Node* rightNode = node->right;
    node->right = rightNode->left;
    rightNode->left = node;
    fixHeight(node);
    fixHeight(rightNode);
    return rightNode;
}
```
### Удаление ключа
Алгоритм удаления узла из AVL-дерева начинается с поиска узла по ключу, при этом спускаясь влево или вправо в зависимости от сравнения ключей. При нахождении узла, если у него нет потомков, он просто удаляется. Если у узла один потомок, он заменяет удаляемый узел. При наличии двух потомков удаляемый узел заменяется минимальным узлом из его правого поддерева, который затем удаляется методом removeMin. В любом случае, после удаления узла проводится балансировка для поддержания свойств AVL-дерева.
[[Источник: habr.com]](https://habr.com/ru/articles/150732/)
```cpp
void AVLTree::remove(int key) {
    root = remove(root, key);
}

Node* AVLTree::remove(Node* node, int key) {
    if (node == nullptr) return nullptr;

    if (key < node->key) {
        node->left = remove(node->left, key);
    }
    else if (key > node->key) {
        node->right = remove(node->right, key);
    }
    else { // Удаление узла, когда ключ найден
        Node* left = node->left;
        Node* right = node->right;

        delete node; // Удаление текущего узла

        if (right == nullptr) return left;

        Node* min = findMin(right);
        min->right = removeMin(right);
        min->left = left;

        return balance(min);
    }

    return balance(node);
}
```
### Поиск ключа
Алгоритм поиска узла в AVL-дереве рекурсивно проверяет каждый узел, сравнивая искомый ключ с ключом текущего узла. Если искомый ключ меньше, продолжает поиск в левом поддереве; если больше — в правом. Поиск завершается возвратом узла, если ключ найден, или nullptr, если такого ключа в дереве нет.
**[Источник: Фундаментальные алгоритмы на C++. Анализ / Структуры данных /
Сортировка / Поиск: Пер. с англ. / Роберт Седжвик. – К.
Издательство «ДиаСофт», 2001.]**
```cpp
// Публичный метод
Node* AVLTree::find(int key) const {
    return find(root, key);
}


// Вспомогательный приватный метод
Node* AVLTree::find(Node* node, int key) const {
    if (node == nullptr) {
        return nullptr; // Ключ не найден
    }
    if (key < node->key) {
        return find(node->left, key);
    }
    else if (key > node->key) {
        return find(node->right, key);
    }
    else {
        return node; // Ключ найден
    }
}
```
### Поиск минимума и максимума
Методы findMin и findMax в AVL-дереве идентифицируют минимальный и максимальный элементы соответственно, путем последовательного перехода в самые крайние левые или правые узлы дерева начиная от корня. Минимальный элемент находится путем движения влево до тех пор, пока не будет достигнут узел без левого потомка, а максимальный — движением вправо до узла без правого потомка.
**[Источник: Фундаментальные алгоритмы на C++. Анализ / Структуры данных /
Сортировка / Поиск: Пер. с англ. / Роберт Седжвик. – К.
Издательство «ДиаСофт», 2001.]**

**findMin**

```cpp
Node* AVLTree::findMin(Node* node) {
    return node->left ? findMin(node->left) : node;
}

Node* AVLTree::removeMin(Node* node) {
    if (node->left == nullptr) return node->right;
    node->left = removeMin(node->left);
    return balance(node);
}

// Находит минимальный элемент в дереве
Node* AVLTree::findMin() const {
    Node* current = root;
    while (current && current->left != nullptr) {
        current = current->left;
    }
    return current;
}
```
**findMax**
```cpp
// Находит максимальный элемент в дереве
Node* AVLTree::findMax() const {
    Node* current = root;
    while (current && current->right != nullptr) {
        current = current->right;
    }
    return current;
}
```
### Поиск ближайшего меньшего и ближайшего большего
Алгоритмы findSuccessor и findPredecessor в AVL-дереве начинают с поиска узла по заданному ключу. Если узел найден, findSuccessor ищет минимальный элемент в правом поддереве этого узла, если оно существует, для определения ближайшего большего значения. В отсутствие правого поддерева, алгоритм идет вверх к корню дерева, пока не найдет переход, где текущий узел был бы левым потомком, определяя таким образом ближайший больший узел. Аналогично, findPredecessor ищет максимальный элемент в левом поддереве для определения ближайшего меньшего значения. Если левое поддерево отсутствует, алгоритм поднимается к корню, пока не обнаружит ситуацию, где текущий узел является правым потомком, что указывает на ближайший меньший узел.
**[Источник: Фундаментальные алгоритмы на C++. Анализ / Структуры данных /
Сортировка / Поиск: Пер. с англ. / Роберт Седжвик. – К.
Издательство «ДиаСофт», 2001.]**

**findSuccessor**

```cpp
Node* AVLTree::findSuccessor(int key) const {
    Node* current = find(root, key); // Сначала находим узел с данным ключом
    if (current == nullptr) return nullptr; // Если такого узла нет, возвращаем nullptr

    // Если у узла есть правое поддерево, то ищем минимальный элемент в этом поддереве
    if (current->right != nullptr) {
        Node* temp = current->right;
        while (temp->left != nullptr) {
            temp = temp->left;
        }
        return temp;
    }

    // Если правого поддерева нет, поднимаемся вверх к корню,
    // пока не найдем переход от левого к правому поддереву
    Node* successor = nullptr;
    Node* ancestor = root;
    while (ancestor != current) {
        if (current->key < ancestor->key) {
            successor = ancestor; // Нашли потенциального successor
            ancestor = ancestor->left;
        }
        else {
            ancestor = ancestor->right;
        }
    }

    return successor;
}
```
**findPredecessor**
```cpp
Node* AVLTree::findPredecessor(int key) const {
    Node* current = find(root, key); // Сначала находим узел с данным ключом
    if (current == nullptr) return nullptr; // Если такого узла нет, возвращаем nullptr

    // Если у узла есть левое поддерево, то ищем максимальный элемент в этом поддереве
    if (current->left != nullptr) {
        Node* temp = current->left;
        while (temp->right != nullptr) {
            temp = temp->right;
        }
        return temp;
    }

    // Если левого поддерева нет, поднимаемся вверх к корню,
    // пока не найдем переход от правого к левому поддереву
    Node* predecessor = nullptr;
    Node* ancestor = root;
    while (ancestor != current) {
        if (current->key > ancestor->key) {
            predecessor = ancestor; // Нашли потенциального predecessor
            ancestor = ancestor->right;
        }
        else {
            ancestor = ancestor->left;
        }
    }

    return predecessor;
}
```


## Результаты тестирования
### Тестирование визуализации структуры дерева
**Входные узлы [3,1,4,2,5]**

<img width="443" alt="test1" src="https://github.com/iis-32170x/RPIIS/assets/144939061/4f8b864f-1f93-4488-9e33-547de7940cec">

### Тестирование вставки узлов
<img width="411" alt="test2" src="https://github.com/iis-32170x/RPIIS/assets/144939061/9d195183-0ed7-4cc6-b0ff-0a9fcfead48d">

### Тестирование удаления узлов
<img width="411" alt="test2" src="https://github.com/iis-32170x/RPIIS/assets/144939061/f599131e-921c-4880-b915-d2677cfb6a3a">

### Тестирование поиска минимального и максимального узлов
<img width="426" alt="test4" src="https://github.com/iis-32170x/RPIIS/assets/144939061/ab2c2e37-c357-4eb5-8f51-7be43990cff8">

### Тестирование поиска ближайших меньшего и большего узлов
<img width="515" alt="test5" src="https://github.com/iis-32170x/RPIIS/assets/144939061/e57584ab-af10-400e-a700-8b64920ad1fa">


## Вывод
Данная работа по реализации и тестированию AVL-дерева представляет собой комплексную задачу, включающую в себя не только программную реализацию структуры данных, но и её тщательное тестирование. Работа над этим проектом позволила глубже понять принципы работы с балансируемыми бинарными деревьями поиска, а также освоить методы их оптимизации и эффективного использования. В результате были достигнуты следующие ключевые моменты:

- Разработка и тестирование AVL-дерева способствовали углублённому пониманию механизмов самобалансировки деревьев и их влияния на эффективность операций поиска, вставки и удаления.

- В процессе работы над проектом были успешно реализованы и применены различные алгоритмы, связанные с балансировкой узлов, вращениями и поиском элементов в дереве, что улучшило навыки алгоритмического программирования.

- Тестирование реализации с помощью разнообразных сценариев показало важность комплексного подхода к проверке корректности работы структур данных и их методов. Визуализация структуры дерева после каждой операции была ключевым элементом в отладке и оптимизации реализации.

- Создание подробной документации и использование визуализации для демонстрации работы дерева обеспечили лучшее понимание структуры и логики AVL-дерева, а также способствовали облегчению процесса отладки и оптимизации.

- Реализованные методы и подходы к работе с AVL-деревом могут быть применены и адаптированы для других типов балансируемых бинарных деревьев, что делает код проекта полезным ресурсом для будущих разработок.
