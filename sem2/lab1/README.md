# <p align="center">Лабораторная работа №1</p>

Вариант 27.
Однонаправленный список. Вставка элемента в список. Удаление элемента из списка. Сортировка списка. Поиск элемента в списке.

## <p align="center">Цели лабораторной работы:</p>
1. Разработать библиотеку для работы с очередью  на выбранном императивном языке программирования (например, C++, Java, Python).
2. Создать тестовую программу для демонстрации функциональности разработанной библиотеки.
3. Разработать систему тестов для проверки работоспособности и корректности библиотеки, учитывая требования полноты, адекватности и непротиворечивости.
4. Обеспечить обработку некорректных данных, предусмотрев корректное завершение программы при возникновении ошибок.
5. Составить отчет по выполнению лабораторной работы.

## <p align="center">Задачи лабораторной работы:</p>
1. Изучить спецификацию задачи по работе с односвязанными списками.
2. Выбрать язык программирования для реализации библиотеки (например, C++, Java, Python) в соответствии с индивидуальным заданием.
3. Разработать и реализовать библиотеку для работы с очередью, включая операции вставки и извлечения элементов.
4. Написать тестовую программу, которая демонстрирует основные сценарии использования библиотеки.
5. Разработать систему тестов, включающую тест-кейсы для проверки различных аспектов работы библиотеки, включая корректность, производительность и обработку ошибок.
6. Провести тестирование разработанной библиотеки, убедившись в ее правильной работе на различных входных данных.
7. Составить подробный отчет, включая описание решения задачи, архитектуры библиотеки, результаты тестирования и выводы.

## <p align="center">Список используемых понятий:</p>
1. **Библиотека программного обеспечения (Библиотека кода):**
В программировании библиотека представляет собой совокупность программного кода, предназначенного для решения определенных задач. Этот код может содержать функции, классы, процедуры или другие компоненты, которые разработчики могут повторно использовать в своих программных проектах. Библиотеки упрощают разработку, так как они предоставляют готовые решения для типовых задач.
2. **Односвязанный список** (singly linked list) - это структура данных, которая представляет собой последовательность элементов, называемых узлами, связанными между собой с помощью ссылок. Каждый узел содержит данные и указатель (ссылку) на следующий узел в списке. Последний узел списка имеет ссылку, указывающую на nullptr, что означает конец списка.
3. **Библиотека cassert** в C++ предоставляет макрос assert, который используется для проверки предположений в программе и обнаружения ошибок во время выполнения.
4. **Класс** - это шаблон или определение, которое описывает состояние и поведение объектов. Он определяет набор свойств (переменных) и методов (функций), которые могут быть использованы для работы с объектами данного класса.

## <p align="center">Описание используемых алгоритмов:</p>
1. **Метод инициализации списка (List() ):**</p>
```cpp
template<typename T>
List<T>::List()
{
	Size = 0;
	head = nullptr;
}
```
2. **Метод деконструкции класса (~List() ):**</p>
```cpp
template<typename T>
List<T>::~List()
{
	clear();
}
```
3. **Метод очистки списка(clear() )**:</p>
```cpp
template<typename T>
void List<T>::clear()
{
	while (Size)
	{
		pop_front();
	}
}
```
4. **Метод удаления первого элемента (pop_front() )**:</p>
```cpp
template<typename T>
void List<T>::pop_front()
{
	Node<T>* temp = head;

	head = head->pNext;

	delete temp;

	Size--;

}
```
5. **Метод добавления элемента в конец списка (push_back() )**:</p>
```cpp
template<typename T>
void List<T>::push_back(T data)
{
	if (head == nullptr)
	{
		head = new Node<T>(data);
	}
	else
	{
		Node<T>* current = this->head;

		while (current->pNext != nullptr)
		{
			current = current->pNext;
		}
		current->pNext = new Node<T>(data);

	}

	Size++;
}
```
6. **Метод перегруженного оператора(operator[] )**:</p>
```cpp
template<typename T>
T& List<T>::operator[](const int index)
{
	int counter = 0;

	Node<T>* current = this->head;

	while (current != nullptr)
	{
		if (counter == index)
		{
			return current->data;
		}
		current = current->pNext;
		counter++;
	}
}
```
7. **Метод добавления элемента в начало списка (push_front() )**:</p>
```cpp
template<typename T>
void List<T>::push_front(T data)
{
	head = new Node<T>(data, head);
	Size++;
}
```   

