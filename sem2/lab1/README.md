# <p align="center">Лабораторная работа №1</p>

Вариант 22. Очередь. Вставка элемента в очередь. Взятие элемента из очереди.

## <p align="center">Цели лабораторной работы:</p>
1. Разработать библиотеку для работы с очередью  на выбранном императивном языке программирования (например, C++, Java, Python).
2. Создать тестовую программу для демонстрации функциональности разработанной библиотеки.
3. Разработать систему тестов для проверки работоспособности и корректности библиотеки, учитывая требования полноты, адекватности и непротиворечивости.
4. Обеспечить обработку некорректных данных, предусмотрев корректное завершение программы при возникновении ошибок.
5. Составить отчет по выполнению лабораторной работы.
   
## <p align="center">Задачи лабораторной работы:</p>
1. Изучить спецификацию задачи по работе с очередью.
2. Выбрать язык программирования для реализации библиотеки (например, C++, Java, Python) в соответствии с индивидуальным заданием.
3. Разработать и реализовать библиотеку для работы с очередью, включая операции вставки и извлечения элементов.
4. Написать тестовую программу, которая демонстрирует основные сценарии использования библиотеки.
5. Разработать систему тестов, включающую тест-кейсы для проверки различных аспектов работы библиотеки, включая корректность, производительность и обработку ошибок.
6. Провести тестирование разработанной библиотеки, убедившись в ее правильной работе на различных входных данных.
7. Составить подробный отчет, включая описание решения задачи, архитектуры библиотеки, результаты тестирования и выводы.

## <p align="center">Список используемых понятий:</p>
1. **Библиотека программного обеспечения (Библиотека кода):**
В программировании библиотека представляет собой совокупность программного кода, предназначенного для решения определенных задач. Этот код может содержать функции, классы, процедуры или другие компоненты, которые разработчики могут повторно использовать в своих программных проектах. Библиотеки упрощают разработку, так как они предоставляют готовые решения для типовых задач.
2. **Класс std::queue<T>** представляет **очередь** - контейнер, который работает по принципу FIFO (first-in first-out или "первый вошел — первым вышел") — первым всегда извлекается первый добавленный элемент. То есть это контейнер, аналогичный стандартной очереди, которая часто встречается в нашей повседневной жизни.
3. **Библиотека stdexcept** в C++ предоставляет классы исключений, которые могут быть брошены во время выполнения программы для сигнализации об ошибках.
4. **Библиотека vector** в C++ является частью стандартной библиотеки и предоставляет контейнерный класс std::vector, который реализует динамический массив. Векторы (std::vector) обеспечивают удобное хранение и управление последовательностью элементов.
5. **Библиотека cassert** в C++ предоставляет макрос assert, который используется для проверки предположений в программе и обнаружения ошибок во время выполнения.
6. **Исключение `std::out_of_range`:**
   Исключение, используемое в C++, чтобы сигнализировать о выходе индекса за пределы допустимого диапазона. В данном контексте, используется для обработки попыток извлечения из пустой приоритетной очереди.
## <p align="center">Описание используемых алгоритмов:</p>
1. **Метод вставки (enqueue):**
   Этот метод добавляет элемент в конец вектор
```cpp
void Queue::enqueue(int value) {
    queue.push_back(value);
}
```
2.**Метод удаления (dequeue):**
Метод dequeue() удаляет и возвращает первый элемент из очереди. Если очередь пустая (проверяется с помощью метода isEmpty()), метод бросает исключение std::out_of_range("Queue is empty"). В противном случае, метод возвращает значение первого элемента queue[frontIndex], увеличивает frontIndex на 1 и тем самым сдвигает "фронт" очереди
```cpp
int Queue::dequeue() {
    if (isEmpty()) {
        throw std::out_of_range("Queue is empty");
    }

    int value = queue[frontIndex];
    frontIndex++;
    return value;
}
```
3. **Метод проверки пустой очереди (isEmpty):**
Метод isEmpty() проверяет, является ли очередь пустой. Он возвращает true, если frontIndex больше или равен размеру вектора queue, иначе возвращает false.
```cpp
bool Queue::isEmpty() const {
    return frontIndex >= queue.size();
}
```
4.**Метод взятия (front):**
Метод front() возвращает значение первого элемента очереди без его удаления. Если очередь пустая, метод бросает исключение std::out_of_range("Queue is empty"). В противном случае, метод возвращает значение queue[frontIndex]
```cpp
int Queue::front() const {
    if (isEmpty()) {
        throw std::out_of_range("Queue is empty");
    }

    return queue[frontIndex];
}
```
5.**Метод размера (size):**
Метод size() возвращает текущий размер очереди, что равно разнице между размером вектора queue и frontIndex.
```cpp
int Queue::size() const {
    return queue.size() - frontIndex;
}

```
6.**Метод очистки (clear):**
 Метод clear() очищает очередь, устанавливая frontIndex в 0 и вызывая метод clear() вектора queue. Это приводит к удалению всех элементов вектора и сбросу индекса первого элемента в очереди.
 ```cpp
void Queue::clear() {
    frontIndex = 0;
    queue.clear();
}
```
## <p align="center">Результаты тестирования:</p>
Тестирование проводилось с помощью библиотеки cassert, которая предоставляет макрос assert, который используется для проверки предположений в программе и обнаружения ошибок во время выполнения.
Когда вы включаете <cassert> в свою программу, вы получаете доступ к макросу assert. Макрос assert принимает выражение в качестве аргумента и проверяет его на истинность. Если выражение является ложным (имеет значение false), то assert генерирует сообщение об ошибке и аварийно завершает программу. Если выражение истинно (имеет значение true), то assert ничего не делает и программа продолжает выполнение.
 ```cpp
#include <iostream>
#include <cassert>
#include "queue.h"

int main() {
    setlocale(LC_ALL, "RU");
    Queue queue;

    // Тест 1: Проверка пустой очереди
    assert(queue.isEmpty());
    std::cout << "Тест 1 пройден" << std::endl;

    // Тест 2: Добавление элементов в очередь
    queue.enqueue(10);
    queue.enqueue(-20);
    queue.enqueue(30);
    std::cout << "Тест 2 пройден" << std::endl;

    // Тест 3: Проверка размера очереди
    assert(queue.size() == 3);
    std::cout << "Тест 3 пройден" << std::endl;

    // Тест 4: Проверка элемента в начале очереди
    assert(queue.front() == 10);
    std::cout << "Тест 4 пройден" << std::endl;

    // Тест 5: Извлечение элементов из очереди
    assert(queue.dequeue() == 10);
    assert(queue.dequeue() == -20);
    std::cout << "Тест 5 пройден" << std::endl;

    // Тест 6: Проверка размера очереди после извлечения
    assert(queue.size() == 1);
    std::cout << "Тест 6 пройден" << std::endl;

    // Тест 7: Проверка элемента в начале очереди после извлечения
    assert(queue.front() == 30);
    std::cout << "Тест 7 пройден" << std::endl;

    // Тест 8: Извлечение последнего элемента и проверка пустоты очереди
    assert(queue.dequeue() == 30);
    assert(queue.isEmpty());
    std::cout << "Тест 8 пройден" << std::endl;

    // Тест 9: Тест на добавление и извлечение большого количества элементов
    for (int i = 0; i < 1000; ++i) {
        queue.enqueue(i);
    }
    assert(queue.size() == 1000);
    for (int i = 0; i < 1000; ++i) {
        assert(queue.dequeue() == i);
    }
    assert(queue.isEmpty());
    std::cout << "Тест 9 пройден" << std::endl;

    // Тест 10: Тест на очистку очереди
    queue.enqueue(10);
    queue.enqueue(20);
    queue.enqueue(30);
    assert(!queue.isEmpty());
    queue.clear();
    assert(queue.isEmpty());
    std::cout << "Тест 10 пройден" << std::endl;

    // Тест 11: Попытка извлечения элемента из пустой очереди
    assert(queue.isEmpty());
    try {
        queue.dequeue();
        // Если извлечение прошло успешно, тест не пройден
        std::cout << "Тест 11 не пройден" << std::endl;
    }
    catch (...) {
        // Если было сгенерировано исключение, то тест пройден
        std::cout << "Тест 11 пройден" << std::endl;
    }

    std::cout << "Все тесты пройдены!" << std::endl;

    return 0;
}
```

Результат выполнения:

![image](https://github.com/iis-32170x/RPIIS/assets/144383538/5d494f17-9e57-46e8-84a0-165e039bc438)

## <p align="center">Вывод:</p>
В ходе выполнения работы познакомился созданием библиотек в С++, реализоавал библиотеку очереди,а также создал систему тестов,которая проверяет корректность созданной библиотеки, отточил свои навыки в создании классов и функций.
## <p align="center">Используемые источники:</p>
1.https://www.youtube.com/watch?v=5mD-rhaYF4U&t=209s (создание библиотеки).
2.https://www.youtube.com/watch?v=pAxEfF2yVlM&t=310s (про заголовочные файлы)
3.https://chat.openai.com (помощь в освоении материала)
4.https://www.youtube.com/watch?v=2lumODP7BtI&t=509s (объснение очереди)
