# Лабораторная работа №1

## Задача:
Разработать библиотеку для работы с красно-черными деревьями. Вставка. Удаление. Поиск. Поиск минимума,
максимума, ближайшего большего и ближайшего меньшего.
## Цель:
Исследовать свойства структур данных и разработать
библиотеку алгоритмов обработки структур данных.

## Список ключевых понятий:
* ***Красно-черное дерево*** — двоичное дерево поиска, в котором каждая вершина дополнительно хранит информацию о своём цвете, который принимает только два значения: "красный" и "чёрный".
* ***Чёрная высота*** - количество **чёрных вершин** дерева на пути к одному из его листов.

## Свойства Красно-черного дерева:
Чтобы дерево считалось красно-черным, необходимо не только наличие в нём красных и черных вершин, но и выполнение следующих свойств:
1. Каждый узел дерева является красным или чёрным.
2. Корень дерева является черным.
3. Каждый лист дерева является черным.
4. Если узел - красный, то оба его дочерних узла - черные.
5. Для каждого узла все пути от него до листьев, являющихся его потомками, содержат одно и то же количество черных узлов.

**Для того, чтобы дерево оставалось красно-черным, необходимо выполнение всех его свойств!**

## Функции библиотеки:
1. Функция `void insertNode(Node*& root, int key)`. Вставка вершины.
    * Принимает аргументы `root` - корень дерева, в которое встявлется вершина и `key` - ключ вставляемой вершины.
    * Осуществляет поиск места для вставки в дерево `root`, основаясь на ключе `key`.
    * Создает новую вершину в подходящем месте. Цвет добавленной вершины всегда красный.
    * После добавления вершины вызывает функцию `insert_fix`, которая обеспечивает сохранение красно-черных свойств дерева.
    * Если вершина с таким ключом уже существует в дереве, функция возвращает соответсвующее сообщение и вставки не происходит.
  
2. Функция `void insert_fix(nodetmp->right, root)`. Исправление последствий вставки.
    * Принимает аргументы `node` - указатель на вершину, которую вставили и `root` - корень дерева, в которое вставлялась вершина.
    * Осуществляет алгоритмы поворотов и перекраски вершин в соответствии с условиями, полученными при вставке вершины.
      
3. Функция `void deleteNode(Node*& root, int key)`. Удаление вершины.
     * Принимает аргументы `root` - корень дерева, в котором удаляется вершина, `key` - ключ удаляемой вершины.
     * Осуществляет поиск заданной вершины по ключу.
     * Вызывает функцию `del`, которая осуществляет непосредственное удаление вершины.

4. Функция `void del(Node*& root, Node* node)`. Перестройка дерева для сохранения его свойств и удаление вершины.
    * Принимает аргументы `root` - корень дерева, в котором вершина удаляется и `node` - указатель на удаляемую вершину.
    * Осуществляет алгоритмы поворотов и перекраски вершин в соответствии с условиями, при которых вершина удаляется.
    * Вызывает функцию `clearNode` для непосредственного удаления вершины.
      
5. Функция `void clearNode(Node* node)`. Непосредственное удаление вершины.
    * Принимает аргументы `node` - указатель на удаляемую вершину.
    * Окончательно стирает вершину и очищает занимаемую ей память.
      
6. Функция `void left_rotate(Node*& root, int key)`. Алгоритм левого поворота.
    * Принимает аргументы `root` - корень дерева, в котором совершается поворот и `node` - указатель на вершину, вокруг которой совершается поворот.
    * Осуществляет левый поворот вокруг вершины с ключом `key`.
      
7. Функция `void right_rotate(Node*& root, int key)`. Алгоритм правого поворота.
    * Принимает аргументы `root` - корень дерева, в котором совершается поворот и `node` - указатель на вершину, вокруг которой совершается поворот.
    * Осуществляет правый поворот вокруг вершины с ключом `key`.
      
8. Функция `Node* find(Node* root, int key)`. Алгоритм поиска вершины.
    * Принимает аргументы `root` - корень дерева, в котором совершается поиск вершины и `key` - ключ вершины, поиск которой соверщается.
    * Возвращает указатель на вершину с заданным ключом.
    * Возвращает `nullptr`, если искомой вершины в дереве нет.
      
9. Функция `int find_max(Node* root)`. Алгоритм поиска вершины c максимальным по значению ключом.
    * Принимает аргументы `root` - корень дерева, в котором совершается поиск вершины.
    * Возвращает указатель на вершину с максимальным по значению ключом.
      
10. Функция `int find_min(Node* root)`. Алгоритм поиска вершины c минимальным по значению ключом.
    * Принимает аргументы `root` - корень дерева, в котором совершается поиск вершины.
    * Возвращает указатель на вершину с минимальным по значению ключом.
    
11. Функция `int find_nearest_max(Node* root, int key)`. Алгоритм поиска ближайшей большей вершины по значению ключа.
    * Принимает аргументы `root` - корень дерева, в котором совершается поиск вершины и `key` - ключ вершины, для которой выполняется поиск ближайшей большей.
    * Возвращает ключ искомой вершины.
      
12. Функция `int find_nearest_min(Node* root, int key)`. Алгоритм поиска ближайшей меньшей вершины по значению ключа.
    * Принимает аргументы `root` - корень дерева, в котором совершается поиск вершины и `key` - ключ вершины, для которой выполняется поиск ближайшей меньшей.
    * Возвращает ключ искомой вершины.
    
13. Функция `void printInorder(Node* root)`. Вывод дерева в консоль.
    * Принимает аргументы `root` - корень дерева.
    * Выводит в консоль информацию о всех узлах дерева.

## Описание алгоритмов:

***Родственные связи вершины (напр. дядя, родитель, брат, племянник), относительно которой выполняется алгоритм определяются по исходной структуре поддерева и не изменяются при описании алгоритма. То есть, например, если некоторая вершина, являющаяся родителем рассматриваемой вершины, изменила свои родственные связи с ней и стала её племянником, то, несмотря на это, при дальнейшем описании алгоритма она будет называться родителем вершины.***

### Вставка вершины
1. Поиск нулевого узла для вставки, путём сравнения ключей.
2. Вставка красной вершины, без учета свойств красно-черного дерева.
   
### Исправление дерева после вставки

#### 1. Родитель вставляемой вершины - черный
В этом случае при вставке вершины никакие свойства красно-черного дерева не нарушаются, то есть дополнительные действия не требуются.

#### 2. Родитель вставляемой вершины - красный
В таком случае возникает проблема двух красных узлов. Алгоритм исправления данного случая зависит от "дяди" вставляемой вершины.

##### 2.1 Родитель - красный. Дядя - черный.
В данном случае происходит следующее:
1. Вокруг родителя узла совершается левый поворот (если вершина вставляется справа от родителя, если же вершина - левый потомок, то совершается правый поворот)
2. Родитель вершины становится черным.
3. Дедушка вершины становится красным. 
   
##### 2.2 Родитель - красный. Дядя - красный.
Решение данного случая ограничивается только перекраской.
1. Родитель вершины становится черным.
2. Дядя вершины становится черным.
3. Дедушка вершины становится красным.

   
*Однако, так как цвет узла рассматриваемого поддерева изменился, то красно-черные свойства всё ещё могут быть нарушены, а конкретно: снова может возникнуть проблема двух красных узлов. Поэтому мы должны проверить: является ли предок родителя вершины красным. Если да, то мы должны повторить с самого начала алгоритм исправления после вставки, но уже для родителя вершины.*

### Удаление вершины
#### 1. Удаление красной вершины без потомков
В случае удаления такой вершины никакие свойства красно-черного дерева не нарушаются. Достаточно просто стереть вершину из дерева.

#### 2. Удаление черной вершины без потомков
Удаление в таком случае разделяется на 6 случаев. Алгоритм удаления зависит от цвета определённых вершин.

***Ниже будут описаны алгоритмы для случаев, когда удаляемая вершина находится справа от потомка, а также в конкретных случаях расположения других вершин. Если структура поддерева зеркальна случаям описанным ниже, то операции левого и правого поворота будут меняться местами, то есть: если для вершины необходимо было совершить левый поворот, то в зеркальном случае уже будет необходимо совершить правый поворот и наоборот. Также возможны ситуации, когда нет необходимости выполнять первый поворот из алгоритма, а нужно сразу выполнить второй, так как поддерево уже находится в состоянии, к которому его должен был привести первый поворот. В отчете описаны полные случаи алгоритмов.*** 

##### 1. Если цвет родителя удаляемой вершины - красный
Дальнейшие действия зависят от наличия у брата вершины красного потомка.

##### 1.1 Если у брата есть хотя бы один красный потомок
В таком случае мы должны выполнить ***левый поворот*** вокруг брата удаляемого узла и затем ***правый поворот*** для его родителя, а после стереть вершину.

##### 1.2 У брата нет красных потомков
Здесь достаточно выполнить только перекраску: родителя окрасить в чёрный, а брата - в красный, а после стереть вершину.

##### 2. Если цвет родителя удаляемой вершины - черный
В таком случае дальнейшие действия зависят от нескольких факторов: цвет брата вершины, наличие/отсутствие у племянника вершины красных потомков, цвет племянника.

##### 2.1 Брат удаляемой вершины - красный
Далее мы должны определить: есть ли у племянника красные потомки?

##### 2.1.1 Племянник вершины имеет хотя бы одного красного потомка
В таком случае мы выполняем ***левый поворот*** вокруг брата вершины, а затем ***правый поворот*** вокруг родителя вершины. После перекрашиваем красных потомков племянника в черный и стираем удаляемую вершину.

##### 2.1.2 Племянник вершины не имеет красных потомков
Здесь необходмо выполнить ***правый поворот*** вокруг родителя вершины. Далее нужно перекрасить брата вершины в черный, а племянника - в красный, а после - стереть вершину.

##### 2.2 Брат удаляемой вершины - черный
В таком случае необходимо проверить: существуют ли у брата вершины красные потомки.

##### 2.2.1 Брат вершины имеет хотя бы одного красного потомка
В таком случае необходимо снача выполнить ***левый поворот*** вокруг брата вершины, затем ***правый поворот*** вокруг родителя вершины. После необходимо перекрасить племянника в черный и стереть вершину.

##### 2.2.2 Брат вершины не имеет красных потомов
Тут все просто, необходимо только перекрасить брата вершины в красный и стереть вершину.

#### 3. Удаление вершины с потомком
Алгоритм в таком случае не зависит от цвета вершины. Здесь для удаляемой вершины находится ближайшее меньшее или ближайшее большее значение в дереве. Затем найденная вершина меняется местами с удаляемой, при этом проиходит обмен цветом, и последняя просто затирается.

## Тестирование программы:

Для тестирования программы использовалась `<cassert>`. Суть тестов заключалась в том, чтобы в ручную воспроизвести вставку, удаление и поиск вершин, а затем сравнить полученные результаты с теми, что даёт нам программа. 

### Код программы для тестирования:
```c++
/*1й тест*/ 
insertNode(root, 25);	 //В случае вставки первой некорневой вершины, она всегда остаётся красной
assert(find(root, 25)->IsRed);

cout << "Первый тест пройден успешно.\n";
```

*изображение*

```c++
/*2й тест*/
insertNode(root, 17);
insertNode(root, 23); //В случае вставки таких вершин в таком порядке, вершина 25 перекрасится в чёрный
insertNode(root, 28);
assert(!find(root, 25)->IsRed);

cout << "Второй тест пройден успешно.\n";
```

*изображение*

```c++
/*3й тест*/
insertNode(root, 12);
insertNode(root, 8); //После вставки вершин с ключами 12 и 8, левым потомком главного узла должен стать узел с ключом 12
assert(root ->left-> key == 12);

cout << "Третий тест пройден успешно.\n";
```

*изображение*

```c++
/*4й тест*/
insertNode(root, 19); //После вставки узла с ключом 19, левый потомок от главного узла должен перекраситься в красный цвет
assert(root->left->IsRed = 1);

cout << "Четвёртый тест пройден успешно.\n";

/*5й тест*/
assert(find_max(root) == 28 ); //Поиск максимального элемента в дереве, в нашем случае это - 28
cout << "Пятый тест пройден успешно.\n";

/*6й тест*/
assert(find_min(root) == 8); //Поиск минимального элемента в дереве, в нашем случае это - 8
cout << "Шестой тест пройден успешно.\n";

/*7й тест*/
assert(find_nearest_min(root, 20) == 19); //Поиск ближайшего меньшего элемента для вершины 20, в нашем этим элементом будет 19
cout << "Седьмой тест пройден успешно.\n";

/*8й тест*/
assert(find_nearest_max(root, 20) == 23); //Поиск ближайшего большего элемента для вершины 20, в нашем этим элементом будет 23
cout << "Восьмой тест пройден успешно.\n";

/*9й тест*/
assert(find(root, 40) == nullptr); //Поиск несуществующей вершины в дереве, ожидая получить nullptr
cout << "Девятый тест пройден успешно.\n";
```

*изображение*
