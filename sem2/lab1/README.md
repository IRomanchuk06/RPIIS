# Лабораторная работа №1

## Задача:
Реализовать B-Дерево. Поиск. Вставка. Удаление.
## Цель:
Исследовать свойства структур данных и разработать
библиотеку алгоритмов обработки структур данных.

## Список ключевых понятий:
* $\textcolor{#4b0082}{\textbf{В-дерево}}$ — это структура данных, сбалансированное дерево поиска, в котором каждый узел содержит множество ключей и имеет более двух потомков. С точки зрения внешнего логического представления — сбалансированное, сильно ветвистое дерево. Часто используется для хранения данных во внешней памяти.
  $\textcolor{#9370db}{\textit{Здесь количество ключей в узле и количество его потомков зависит от порядка B-дерева. Каждое B-дерево имеет порядок.}}$
* $\textcolor{#4b0082}{\textbf{Сбалансированность}}$ означает, что длины любых двух путей от корня до листьев различаются не более, чем на единицу.
* $\textcolor{#4b0082}{\textbf{Ветвистость дерева}}$ — это свойство каждого узла дерева ссылаться на большое число узлов-потомков.

## Свойства:

![B-tree-definition](https://github.com/iis-32170x/RPIIS/assets/145003765/059c5f1d-71cd-45d0-be0f-f8bc1cea32d7)


B-дерево порядка **m** обладает следующими свойствами:

* $\textcolor{#d8bfd8}{\textit{Свойство 1:}}$ Глубина всех листьев одинакова.
* $\textcolor{#d8bfd8}{\textit{Свойство 2:}}$ Все узлы, кроме корня должны иметь как минимум (m/2) – 1 ключей и максимум m-1 ключей.
* $\textcolor{#d8bfd8}{\textit{Свойство 3:}}$ Все узлы без листьев, кроме корня (т.е. все внутренние узлы), должны иметь минимум m/2 потомков.
* $\textcolor{#d8bfd8}{\textit{Свойство 4:}}$ Если корень – это узел не содержащий листьев, он должен иметь минимум 2 потомка.
* $\textcolor{#d8bfd8}{\textit{Свойство 5:}}$ Узел без листьев с n-1 ключами должен иметь n потомков.
* $\textcolor{#d8bfd8}{\textit{Свойство 6:}}$ Все ключи в узле должны располагаться в порядке возрастания их значений.

*****
Ключи в каждом узле обычно упорядочены для быстрого доступа к ним. Корень содержит от **1** до **2t-1** ключей. Любой другой узел содержит от **t-1** до **2t-1** ключей. Листья не являются исключением из этого правила. Здесь **t** — *параметр дерева*, не меньший 2 
*****

## Алгоритмы операций над В-деревом

### **Поиск по В-дереву**

Поиск по B-дереву аналогичен поиску по двоичному дереву поиска. В двоичном дереве поиска поиск начинается с корня и каждый раз принимается двустороннее решение (пойти по левому поддереву или по правому). В В-дереве поиск также начинается с корневого узла, но на каждом шаге принимается n-стороннее решение, где n – это общее количество потомков рассматриваемого узла. В В-дереве сложность поиска составляет O(log n). Поиск происходит следующим образом:

* $\textcolor{#9370db}{\textit{Шаг 1:}}$ Считать элемент для поиска.
* $\textcolor{#9370db}{\textit{Шаг 2:}}$ Сравнить искомый элемент с первым значением ключа в корневом узле дерева.
* $\textcolor{#9370db}{\textit{Шаг 3:}}$ Если они совпадают, вывести: «Искомый узел найден!» и завершить поиск.
* $\textcolor{#9370db}{\textit{Шаг 4:}}$ Если они не совпадают, проверить больше или меньше значение элемента, чем текущее значение ключа.
* $\textcolor{#9370db}{\textit{Шаг 5:}}$ Если искомый элемент меньше, продолжить поиск по левому поддереву.
* $\textcolor{#9370db}{\textit{Шаг 6:}}$ Если искомый элемент больше, сравнить элемент со следующим значением ключа в узле и повторять Шаги 3, 4, 5 и 6 пока не будет найдено совпадение или пока искомый элемент не будет сравнен с последним значением ключа в узле-листе.
* $\textcolor{#9370db}{\textit{Шаг 7:}}$ Если последнее значение ключа в узле-листе не совпало с искомым, вывести «Элемент не найден!» и завершить поиск.

 ***Основная функция поиска ключа в В-дереве***

``` c++
BTreeNode* BTreeNode::search_key(int k)
{
	int i = 0;
	while (i < n && k > keys[i])
		i++;

	if (keys[i] == k)
		return this;

	if (leaf == true)
		return NULL;

	return C[i]->search_key(k);
}
```
*****
### **Операция вставки в B-дерево**

  В В-дереве новый элемент может быть добавлен только в узел-лист. Это значит, что новая пара ключ-значение всегда добавляется только к узлу-листу. Вставка происходит следующим образом:

* $\textcolor{#9370db}{\textit{Шаг 1:}}$ Проверить пустое ли дерево.
* $\textcolor{#9370db}{\textit{Шаг 1:}}$ Если дерево пустое, создать новый узел с новым значением ключа и его принять за корневой узел.
* $\textcolor{#9370db}{\textit{Шаг 1:}}$ Если дерево не пустое, найти подходящий узел-лист, к которому будет добавлено новое значение, используя логику дерева двоичного поиска.
* $\textcolor{#9370db}{\textit{Шаг 1:}}$ Если в текущем узле-листе есть незанятая ячейка, добавить новый ключ-значение к текущему узлу-листу, следуя возрастающему порядку значений ключей внутри узла.
* $\textcolor{#9370db}{\textit{Шаг 1:}}$ Если текущий узел полон и не имеет свободных ячеек, разделите узел-лист, отправив среднее значение родительскому узлу. Повторяйте шаг, пока отправляемое значение не будет зафиксировано в узле.
* $\textcolor{#9370db}{\textit{Шаг 1:}}$ Если разделение происходит с корнем дерева, тогда среднее значение становится новым корнем дерева и высота дерева увеличивается на единицу.

***Основная функция вставки ключа в В-дерево***

``` c++
void BTree::insert_key(int k)
{
	if (root == NULL)
	{
		root = new BTreeNode(t, true);
		root->keys[0] = k; 
		root->n = 1; 
	}
	else 
	{
		if (root->n == 2 * t - 1)
		{
			BTreeNode* s = new BTreeNode(t, false);
			s->C[0] = root;
			s->splitChild(0, root);
 
			int i = 0;
			if (s->keys[0] < k)
				i++;
			s->C[i]->insertNonFull(k);

			root = s;
		}
		else 
			root->insertNonFull(k);
	}
}
```
*****
### **Операция удаления в B-дереве**  

Удаление из B-дерева сложнее, чем вставка, поскольку мы можем удалить ключ из любого узла, а не только из листа, и когда мы удаляем ключ из внутреннего узла, нам придется переупорядочить дочерние узлы этого узла. 

#####   Случай 1

* Если ключ k находится в узле x, а x является листом, удаляем ключ k из x.

#####   Случай 2

* Если ключ k находится в узле x, а x является внутренним узлом, выполняем следующие действия.
    * Если дочерний элемент y, который предшествует k в узле x, имеет как минимум t ключей, то находим предшественника k0 узла k в поддереве с корнем в y. Рекурсивно удаляем k0 и заменяем k на k0 в x. 
    * Если у y меньше t ключей, то симметрично проверяем дочерний элемент z, следующий за k в узле x. Если z имеет хотя бы t ключей, то находим преемника k0 для k в поддереве с корнем в z. Рекурсивно удаляем k0 и заменяем k на k0 в x. 
    * В противном случае, если и y, и z имеют только t-1 ключей, объединяем k и все z с y, так что x потеряет и k, и указатель на z, и y теперь будет содержать 2t-1 ключей. Затем освобождаем z и рекурсивно удаляем k из y.

  
#####   Случай 3

* Если ключ k отсутствует во внутреннем узле x, определяем корень xc(i) соответствующего поддерева, которое должно содержать k, если k вообще присутствует в дереве.
   * Если у xc(i) есть только t-1 ключей, но у него есть непосредственный брат с хотя бы t ключами, даём xc(i) дополнительный ключ, переместив ключ из x вниз в xc(i), переместив ключ из xc(i) ) непосредственный левый или правый одноуровневый элемент вверх по x и перемещает соответствующий дочерний указатель из одноуровневого элемента в xc(i).
   * Если xc(i) и оба непосредственных одноуровневых узла xc(i) имеют ключи t-1, объединяем xc(i) с одним одноуровневым, что предполагает перемещение ключа от x вниз в новый объединенный узел, чтобы он стал медианным ключом для этот узел.

***Основная функция удаления ключа из В-деревa***

``` c++
void BTreeNode::delete_key(int k)
{
	int idx = findKey(k);
	
	if (idx < n && keys[idx] == k)
	{
		if (leaf)
			delete_from_leaf(idx);
		else
			delete_from_nonleaf(idx);
	}
	else
	{
		if (leaf)
		{
			cout << "The key " << k << " is does not exist in the tree\n";
			return;
		}
		bool flag = ((idx == n) ? true : false);
  
		if (C[idx]->n < t)
			fill(idx);
		
		if (flag && idx > n)
			C[idx - 1]->delete_key(k);
		else
			C[idx]->delete_key(k);
	}
	return;
}
```
## Результаты тестирования (GoogleTest)

В программах тестирования были проведены тесты над основными операциями над В-деревьями с различными параметрами

***Тест 1. В-дерево с параметром 3***

![Снимок экрана 2024-03-10 115333](https://github.com/iis-32170x/RPIIS/assets/145003765/fa3c3374-cc3e-43f0-ab2f-6f15b7bb9a62)


***Тест 2. В-дерево с параметром 4***

![Снимок экрана 2024-03-10 115246](https://github.com/iis-32170x/RPIIS/assets/145003765/0c45a456-9b9a-4a6b-8b62-11c0dcf2393e)



***Тест 3. В-дерево с параметром 5***

![Снимок экрана 2024-03-10 114852](https://github.com/iis-32170x/RPIIS/assets/145003765/3012a47b-a528-4f63-9271-77a98cd57d9f)


**Итог**  все тесты пройдены успешно!

## Примеры выполнения программы

* Дерево заполняется автоматически при помощи функции rand()

![Снимок экрана 2024-03-09 201807](https://github.com/iis-32170x/RPIIS/assets/145003765/9234c8bf-5eaa-4510-a9d2-6f58c234a693)


* Дерево заполняется в коде

![Снимок экрана 2024-03-09 201609](https://github.com/iis-32170x/RPIIS/assets/145003765/3b15850a-77c1-4362-b15b-22c8bdeec156)

## Список использованных источников: 
* https://www.cs.usfca.edu/~galles/visualization/BTree.html
* https://ru.wikipedia.org/wiki/B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE
* https://habr.com/ru/companies/otus/articles/459216/
* https://habr.com/ru/articles/114154/
