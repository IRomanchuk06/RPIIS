# Лабораторная работа №1 

![image](https://github.com/iis-32170x/RPIIS/assets/135509020/570a9b15-2e67-4c18-b04e-9f8e5f663851)

# Задача:

Удаление вершины, вставка вершины, удаление дуги(ребра), вставка дуги(ребра), построение дерево обхода в глубину неориентированного графа

# Цель:

Исследовать свойства структур данных и разработать библиотеку алгоритмов обработки структур данных.

## Список ключевых понятий:
* <em>Граф</em> - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями. Граф как математический объект есть совокупность двух множеств — множества самих объектов, называемого множеством вершин, и множества их парных связей, называемого множеством рёбер. Элемент множества рёбер есть пара элементов множества вершин.
* <em>Неориентированный граф</em> - граф, ребра в котором имеют <em>неориентированную природу</em>, что значит, что ребро <a,b> есть так же ребро <b,a>.
* <em>Дерево обхода в глубину (поиск-в-глубину)</em> - один из методов обхода графа. Стратегия поиска в глубину, как и следует из названия, состоит в том, чтобы идти «вглубь» графа, насколько это возможно.
* <em>Ребро ( дуга )</em> - одно из множеств графа, служащее в качестве связи между вершинами
* <em>Вершина</em> - одно из множеств графа, задающее структуру графа
* <em>Матрица инцидентности</em> - способ представления графа, в котором стобцами и строками матрицы служат вершины графа, а наличие или отсутствие 0 или 1 на пересечении вершин означает отсутствие или наличие инцидентности (связи) между вершинами. 0 - вершины не инцидентны, 1 - вершины инцидентны.

## Алгоритмы действий над неориентированным графом

### Удаление/вставка вершины 

Алгоритм удаления/вставки n-ой вершины прост:
- Шаг 1: Обнулить n-ую строку
- Шаг 2: Обнулить n-ый столбец
- Шаг 3: Перенести соответствующие значения полей с единицами (1), в верхнюю освободившуюся строчку, для значений строк
- Шаг 4: Перенеси соотвтетствующие значения полей с единицами (1), в левый освободившийся столбец, для значений столбцов
- Шаг 5: Удалить последнюю строчку
- Шаг 6: Удалить последний столбец

### Программная реализация и пример работы

Реализация:
```c++
vector<vector<int>> ADD_VERTICE() {
    vector<vector<int>> matrix;
    matrix = adjacent_m;
    matrix.resize(adjacent_m.size() + 1);
    for (int i = 0; i < matrix.size(); i++) {
        matrix[i].resize(adjacent_m.size() + 1,0);
    }
    adjacent_m = matrix;
    return adjacent_m;
}
vector<vector<int>> RM_VERTICE(int node_to_rm) {
    vector<vector<int>> matrix;
    matrix = adjacent_m;
    if (!matrix.empty()) {
        if (node_to_rm - 1 >= 0 && node_to_rm - 1 < matrix.size()) {
            matrix.erase(matrix.begin() + node_to_rm - 1);
            for (int i = 0; i < matrix.size(); i++) {
                if (!matrix[i].empty() && node_to_rm - 1 >= 0 && node_to_rm - 1 < matrix[i].size()) {
                    matrix[i].erase(matrix[i].begin() + node_to_rm - 1);
                }
            }
        }
    }
```
Программа выполняется в соответствии с описанным алгоритмом.

#### Пример: 

Изначально граф представлен такой матрицей смежности:

![image](https://github.com/iis-32170x/RPIIS/assets/135509020/aaceff66-7495-4d7a-916b-008118613a60)

Добавление вершины:

![image](https://github.com/iis-32170x/RPIIS/assets/135509020/c0aa34de-6880-4928-bef6-80478170c763)

Удаление 3 - ей вершины:

![image](https://github.com/iis-32170x/RPIIS/assets/135509020/814956d7-80ea-4159-a4a3-c675653bd04d)

### Удаление/вставка дуги (ребра)

Алгоритм удаления/вставки n-ой дуги (ребра) прост:
- Шаг 1: Вписать 1(0) в соответствующую ячейку матрицы, находящуюся на пересечении 1-ой вершины по строкам и 2-ой вершины по столбцам
- Шаг 2: Вписать 1(0) в соответствующую ячейку матрицы, находящуюся на пересечении 1-ой вершины по столбцам и 2-ой вершины по строкам

### Программная реализация и пример работы

Реализация:

```c++
vector<vector<int>> ADD_EDGE(int node1, int node2) {
    adjacent_m[node1-1][node2-1] = 1;
    adjacent_m[node2-1][node1-1] = 1;
    return adjacent_m;

}
vector<vector<int>> RM_EDGE(int node1, int node2) {
    adjacent_m[node1 - 1][node2 - 1] = 0;
    adjacent_m[node2 - 1][node1 - 1] = 0;
    return adjacent_m;
}
```
Программа выполняется в соответствии с описанным алгоритмом.

#### Пример: 

Изначально граф представлен той же матрицей смежности

Добавление дуги между 5-ой и 6-ой вершиной:

![image](https://github.com/iis-32170x/RPIIS/assets/135509020/22d563ed-03b1-4cdf-bd89-2dd634d3693b)

Удаление дуги между 2-ой и 4-ой вершиной:

![image](https://github.com/iis-32170x/RPIIS/assets/135509020/38961065-9c81-42ee-a356-8df4398c52f6)

### Построение дерева обхода графа в глубину

Алгоритм построения дерева обхода графа в глубину:

- Шаг 1: Перебираем все исходящие из рассматриваемой вершины рёбра.
- Шаг 2: Если ребро ведёт в вершину, которая не была рассмотрена ранее, то запускаем алгоритм от этой нерассмотренной вершины, а после возвращаемся и продолжаем перебирать рёбра.
- Шаг 3: Возврат происходит в том случае, если в рассматриваемой вершине не осталось рёбер, которые ведут в нерассмотренную вершину.
- Шаг 4: Если после завершения алгоритма не все вершины были рассмотрены, то необходимо запустить алгоритм от одной из нерассмотренных вершин.

В результате должен быть получен массив, отсортированный в порядке просмотра вершин.

### Программная реализация и пример работы

Реализация:

```c++
vector<int> DFS_TREE(int node_to_start) {
    int current = node_to_start;
    not_visited.insert(not_visited.begin(), current);
    while (!not_visited.empty()) {
        visited.push_back(current);
        not_visited.erase(not_visited.begin());
        for (int i = adjacent_m.size()-1; i >= 0;i--) {
            if (adjacent_m[current][i] != 0 && i != current && find(not_visited.begin(), not_visited.end(), i) == not_visited.end() && find(visited.begin(), visited.end(), i) == visited.end()) {
                not_visited.insert(not_visited.begin(), i);
                
            }
        }
        if (!not_visited.empty()) {
            current = not_visited.front();
        }
    }
    return visited;
}
```
Программа выполняется в соответствии с описанным алгоритмом.

#### Пример: 

Обход графа в глубину, начиная с 1-ой вершины:

![image](https://github.com/iis-32170x/RPIIS/assets/135509020/332ab809-814a-4728-810d-fa811edd0122)
