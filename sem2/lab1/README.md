# Лабораторная работа №1
## Цель
 Разработать библеотеку для работы со структурой данных.
## Задача
**Структура данных — однонаправленный список.**
_______________________________________________
**Функции для данной структуры данных:** <br>
1.Вставка элемента в список.<br>
2.Удаление элемента из списка.<br>
3.Сортировка списка.<br>
4.Поиск элемента в списке.<br>
5.Объединение двух списков.<br>
6.Пересечение двух списков.<br>
## Реализация структуры данных
### Однонаправленный список
*Однонаправленный список* — это структура данных, состоящая из узлов, каждый из которых содержит некоторую информацию и указатель на следующий узел в списке. Конечный узел в списке вместо ссылки на следущий узел содержит информацию "nullptr"
Реализация представлена в виде данной структуры: <br>
```
struct node 
{
	int info;
	node* next;
};
```
> *int info* - информация, хранящаяся в узле <br>
> *node next* - указатель на следующий узел в списке
## Реализация исходных функций
### Функция *Сортировка списка*
```
void NodeSorting(node* begin)
{
	node* t = begin;  
	bool proof = false;
	while (!proof)
	{
		proof = true;
		while (t->next != nullptr)
		{
			if (t->info > t->next->info)
			{
				int buff;
				buff = t->info;
				t->info = t->next->info;
				t->next->info = buff;
				proof = false;
			}
			t = t->next;
		}
		t = begin;
	}
}
```
> В функцию приходит указатель на первый узел списка, который будет сортироваться, (node* begin). Далее функция использует метод сортировки *BubbleSorting* и сортирует список именно в памяти компьютера (поэтому функция ничего не возвращает)
### Функция *Поиск элемента в списке*
```
node* SearchNodeInfo(node* begin, int search)
{
	node* t = begin;
	while (t != nullptr)
	{
		if (t->info == search)
		{
			return t;
		}
		t = t->next;
	}
	return nullptr;
}
```
> В функцию приходит указатель на первый узел списка, в котором требуется найти узел, (node* begin) и значение, которое функция должна найти в данном списке, (int search). Далее функция проходит по всему списку и сравнивает значение информации в узле и значение, которое пришло в функцию.
```
while (t != nullptr) {...}
```
Далее <br>
1. Если функция находит искомый узел,
```
if (t->info == search)
```
то она возвращает указатель на него.
```
return t;
```
2. Если функция не находит искомый узел, то она возвращает значение "*отсутствия*".
```
return nullptr;
```
### Функция *Удаление элемента из списка*
```
void DeleteNode(node** begin, node* del)
{
	if (del != nullptr)
	{
		if (del == *begin)
		{
			*begin = del->next;
			delete del;
		}
		else
		{
			node* t = *begin;
			while (t->next != del)
			{
				t = t->next;
			}
			t->next = del->next;
			delete del;
		}
	}
}
```
> В функцию приходит указатель на указатель на первый узел списка, в котором требуется удалить запрашиваемый узел, (node** begin) и сам запрашиваемый узел (node* del). Делаем проверку на то, что в функцию пришел узел, который присутствует с списке.
```
if (del != nullptr) {...}
```
 Далее <br>
1. Если удалаемый узел является первым в списке,
```
if (del == *begin) {...}
```
то изменяем значение указателя на начало списка на указатель на следующий узел 
```
*begin = del->next;
```
и удаляем запрашиваемый узел (даем системе понять, что данный участок памяти можно использовать).
```
delete del;
```
2. Если удаляемый узел не является первым в списке, то указатель на следующий узел в предыдущем за удалаемым узлом изменяем на указатель, который равняется указателю на следующий узел в удаляемом узле
```
t->next = del->next;
```
и удаляем запрашиваемый узел (даем системе понять, что данный участок памяти можно использовать).
```
delete del;
```
### Функция *Вставка элемента в список*
```
void AddNode(node* begin, int add)
{
	while (cin.fail() || SearchNodeInfo(begin, add) != nullptr)
	{
		cin.clear();
		cin.ignore(100000, '\n');
		cout << "ОШИБКА. Введите другое число" << endl;
		cin >> add;
	}
	node* a = new node;
	node* t = begin;
	while (t->next != nullptr)
	{
		t = t->next;
	}
	t->next = a;
	a->info = add;
	a->next = nullptr;
}
```
> В функцию приходит указатель на первый узел списка, в который необходимо вставить новый узел, (node* begin) и значение, которое будет внесено в новый узел списка (int add). Делаем проверку, что ни у одного узла данное значение не хранится.
```
(while (cin.fail() || SearchNodeInfo(begin, add) != nullptr) {...})
```
Далее создаем новый узел 
```
(node* a = new node;)
```
Изменяем указатель последнего узла списка на указатель на новый узел 
```
(while (t->next != nullptr) {...}
t->next = a;)
```
Вносим необходимое значение в новый узел 
```
(a->info = add;)
```
Делаем указатель нового узла на следующий узел "*отсутствующим*" 
```
(a->next = nullptr;)
```
### Функция *Объединение двух списков*
```
node* Unification(node* a, node* b)
{
	node* c = new node;
	node* ta = a;
	node* tb = b;
	node* tc = c;
	while (ta->next != nullptr)
	{
		node* r = new node;
		tc->info = ta->info;
		tc->next = r;
		r->next = nullptr;
		ta = ta->next;
		tc = tc->next;
	}
	tc->info = ta->info;
	while (tb != nullptr)
	{
		if (SearchNodeInfo(c, tb->info) != nullptr)
		{
			tb = tb->next;
		}
		else
		{
			AddNode(c, tb->info);
			tb = tb->next;
		}
	}
	return c;
}
```
> В функцию приходит указатель на первый узел из списка А (node* a) и указатель на первый узел из списка В (node* b). Далее создаем новый узлел с, который является указателем на первый узел нового списка С, и создаем указатели ta и tb, которые равны указателям a и b соответственно.
```
node* c = new node;
node* ta = a;
node* tb = b;
node* tc = c;
```
Далее копируем все узлы из списка А в списк С.
```
	while (ta->next != nullptr)
	{
		node* r = new node;
		tc->info = ta->info;
		tc->next = r;
		r->next = nullptr;
		ta = ta->next;
		tc = tc->next;
	}
	tc->info = ta->info;
```
Далее проходимся по каждому узлу из списка В
```
while (tb != nullptr) {...}
```
и "ищем" их при помощи *функции поиска* в списке А и, если этих узлов не находится в списке А,
```
		if (SearchNodeInfo(c, tb->info) != nullptr) {...}
```
то "вставляем" их при помощи *функции вставки* в список С
```
if (SearchNodeInfo(c, tb->info) != nullptr)
		{
			tb = tb->next;
		}
		else
		{
			AddNode(c, tb->info);
			tb = tb->next;
		}
```
Далее выводим указатель на первый узел списка С
```
return c;
```
### Функция *Пересечение двух списков*
```
node* Intersection(node* a, node* b) {
	node* ta = a;
	node* tb = b;
	node* HeadC = nullptr;
	node* TailC = nullptr;
	while (ta != nullptr) {
		while (tb != nullptr) {
			if (ta->info == tb->info) {
				node* c = new node;
				c->info = ta->info;
				c->next = nullptr;
				if (HeadC == nullptr) {
					HeadC = c;
					TailC = c;
				}
				else {
					TailC->next = c;
					TailC = c;
				}
				break;
			}
			tb = tb->next;
		}
		ta = ta->next;
		tb = b;
	}
	return HeadC;
}
```
