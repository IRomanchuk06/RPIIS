# <p align="center">Лабораторная работа №1</p>

Вариант 25. Очередь с приоритетом. Вставка элемента в очередь. Взятие элемента из очереди.

## <p align="center">Цели лабораторной работы:</p>
1. Разработать библиотеку для работы с очередью с приоритетом на выбранном императивном языке программирования (например, C++, Java, Python).
2. Создать тестовую программу для демонстрации функциональности разработанной библиотеки.
3. Разработать систему тестов для проверки работоспособности и корректности библиотеки, учитывая требования полноты, адекватности и непротиворечивости.
4. Обеспечить обработку некорректных данных, предусмотрев корректное завершение программы при возникновении ошибок.
5. Составить отчет по выполнению лабораторной работы.
   
## <p align="center">Задачи лабораторной работы:</p>
1. Изучить спецификацию задачи по работе с очередью с приоритетом.
2. Выбрать язык программирования для реализации библиотеки (например, C++, Java, Python) в соответствии с индивидуальным заданием.
3. Разработать и реализовать библиотеку для работы с очередью с приоритетом, включая операции вставки и извлечения элементов.
4. Написать тестовую программу, которая демонстрирует основные сценарии использования библиотеки.
5. Разработать систему тестов, включающую тест-кейсы для проверки различных аспектов работы библиотеки, включая корректность, производительность и обработку ошибок.
6. Провести тестирование разработанной библиотеки, убедившись в ее правильной работе на различных входных данных.
7. Составить подробный отчет, включая описание решения задачи, архитектуры библиотеки, результаты тестирования и выводы.

## <p align="center">Список используемых понятий и алгоритмов:</p>
1. **Библиотека программного обеспечения (Библиотека кода):**
В программировании библиотека представляет собой совокупность программного кода, предназначенного для решения определенных задач. Этот код может содержать функции, классы, процедуры или другие компоненты, которые разработчики могут повторно использовать в своих программных проектах. Библиотеки упрощают разработку, так как они предоставляют готовые решения для типовых задач.

2. **Приоритетная очередь:**
   Приоритетная очередь (англ. priority queue) — это абстрактная структура данных наподобие стека или очереди, где у каждого элемента есть приоритет. Элемент с более высоким приоритетом находится перед элементом с более низким приоритетом.

3. **Двоичная куча (Binary Heap):**
   Двоичная куча представляет собой вид двоичного дерева, которое соответствует следующим трем условиям:
   - **Сортировка значений:** Значение в каждой вершине не меньше, чем значения её потомков. В случае мин-кучи, значение в каждой вершине не больше значений её потомков, в макс-куче — не меньше.
   - **Балансировка глубины:** Разница в глубине листьев (расстояние от корня до листа) не превышает 1 слой. Это обеспечивает сбалансированность дерева и эффективное использование памяти.
   - **Заполнение слоев слева направо:** Последний слой дерева заполняется слева направо, без пропусков. Это обеспечивает эффективное хранение данных в виде массива.

4. **Операции вставки и извлечения:**
   - **Вставка (insert):** Операция добавления нового элемента в структуру данных. В контексте приоритетной очереди, элемент вставляется с учетом его приоритета.
   - **Извлечение (extract):** Операция удаления и возврата элемента с наивысшим приоритетом из структуры данных.

5. **Методы поддержки структуры данных:**
   - **Метод `up(i)`:** Поднимает элемент вверх по дереву, обеспечивая корректность структуры данных после вставки.
   - **Метод `down(i)`:** Спускает элемент вниз по дереву, обеспечивая корректность структуры данных после извлечения.

6. **Исключение `std::out_of_range`:**
   Исключение, используемое в C++, чтобы сигнализировать о выходе индекса за пределы допустимого диапазона. В данном контексте, используется для обработки попыток извлечения из пустой приоритетной очереди.

7. **Тестирование с использованием Google Test:**
   Google Test — это фреймворк для написания тестов в языке программирования C++. Тестирование с его использованием обеспечивает автоматизацию проверок и обеспечивает надежность кода.

## <p align="center">Описание используемых алгоритмов:</p>
1. **Бинарная куча (Heap):**
В своей библиотеке я реализовывал бинарную (двоичную) кучу через `std::vector`. Где n-ому элементу, соответствовали элементы 2n+1 и 2n+2.

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/binaryheap.png" alt="Двоичная куча через вектор">
</p>

2. **Метод вставки (insert):**
Отвечает за вставку нового элемента в приоритетную очередь. Этот метод добавляет элемент в конец вектора и затем вызывает метод up, который поднимает элемент вверх по дереву для обеспечения соблюдения условий бинарной кучи.
    - **Вспомогательный метод up:**
    Отвечает за подъем элемента вверх по дереву для восстановления условий бинарной кучи после вставки. Этот метод выполняет цикл, сравнивая значение текущего элемента с его родителем и меняя их местами при необходимости до тех пор, пока элемент не достигнет правильной позиции.

```cpp
void priorityQueue::insert(int value) {
	a.push_back(value);
	up(a.size() - 1);
}

void priorityQueue::up(int i) {
	while (a[i] > a[(i - 1) / 2] && i != 0) {
		swap(a[(i - 1) / 2], a[i]);
		i = (i - 1) / 2;
	}
}
```

3. **Метод извлечения (extract):**
Отвечает за извлечение элемента с наивысшим приоритетом из приоритетной очереди. Этот метод извлекает значение из корня, заменяет корень последним элементом вектора, а затем вызывает метод down, который опускает новый корень вниз по дереву для восстановления условий бинарной кучи. Также учитыется случай, когда происходит попытка извлечения из пустой очереди, для этого случая создано исключение `std::out_of_range` 
    - **Вспомогательный метод down:**
    Отвечает за опускание элемента вниз по дереву для восстановления условий бинарной кучи после извлечения. Этот метод выполняет цикл, сравнивая значение текущего элемента с его потомками и меняя его место с наибольшим из потомков, если это необходимо, до тех пор, пока элемент не достигнет правильной позиции.

```cpp
int priorityQueue::extract() {
	if (isEmpty()) {
		throw out_of_range("Priority queue is empty");
	}

	int value = a[0];
	a[0] = a[a.size() - 1];
	a.pop_back();
	down(0);
	return value;
}

void priorityQueue::down(int i) {
	while (2 * i + 1 < a.size()) {
		int maxChild = 2 * i + 1;
		if (maxChild + 1 < a.size() && a[maxChild] < a[maxChild + 1])
			maxChild++;
		if (a[i] >= a[maxChild])
			break;
		swap(a[maxChild],a[i]);
		i = maxChild;
	}
}
```
   
4. **Метод проверки пустой очереди (isEmpty):**
Проверяет, пуста ли приоритетная очередь. Возвращает true, если вектор a пуст, и false в противном случае.

```cpp
bool priorityQueue::isEmpty() const {
	return a.empty();
}
```

5. **Алгоритм работы очереди с приоритетом:**

    1. **Инициализация:**
       - Создание экземпляра класса `priorityQueue`.
       - Внутренний вектор `a` используется для хранения элементов в виде бинарной кучи.
    
    2. **Вставка элемента:**
       - Новый элемент добавляется в конец вектора.
       - Вызывается метод `up` для восстановления условий бинарной кучи.
    
    3. **Извлечение элемента:**
       - Проверка наличия элементов в куче.
       - Извлечение значения из корня (с наивысшим приоритетом).
       - Замена корня последним элементом вектора.
       - Вызов метода `down` для восстановления условий бинарной кучи.
    
    4. **Подъем элемента вверх:**
       - Пока текущий элемент больше родителя и не достигнут корень:
         - Меняем местами текущий элемент и его родителя.
         - Обновляем индекс текущего элемента.
    
    5. **Опускание элемента вниз:**
       - Пока есть хотя бы один потомок текущего элемента:
         - Выбираем максимального из потомков.
         - Если текущий элемент меньше выбранного потомка, меняем их местами.
         - Обновляем индекс текущего элемента.
    
    6. **Проверка наличия элементов:**
       - Проверка, пуста ли куча, основываясь на пустоте вектора `a`.

## <p align="center">Результаты тестирования:</p>
Тестирование проводилось с помощью фреймворка Google test. Система тестов состоит из 5 тестов: 2 базовых теста на вставку и извлечение, тест на вставку и извлечение с одинаковыми элементами, тест на вставку и извлечение с отрицательными элементами, тест на извлечение из пустой очереди. Все тесты прошли успешно.

<p align="center">
  <img src="https://github.com/IRomanchuk06/PriorityQueue/blob/main/TestPriorityQueue.png?raw=true" alt="Тесты библиотеки">
</p>

**Система тестов:**

```cpp
#include "pch.h"
#include <gtest/gtest.h>
#include "../priorituQueue/priorityQueue.h"
using namespace std;

//базовый тест на вставку и извлечение
TEST(PriorityQueueTest, InsertAndExtract1) {
    priorityQueue pq;

    EXPECT_TRUE(pq.isEmpty());

    pq.insert(10);
    pq.insert(5);
    pq.insert(20);

    EXPECT_FALSE(pq.isEmpty());

    EXPECT_EQ(pq.extract(), 20);
    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), 5);

    EXPECT_TRUE(pq.isEmpty());
}

//базовый тест на вставку и извлечение
TEST(PriorityQueueTest, InsertAndExtract2) {
    priorityQueue pq;

    pq.insert(10);
    pq.insert(5);
    pq.insert(20);
    pq.insert(15);
    pq.insert(25);

    EXPECT_EQ(pq.extract(), 25);
    EXPECT_EQ(pq.extract(), 20);
    EXPECT_EQ(pq.extract(), 15);
    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), 5);

    EXPECT_TRUE(pq.isEmpty());
}

//тест на вставку и извлечение с одинаковыми элементами
TEST(PriorityQueueTest, InsertAndExtractWithDuplicates) {
    priorityQueue pq;
    pq.insert(10);
    pq.insert(5);
    pq.insert(10);
    pq.insert(8);

    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), 8);
    EXPECT_EQ(pq.extract(), 5);
    EXPECT_TRUE(pq.isEmpty());
}

//тест на извлечение из пустой очереди
TEST(PriorityQueueTest, ExtractFromEmptyQueue) {
    priorityQueue pq;

    EXPECT_THROW(pq.extract(), std::out_of_range);
}

//тест на вставку и извлечение с отрицательными элементами
TEST(PriorityQueueTest, InsertWithNegativeNumbers) {
    priorityQueue pq;
    
    pq.insert(10);
    pq.insert(-5);
    pq.insert(25);
    pq.insert(-10);
    pq.insert(-2);

    EXPECT_EQ(pq.extract(), 25);
    EXPECT_EQ(pq.extract(), 10);
    EXPECT_EQ(pq.extract(), -2);
    EXPECT_EQ(pq.extract(), -5);
    EXPECT_EQ(pq.extract(), -10);
    EXPECT_TRUE(pq.isEmpty());
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```
## <p align="center">Вывод:</p>
**Научился:**
В ходе выполнения лабораторной работы я углубил свои знания в принципы работы приоритетных очередей на основе max-heap. Разобравшись с методикой "подъема" и "опускания" элементов, я научился эффективно управлять структурой данных, где максимальный элемент располагается в корне. Также я освоил применение стандартных контейнеров C++, в частности, использование `std::vector` для представления бинарной кучи.

**Сделал:**
Моим результатом стала успешная реализация библиотеки для приоритетной очереди. Я грамотно реализовал операции вставки, извлечения и проверки на пустоту, обеспечив эффективность и корректность работы структуры данных. Написание тестов с использованием Google Test позволило мне убедиться в надежности и правильности моей реализации.

**Освоил:**
Эта лабораторная работа подарила мне глубокое понимание проектирования и реализации приоритетных очередей. Опыт работы с тестовыми фреймворками, в данном случае с Google Test, дал возможность проверить функциональность моего кода, что стало важным шагом в обеспечении его корректности. Использование стандартных исключений для обработки ошибок стало неотъемлемой частью моего опыта в создании надежных программных решений.

В итоге, лабораторная работа не только расширила мои теоретические знания, но и придала практический опыт в области разработки структур данных, что положительно сказывается на моих навыках программирования.

## <p align="center">Используемые источники:</p>
1. https://neerc.ifmo.ru/wiki/index.php?title=Приоритетные_очереди#.D0.A0.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B8 (определения понятий).
2. https://www.youtube.com/watch?v=5mD-rhaYF4U&t=209s (создание библиотеки).
3. https://www.youtube.com/watch?v=o1ZDXf7NGN4&t=868s (реализация алгоритмов на C++).
4. https://github.com/google/googletest (про Google test: установка, использование).
5. https://chat.openai.com (помощь в освоении материала)
