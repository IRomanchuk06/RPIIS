## Цели 
***Исследовать свойства структур данных и разработать библиотеку алгоритмов обработки конкретной структуры данных***

## Тема 
***Структуры данных***

## Задача 
**Вариант 4**

Бинарное дерево поиска. Поиск узла в дереве. Вставка узла в дерево.
Удаление узла из дерева. Обходы дерева. Построение дерева из
массива.

## Cписок используемых понятий с указанием источников

* **Бинарное дерево поиска** — это бинарное дерево, обладающее дополнительными свойствами: значение левого потомка меньше значения родителя, а значение правого потомка больше значения родителя для каждого узла дерева. То есть, данные в бинарном дереве поиска хранятся в отсортированном виде. При каждой операции вставки нового или удаления существующего узла отсортированный порядок дерева сохраняется. При поиске элемента сравнивается искомое значение с корнем. Если искомое больше корня, то поиск продолжается в правом потомке корня, если меньше, то в левом, если равно, то значение найдено и поиск прекращается.
* **Бинарное дерево** — это иерархическая структура данных, в которой каждый узел имеет значение (оно же является в данном случае и ключом) и ссылки на левого и правого потомка. Узел, находящийся на самом верхнем уровне (не являющийся чьим либо потомком) называется корнем. Узлы, не имеющие потомков (оба потомка которых равны NULL) называются листьями.

![BSTSearch](https://github.com/iis-32170x/RPIIS/assets/136707141/2cda2deb-c0bd-4301-97b5-63c82f620108)




* https://habr.com/ru/articles/267855/
* https://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0,_%D0%BD%D0%B0%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F
* https://ru.hexlet.io/courses/algorithms-trees/lessons/binary/theory_unit
* https://www.youtube.com/watch?v=sf_9w653xdE&list=PLTxllHdfUq4d-DE16EDkpeb8Z68DU7Z_Q&index=1
* https://www.youtube.com/watch?v=18c3MTX0PK0&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&pp=iAQB
* https://learn.microsoft.com/ru-ru/cpp/?view=msvc-170
* https://ru.stackoverflow.com/questions/54502/%D0%A3%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%83%D0%B7%D0%BB%D0%B0-%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%B0

## Описание алгоритмов с указанием источников
***Иточники***:

https://www.youtube.com/watch?v=sf_9w653xdE&list=PLTxllHdfUq4d-DE16EDkpeb8Z68DU7Z_Q&pp=iAQB

**Алгоритм**

1. 


1). Создать структуру узла дерева, содержащую значение и указатели на левого и правого потомков.

2). Создать функцию для вставки нового значения в дерево, рекурсивно спускаясь по дереву и сравнивая значения.

3). Инициализировать указатель на корень дерева значением `nullptr`.

4). Для каждого значения в массиве:
   - Вызвать функцию вставки, передавая указатель на корень и значение.
     
5). Вернуть указатель на корень дерева.

![image](https://github.com/iis-32170x/RPIIS/assets/136707141/31e114b6-d47f-4fd9-9cf5-6e206068c966)
   
2.  

1). Если дерево пустое, создать новый узел и сделать его корнем.

2). Если дерево не пустое:
   - Если значение нового узла меньше значения текущего узла, рекурсивно вызвать алгоритм добавления для левого поддерева.
   - Если значение нового узла больше или равно значению текущего узла, рекурсивно вызвать алгоритм добавления для правого поддерева.

 ![image](https://github.com/iis-32170x/RPIIS/assets/136707141/98f2f156-6ed5-460f-b69a-6668b093ee43)
 
3.

1). Если дерево пустое, возвращаем `nullptr`.

2). Если значение узла для удаления меньше значения текущего узла, рекурсивно вызываем алгоритм удаления для левого поддерева.

3). Если значение узла для удаления больше значения текущего узла, рекурсивно вызываем алгоритм удаления для правого поддерева.

4). Если значение узла для удаления равно значению текущего узла:
   - Если текущий узел не имеет потомков, просто удаляем его.
   - Если текущий узел имеет только одного потомка, заменяем его на этого потомка.
   - Если текущий узел имеет двух потомков, находим наименьший узел в правом поддереве (или наибольший узел в левом поддереве), заменяем значение текущего узла на значение найденного узла и рекурсивно вызываем алгоритм удаления для найденного узла в правом (или левом) поддереве.
     
5). Возвращаем указатель на корень дерева после удаления узла.


 ![image](https://github.com/iis-32170x/RPIIS/assets/136707141/63dbab12-3238-4aa3-8713-21cd7bc0579a)
 ![image](https://github.com/iis-32170x/RPIIS/assets/136707141/05a96f25-fc9a-4f36-b0a8-0467e11ddf51)
 
4.

1). Если дерево пустое, завершаем обход.
2). Рекурсивно вызываем алгоритм для левого поддерева.
3). Посещаем текущий узел (выполняем необходимые операции с его значением).
4). Рекурсивно вызываем алгоритм для правого поддерева.
  
  ![image](https://github.com/iis-32170x/RPIIS/assets/136707141/97939824-0d48-47a2-97d4-ea405a26283b)

   
5.

1). Если дерево пустое, завершаем обход.
2). Рекурсивно вызываем алгоритм для левого поддерева.
3). Рекурсивно вызываем алгоритм для правого поддерева.
4). Посещаем текущий узел (выполняем необходимые операции с его значением).


   ![image](https://github.com/iis-32170x/RPIIS/assets/136707141/8ad56b69-0e41-4f45-b044-a65b40202306)
 ![image](https://github.com/iis-32170x/RPIIS/assets/136707141/2ac2926c-a382-491c-b687-d754dfbf8476)


## Результаты тестирования (изображения входных и выходных данных, с кратким описанием)

* Пользователь задает множество ключей и из этого множества программа создает ***Бинарное Дерево Поиска***. А также выводит ключи данного дерева симметричным обходом (в порядке возрастания)

![Screenshot 2024-03-06 224351](https://github.com/iis-32170x/RPIIS/assets/136707141/7f48f5fd-74ed-438c-a480-4088e2d5163a)

* Пользователь получает данные о каджом узле и его левого и правого детей 

![Screenshot 2024-03-06 224400](https://github.com/iis-32170x/RPIIS/assets/136707141/0bbf7833-ca22-4d07-b555-67577b5de97d)

* Пользователь может удалить любой узел. Результат выводится на экран

![image](https://github.com/iis-32170x/RPIIS/assets/136707141/509c0f87-1c65-4313-bae9-58465f1668a2)

* Здесь работает деструктор, который удаляет созданное дерево, а также выводит удаленные узлы обратном обходом

![image](https://github.com/iis-32170x/RPIIS/assets/136707141/9793d9a6-3bba-4ea8-874c-4909e7fa2bd2)


## Вывод

Создал **Бинарное Дерево Поиска** и провел некторое опрециия с ним 



