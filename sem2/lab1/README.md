<h1 align = "center">Лабораторная работа №1</h1>
<h3>Вариант 28. Дерево Хаффмана. Зашифровать текст с помощью дерева.</h3>
<h2 align = "center">Цель лабораторной работы:</h2>
1.Разрабатываю среду для работы на выбранном императивном языке программирования (например, C++, Java, Python).
<br>2.Создать тестовую программу для обеспечения функциональности программной библиотеки.
<br>3.Разработайте системные тесты для проверки работоспособности и корректности библиотеки, выполнения требований полноты, адекватности и непротиворечивости.
<br>4.Обеспечить обработку некорректированных данных, предусмотрев правильное завершение программы при устранении ошибок.
<br>5.Составить отчет по выполнению лабораторной работы.
<h2 align = "center">Список используемых понятий</h2>
<B>Дерево</B> — структура данных, эмулирующая древовидную структуру в виде набора связанных узлов. Является связным графом, не содержащим циклы.
<br><B>Корневой узел</B> — самый верхний узел дерева.
<br><B>Лист</B> (листовой или терминальный узел) — узел, не имеющий дочерних элементов.
<br><B>Внутренний узел</B> — любой узел дерева, имеющий потомков, и таким образом, не являющийся листовым узлом.
<br><B>Приоритетная очередь</B> (англ. priority queue) — это абстрактная структура данных наподобие стека или очереди, где у каждого элемента есть приоритет. Элемент с более высоким приоритетом находится перед элементом с более низким приоритетом. (В нашем случае приоритет у элемента с наименьшей частотой)
<br><B>Алгоритм Хаффмана</B> — алгоритм оптимального префиксного кодирования алфавита. Был разработан в 1952 году аспирантом Массачусетского технологического института Дэвидом Хаффманом при написании им курсовой работы. Его идея заключается в том чтобы при кодировании текста элементы с наибольшей частотой имели наименьший код.
<h3>Пример дерева Хаффмана:</h3>

<h2 align = "center">Выполнение Задания</h2>
<h3>Алгоритм создания Дерева Хаффмана:</h3>
1.Создаём таблицу частотности.
<br>2.Полученую таблицу заноси в очередь приоритетов с приоритетом наименьшей частотности.
<br>3.Добавляем также эти элементы в качестве листьев нашего дерева.
<br>4.Соеденяем 2 элемента с наименьшей частотой в узел(попутно удаляя их из приоритетной очереди) и закидываем полученый узел в приоритетную очередь и так пока в ней не останется один элемент который и будет нашим корнем.
<h2 align = "center">Описание используемых алгоритмов</h2>
