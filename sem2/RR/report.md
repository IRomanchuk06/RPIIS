# Расчётная работа

### Цель

Формализовать выполнение алгоритма в виде SCg-кода.

### Задание

2.7.Найти число реберной связности графа.

### Ключевые понятия

`Граф` — математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

![image](граф.png)
***
![граф бза](https://github.com/iis-32170x/RPIIS/assets/144935038/5ec3bc6c-f125-47a0-a536-be4a44d16d5d)

***
`Неориентированный граф` —  это математическая структура, представляющая собой набор вершин и рёбер, где рёбра не имеют направления.

![image](неорграф.png)
***
![неорграф_база](https://github.com/iis-32170x/RPIIS/assets/144935038/8bb2607f-05b3-414f-baf0-99c0a587eb0d)

***
`Ориентированный граф` — это математическая структура, представляющая собой набор вершин и рёбер, где рёбра  имеют направления.

![image](орграф.png)
***
![орграф_база](https://github.com/iis-32170x/RPIIS/assets/144935038/cfdbfd5c-c370-484b-9c6d-a727bffc7a40)

***
`Число реберной связности` — это минимальное количество ребер, удаление которых приводит к несвязному или тривиальному графу.

![реберная связность](https://github.com/iis-32170x/RPIIS/assets/144935038/e420fb12-aa6c-4939-b13c-fcc86ae6a250)

***
![реберная связность_база](https://github.com/iis-32170x/RPIIS/assets/144935038/91bd8a6a-8afb-47ec-8ede-a420ee190649)

***

`Несвязный граф`— граф,который имеет по крайней мере две компоненты связности.
***
`Компонента связности`— максимально связный подграф графа.

![компонента связности](https://github.com/iis-32170x/RPIIS/assets/144935038/2fe06b24-ac6a-4835-a4f4-650c60557e69)

***
![компсвязн_база](https://github.com/iis-32170x/RPIIS/assets/144935038/6c9b78e6-a74b-4c99-936e-65ce036f37de)

***
`Тривиальный граф`— граф, состоящий не более чем из одной вершины.

![тривиальный граф](https://github.com/iis-32170x/RPIIS/assets/144935038/33c8e9dd-9abf-4024-9eb9-4a346fa6c785)
***
![тривиальный граф база](https://github.com/iis-32170x/RPIIS/assets/144935038/294cdc40-30b4-4fd6-97ed-2692643c4bbc)

***

### Алгоритм решения


##### Переменная `grph` получает в качестве значения sc-узел неориентированного графа
![image](1.png)
***

##### Создадим переменную `nonvisited`, в которую запишем множество непройденных вершин, переменную `beg_vertex`, в которую заишем начальную для обхода вершину, переменную `amnt_exclude_edg`, в которую запишем количество исключенных ребер,т.е. 0.
![image](2.png)
***

##### Создание волны, включающей вершину *v1*.
![image](3.png)
***

##### Создание волны, включающей вершины *v2*,*v3*,*v4*.
![image](4.png)
***

##### Создание волны, включающей вершину *v5*
![image](5.png)
***

##### Создание волны, включающей вершину *v6*,*v7*.
![image](6.png)
***

##### Создание волны, включающей вершину *v8*,*v9*.
![image](7.png) 
***

##### Создаем волну, включающую вершину *v1*, записываем в переменную `nonvisited` все вершины, за исключением *v1*, переменную `exclude_edg`,которая хранит исключенные из обхода ребра,запишем в нее одну вершину *v1*, увеличиваем значение `amnt_exclude_edg` на 1.
![image](8.png)
***

##### Начало итерации цикла. Создание волны, включающей вершину *v3*,*v4* и не включающей *v2*, поскольку ребро *v1v2* исключено из обхода.
![image](9.png)
***

##### Создание волны, включающей вершину *v2*,*v5*.
![image](10.png)
***

##### Создание волны, включающей вершину *v7*,*v6*
![image](11.png)
***

##### Создание волны, включающей вершину *v8*,*v9*.Завершение итерации цикла.
![image](12.png)
#### Поскольку множество непосещенных вершин пусто, удаляем из переменной *exclud_edg* записанное ребро,записываем другое ребро и переходим к следующей итерации цикла. Т.к. следующие итерации цикла идентичны предыдущим, шаги по их выполнению опустим.
***

##### Записываем в переменную `exclude_edg` ребра *v1v2* и *v1v4*, увеличиваем значение `amnt_exclude_edg` на 1.
![image](13.png)
***

##### Начало итерации цикла. Создаем волну,включающую вершину *v1*,записывпем в переменную `nonvisited` все вершины, кроме *v1*.
![image](14.png)
***

##### Создаем волну,включающую только вершину *v3*,т.к. ребра *v1v2* и *v1v4* исключены из обхода.
![image](15.png)
***

##### Создаем волну,включающую  вершины *v2*,*v4*,*v5*.
![image](16.png)
***

##### Создаем волну,включающую  вершины *v7*,*v6*.
![image](17.png)
***

##### Создаем волну,включающую  вершины *v8*,*v9*.Завершение итерации цикла.
![image](18.png)
#### Поскольку множество непосещенных вершин пусто, удаляем из переменной *exclud_edg* записанные ребра,записываем другие ребра и переходим к следующей итерации цикла. Т.к. следующие итерации цикла идентичны предыдущим, шаги по их выполнению опустим.
***

##### Удаляем из переменной `exclude_edg` значения и записываем ребра *v4v5*,*v3v5*,в переменную `nonvisited` записываем все вершины, кроме *v1*, создаем волну, включающую вершину *v1*.
![image](19.png)
***

##### Создаем волну,включающую  вершины *v2*,*v3*,*v4*.
![image](20.png)
#### Поскольку все ребра,связывающие вершины из множества `new_wave` с вершинами, являющимися элементами множества непосещенных вершин `nonvisited`, исключены из обхода, итерация цикла завершается. В ответ идёт значение переменной `amnt_excude_edg`.
***
##### Удаляем список волн,множество непосещенных вершин `nonvisited`, переменную `_beg_vertex`, множество исключенных ребер `exclude_edg`.
![21](https://github.com/iis-32170x/RPIIS/assets/144935038/661b110d-947d-4314-9a74-ca5329f8e9f3)
***

### Тестовые примеры

#### Тест №1

##### Входные данные
![test1input](https://github.com/iis-32170x/RPIIS/assets/144935038/f5711b8e-388b-440e-a44c-b9af1dcd4b18)

***

##### Выходные данные
![test1output](https://github.com/iis-32170x/RPIIS/assets/144935038/bab65b04-3990-41b1-b2db-547bb9309298)

***
![Снимок экрана (110)](https://github.com/iis-32170x/RPIIS/assets/144935038/580d6cbe-7fc9-4515-8164-5148c6194086)

***
#### Тест №2

##### Входные данные
![test2input](https://github.com/iis-32170x/RPIIS/assets/144935038/6e613a04-4be2-4384-b5d1-cda641c86963)

***

##### Выходные данные
![test2output](https://github.com/iis-32170x/RPIIS/assets/144935038/1c6ddfd6-5e71-450c-9cf3-f5efc84078b9)


***
![Снимок экрана (109)](https://github.com/iis-32170x/RPIIS/assets/144935038/efb5bd45-caac-47a2-ba40-0c49d68bc332)

***
#### Тест №3

##### Входные данные
![test3input](https://github.com/iis-32170x/RPIIS/assets/144935038/792bc3d6-19ef-45ad-b351-fbde76817557)

***

##### Выходные данные
![test3output](https://github.com/iis-32170x/RPIIS/assets/144935038/7fe54538-91ae-4fc4-b4c2-cfd121691be1)
***
![Снимок экрана (108)](https://github.com/iis-32170x/RPIIS/assets/144935038/940b5f66-5933-4fc7-8e1b-0439f4e01f54)

***
#### Тест №4

##### Входные данные
![test4input](https://github.com/iis-32170x/RPIIS/assets/144935038/cbe98ae4-b433-4f5f-b348-a306eb9b1928)

***
##### Выходные данные
![test4output](https://github.com/iis-32170x/RPIIS/assets/144935038/ad82b771-3417-46da-a9b4-b768d0056a09)

***
![Снимок экрана (107)](https://github.com/iis-32170x/RPIIS/assets/144935038/aefa7146-b373-4e10-939d-cc756f97dabb)

***
### Вывод

В результате выполнения данной расчётной работы был формализован алгоритм нахождения числа реберной связности графа, были изучены:

- Основы теории графов

- Способы представления графов

- Базовые алгоритмы для работы с графами

- Основы SC-кода и SC-алфавита

- Базовые знания о SCg-коде

- Правила формирования идетификаторов sc-элементов

### Источники

- [Руководство к выполнению РР](https://drive.google.com/drive/folders/1RSriLOZWpxyozHjUa1Kz3uZtIr0PixVh)
