#pragma once
#include <iostream>
#include <cstdio>
#include "Header.h"

int n;
int a[100000];
int tree[400004];

void build_tree(int v, int tl, int tr, const int* a) {
    if (tl == tr) {
        tree[v] = a[tl];
    }
    else {
        int tm = (tl + tr) / 2;
        build_tree(v * 2, tl, tm, a);
        build_tree(v * 2 + 1, tm + 1, tr, a);
        tree[v] = tree[v * 2] + tree[v * 2 + 1];
    }
}

int get_sum(int l, int r, int v, int tl, int tr) {
    if (v >= 0 && v < 400004) {
        if (l <= tl && tr <= r) {
            return tree[v];
        }
        if (tr < l || r < tl) {
            return 0;
        }

        int tm = (tl + tr) / 2;
        return get_sum(l, r, v * 2, tl, tm)
            + get_sum(l, r, v * 2 + 1, tm + 1, tr);
    }
    return 0;
}

void update_range(int l, int r, int val, int v, int tl, int tr) {
    if (v >= 0 && v < 400004) {
        if (l <= tl && tr <= r) {
            tree[v] += val * (tr - tl + 1);
            if (tl != tr) {
                update_range(l, r, val, v * 2, tl, (tl + tr) / 2);
                update_range(l, r, val, v * 2 + 1, (tl + tr) / 2 + 1, tr);
            }
            return;
        }
        if (tr < l || r < tl) {
            return;
        }

        int tm = (tl + tr) / 2;
        update_range(l, r, val, v * 2, tl, tm);
        update_range(l, r, val, v * 2 + 1, tm + 1, tr);
        tree[v] = tree[v * 2] + tree[v * 2 + 1];
    }
}
