# Лабораторная работа №2

- `Цель` - нахождение пересечения множеств(без учета кратных вхождений)
- `Задача` - реализовать алгоритм пересечения исходных множеств
- `Вариант` - $\textcolor{grey}{\textit{2}}$

## Основные понятий 

- `Пересечение множеств` - это множество, которому принадлежат те и только те элементы, которые одновременно принадлежат всем данным множествам.

- `Элментом множества` может являться число, кортеж, отдельное множество, сочетание буквы и числа.

## Алгоритм часть 1

Алгоритм пересечения множест в данном коде выполняется следующим образом:

-Открывается файл с указанным путем.

-Инициализируются переменные, включая пустое множество result, флаг firstSet для отслеживания первого множества.

-Читается каждая строка из файла.

-Строка подвергается обрезке пробельных символов с помощью функции trim().
### Функция trim(const string& str):

```c++
string trim(const string& str) {
    size_t start = str.find_first_not_of(" \t\n\r");
    size_t end = str.find_last_not_of(" \t\n\r");
    if (start == string::npos || end == string::npos) {
        return "";
    }
    return str.substr(start, end - start + 1);
}
```

-Если строка содержит символ <, то она представляет собой кортеж множества. Внутри цикла происходит сборка элементов кортежа до тех пор, пока не встретится символ >. Затем собранный кортеж добавляется в текущее множество currentSet.

-Если строка не является кортежем, то элементы разделяются по запятой и добавляются в currentSet.

-Если это первое множество, оно становится результатом result.

-Если это не первое множество, происходит пересечение текущего множества currentSet с предыдущим результатом result. Результат пересечения сохраняется в intersectionSet.

-После обработки всех строк в файле, результат пересечения intersectionSet становится новым значением result.

-Файл закрывается, и возвращается итоговое пересечение множеств в виде result.

#### Более детальный разбор принципа работы данной функции:

1. size_t start = str.find_first_not_of(" \t\n\r");
Эта строка ищет первый индекс символа в строке str, который не является пробельным символом. Она использует функцию find_first_not_of, которая принимает набор символов (в данном случае пробельные символы) и возвращает индекс первого символа, который не является ни одним из указанных символов. Если такого символа не найдено, то функция возвращает string::npos, что указывает на неудачу в поиске.

2. size_t end = str.find_last_not_of(" \t\n\r");
Эта строка ищет последний индекс символа в строке str, который не является пробельным символом. Она использует функцию find_last_not_of, которая работает аналогично find_first_not_of, но ищет последний символ, который не является ни одним из указанных символов.

3. if (start == string::npos || end == string::npos) { return ""; }
В этом условном операторе проверяется, найдены ли начальные и конечные непробельные символы. Если хотя бы один из них не был найден (т.е. start или end равны string::npos), то строка str содержит только пробельные символы, и функция возвращает пустую строку "" в качестве результата.

5. return str.substr(start, end - start + 1);
Если начальные и конечные непробельные символы найдены, то функция использует функцию substr для создания новой строки, содержащей подстроку из строки str, начиная с индекса start и имеющей длину end - start + 1. Это обрезает пробельные символы с обоих концов строки str, и результат возвращается из функции.

### Функция ntersection(const string& file_path) :

```c++
set<string> intersection(const string& file_path) {
    ifstream file(file_path);
    if (!file.is_open()) {
        cout << "Не удалось открыть файл.";
        exit(-1);
    }

    string line;
    set<string> result;
    bool firstSet = true;

    while (getline(file, line)) {

        line = trim(line);
        line = line.substr(1, line.length() - 2);

        stringstream ss(line);
        set<string> currentSet;
        string element;

        while (getline(ss, element, ',')) {

            element = trim(element);


            if (element.find('<') != string::npos) {
                string tuple;
                while (element.find('>') == string::npos) {

                    tuple += element + ",";
                    getline(ss, element, ',');
                    element = trim(element);
                }
                tuple += element;
                currentSet.insert(tuple);
            }
            else {

                if (!element.empty()) {
                    currentSet.insert(element);
                }
            }
        }

        if (firstSet) {
            result = currentSet;
            firstSet = false;
        }
        else {
            set<string> intersectionSet;
            for (const string& elem : currentSet) {
                if (result.find(elem) != result.end()) {
                    intersectionSet.insert(elem);
                }
            }
            result = intersectionSet;
        }
    }

    file.close();
    return result;
}
```
## Алгоритм часть 2

- Включает заголовочный файл "set.h", который, вероятно, содержит определения функций и классов, связанных с множествами.

- В функции `main()` устанавливаются кодировки консоли с помощью функций `SetConsoleCP(1251)` и `SetConsoleOutputCP(1251)`. Кодировка 1251 соответствует кодировке Windows-1251, которая используется для представления символов на русском языке.

- Создается строковая переменная `file_path` и инициализируется значением "source.txt". Вероятно, это путь к файлу, который содержит данные для выполнения операции пересечения множеств.

- Вызывается функция `intersection(file_path)`, которая, вероятно, определена в заголовочном файле "set.h". Предположительно, эта функция считывает данные из файла `file_path` и выполняет операцию пересечения множеств на этих данных.

- Результат операции пересечения множеств сохраняется в переменной `result`.

- Далее происходит вывод результата операции на консоль. С помощью цикла `for` перебираются элементы `result`. Каждый элемент выводится на консоль с помощью объекта `cout`. Элементы разделяются запятыми и заключаются в фигурные скобки.

- Программа завершается и возвращает управление операционной системе.
```c++
#include "set.h"

int main() {
SetConsoleCP(1251);
SetConsoleOutputCP(1251);
string file_path = "source.txt";
const auto result = intersection(file_path);
cout << "Пересечение множеств: ";
cout << "{";
bool first = true;
for (const string& element : result) {
if (!first) {
cout << ", ";
}
cout << element;
first = false;
}
cout << "}";
}
```
## Вывод

Была реализована программа по пересечению множеств и выводу их итоговое пересечение.
