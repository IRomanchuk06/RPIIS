# Лабораторная работа №2

- `Цель` - нахождение пересечения множеств(без учета кратных вхождений)
- `Задача` - реализовать алгоритм пересечения исходных множеств
- `Вариант` - $\textcolor{grey}{\textit{2}}$

## Основные понятий 

- `Пересечение множеств` - это множество, которому принадлежат те и только те элементы, которые одновременно принадлежат всем данным множествам.

- `Элментом множества` может являться число, кортеж, отдельное множество, сочетание буквы и числа.

## Алгоритм часть 1

Алгоритм пересечения множест в данном коде выполняется следующим образом:

-Открывается файл с указанным путем.

-Инициализируются переменные, включая пустое множество result, флаг firstSet для отслеживания первого множества.

-Читается каждая строка из файла.

-Строка подвергается обрезке пробельных символов с помощью функции trim().
### Функция trim(const string& str):

```c++
string trim(const string& str) {
    size_t start = str.find_first_not_of(" \t\n\r");
    size_t end = str.find_last_not_of(" \t\n\r");
    if (start == string::npos || end == string::npos) {
        return "";
    }
    return str.substr(start, end - start + 1);
}
```

-Если строка содержит символ <, то она представляет собой кортеж множества. Внутри цикла происходит сборка элементов кортежа до тех пор, пока не встретится символ >. Затем собранный кортеж добавляется в текущее множество currentSet.

-Если строка не является кортежем, то элементы разделяются по запятой и добавляются в currentSet.

-Если это первое множество, оно становится результатом result.

-Если это не первое множество, происходит пересечение текущего множества currentSet с предыдущим результатом result. Результат пересечения сохраняется в intersectionSet.

-После обработки всех строк в файле, результат пересечения intersectionSet становится новым значением result.

-Файл закрывается, и возвращается итоговое пересечение множеств в виде result.

#### Более детальный разбор принципа работы данной функции:

Данная функция trim принимает в качестве аргумента строку str и удаляет все начальные и конечные пробельные символы (пробелы, табуляции, символы новой строки и возврата каретки) из этой строки. Она возвращает новую строку, которая является результатом обрезки пробельных символов.

1. size_t start = str.find_first_not_of(" \t\n\r");
Эта строка ищет первый индекс символа в строке str, который не является пробельным символом. Она использует функцию find_first_not_of, которая принимает набор символов (в данном случае пробельные символы) и возвращает индекс первого символа, который не является ни одним из указанных символов. Если такого символа не найдено, то функция возвращает string::npos, что указывает на неудачу в поиске.

2. size_t end = str.find_last_not_of(" \t\n\r");
Эта строка ищет последний индекс символа в строке str, который не является пробельным символом. Она использует функцию find_last_not_of, которая работает аналогично find_first_not_of, но ищет последний символ, который не является ни одним из указанных символов.

3. if (start == string::npos || end == string::npos) { return ""; }
В этом условном операторе проверяется, найдены ли начальные и конечные непробельные символы. Если хотя бы один из них не был найден (т.е. start или end равны string::npos), то строка str содержит только пробельные символы, и функция возвращает пустую строку "" в качестве результата.

5. return str.substr(start, end - start + 1);
Если начальные и конечные непробельные символы найдены, то функция использует функцию substr для создания новой строки, содержащей подстроку из строки str, начиная с индекса start и имеющей длину end - start + 1. Это обрезает пробельные символы с обоих концов строки str, и результат возвращается из функции.

Таким образом, функция trim удаляет начальные и конечные пробельные символы из строки и возвращает обрезанную строку.

### Функция ntersection(const string& file_path) :

```c++
multiset<string> intersection(const string& file_path) {
    ifstream file(file_path);
    if (!file.is_open()) {
        cout << "Не удалось открыть файл.";
        exit(-1);
    }

    string line;
    multiset<string> result;
    bool firstSet = true;

    while (getline(file, line)) {
        line = trim(line);
        line = line.substr(3, line.length() - 4);

        multiset<string> currentSet;
        string element;
        line += ',';
        for (int i = 0; i < line.size(); i++) {
            if (line[i] == '{') {
                int end = find_next_bracker(line, i) - 1;
                i++;
                string str = line.substr(i, end - i + 1);
                currentSet.insert(sets(str));
                i = end + 2;
                element = "";
                continue;
            }
            if (line[i] == '<') {
                int end = find_next_bracker(line, i) - 1;
                i++;
                string str = line.substr(i, end - i + 1);
                currentSet.insert(corteges(str));
                i = end + 2;
                element = "";
                continue;
            }

            if (line[i] != ',') {
                element += line[i];
            }
            else {
                currentSet.insert(element);
                element = "";
            }
        }

        if (firstSet) {
            result = currentSet;
            firstSet = false;
        }
        else {
            multiset<string> intersectionSet;
            for (const string& elem : currentSet) {
                if (result.find(elem) != result.end()) {
                    intersectionSet.insert(elem);
                }
            }
            result = intersectionSet;
        }
    }

    file.close();
    return result;
}
```
#### Более детальный разбор принципа работы данной функции:

Данная функция `intersection` предназначена для нахождения пересечения множеств, представленных в текстовом файле. Функция принимает в качестве параметра путь к файлу, содержащему множества, и возвращает множество, являющееся результатом пересечения всех множеств из файла.

1. Открывается файл с помощью `ifstream` с указанным в параметре `file_path` путем.

2. Проверяется, удалось ли открыть файл. Если файл не удалось открыть, выводится сообщение об ошибке, используя `cout`, и программа завершается с кодом `-1` с помощью `exit(-1)`.

3. Создается пустая строка `line`, которая будет использоваться для чтения строк из файла.

4. Создается пустое множество строк `result`, которое будет содержать результат пересечения.

5. Устанавливается флаг `firstSet` в значение `true`, который будет использоваться для отслеживания первого множества.

6. Запускается цикл `while`, который будет выполняться до тех пор, пока есть строки для чтения из файла с помощью `getline(file, line)`.

7. Внутри цикла происходит обработка каждой строки:
   - Строка `line` обрезается с помощью функции `trim`, которая удаляет пробельные символы с начала и конца строки.
   - Затем строка `line` обрезается таким образом, чтобы удалить первый и последний символ (символы `<` и `>`), используя `line.substr(1, line.length() - 2)`.
   - Создается `stringstream` с именем `ss`, который будет использоваться для разделения строки на элементы с помощью разделителя `,`.
   - Создается пустое множество строк `currentSet`, которое будет содержать текущее множество из строки.
   - Запускается вложенный цикл `while`, который будет выполняться до тех пор, пока есть элементы для чтения из `ss` с помощью `getline(ss, element, ',')`.
   - Внутри вложенного цикла происходит обработка каждого элемента:
     - Элемент `element` обрезается с помощью функции `trim`, которая удаляет пробельные символы с начала и конца строки.
     - Проверяется, содержит ли элемент символ `<`, с помощью `element.find('<') != string::npos`.
     - Если элемент содержит символ `<`, значит это кортеж вида `<элемент1, элемент2, ...>`. В этом случае происходит следующее:
       - Создается пустая строка `tuple`, которая будет использоваться для сборки кортежа.
       - Запускается вложенный цикл `while`, который будет выполняться до тех пор, пока не будет найден символ `>` внутри элемента, с помощью `element.find('>') == string::npos`.
       - Внутри вложенного цикла элемент `element` добавляется к строке `tuple`, за исключением последнего символа `,`, и затем считывается следующий элемент из `ss` с помощью `getline(ss, element, ',')`.
       - Элемент `element` обрезается с помощью функции `trim`, которая удаляет пробельные символы с начала и конца строки.
       - После выхода из вложенного цикла `while`, последний элемент `element` добавляется к строке `tuple`.
       - Затем строка `tuple` добавляется в множество `currentSet`.
     - Если элемент не содержит символ `<`, значит это обычный элемент множества. В этом случае происходит следующее:
       - Проверяется, не является ли элементпустым, с помощью `!element.empty()`.
       - Если элемент не пустой, то он добавляется в множество `currentSet`.
   - После завершения вложенного цикла `while`, текущее множество `currentSet` готово.
   - Далее происходит обновление результирующего множества `result`.
     - Если это первое множество (флаг `firstSet` равен `true`), то результирующее множество `result` присваивается текущее множество `currentSet`, и флаг `firstSet` устанавливается в `false`.
     - Если это не первое множество, то создается пустое множество `intersectionSet`, которое будет содержать пересечение множеств `result` и `currentSet`.
     - Запускается цикл `for`, который перебирает все элементы `elem` из `currentSet`.
     - Внутри цикла проверяется, содержится ли элемент `elem` в множестве `result` с помощью `result.find(elem) != result.end()`.
     - Если элемент содержится в `result`, то он добавляется в множество `intersectionSet`.
     - После завершения цикла `for`, результирующее множество `result` обновляется и становится равным `intersectionSet`.

8. После обработки всех строк в файле, файл закрывается с помощью `file.close()`.

9. Результирующее множество `result` возвращается из функции.

Таким образом, функция проходит по каждому множеству, представленному в файле, и находит их пересечение, обновляя результат на каждой итерации. В конце выполняется возврат результирующего множества.

## Алгоритм часть 2

- Включает заголовочный файл "set.h", который, вероятно, содержит определения функций и классов, связанных с множествами.

- В функции `main()` устанавливаются кодировки консоли с помощью функций `SetConsoleCP(1251)` и `SetConsoleOutputCP(1251)`. Кодировка 1251 соответствует кодировке Windows-1251, которая используется для представления символов на русском языке.

- Создается строковая переменная `file_path` и инициализируется значением "source.txt". Вероятно, это путь к файлу, который содержит данные для выполнения операции пересечения множеств.

- Вызывается функция `intersection(file_path)`, которая, вероятно, определена в заголовочном файле "set.h". Предположительно, эта функция считывает данные из файла `file_path` и выполняет операцию пересечения множеств на этих данных.

- Результат операции пересечения множеств сохраняется в переменной `result`.

- Далее происходит вывод результата операции на консоль. С помощью цикла `for` перебираются элементы `result`. Каждый элемент выводится на консоль с помощью объекта `cout`. Элементы разделяются запятыми и заключаются в фигурные скобки.

- Программа завершается и возвращает управление операционной системе.
```c++
#include "set.h"

int main() {
SetConsoleCP(1251);
SetConsoleOutputCP(1251);
string file_path = "source.txt";
const auto result = intersection(file_path);
cout << "Пересечение множеств: ";
cout << "{";
bool first = true;
for (const string& element : result) {
if (!first) {
cout << ", ";
}
cout << element;
first = false;
}
cout << "}";
}
```
## Вывод

Была реализована программа по пересечению множеств и выводу их итоговое пересечение.
