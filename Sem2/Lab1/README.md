# Лабораторная работа №1
> ## Постановка задачи
1. Разработать библиотеку для работы со структурой данных, указанной в
индивидуальном задании, на любом императивнойм языке
программирования (Pascal, C\C++, Java, C#, Python и др.)
2. Разработать тестовую программу, которая демонстрирует
работоспособность реализованной библиотеки работы со структурой
данных.
3. Разработать систему тестов, которые продемонстрировали бы
работоспособность реализованной библиотеки. Система тестов должна
отвечать требованиям полноты, адекватности и непротиворечивости.
Система тестов должна учитывать не только корректную работу на
правильных данных, но и предусматривать корректное завершение
программы в случае некорректных данных.
4. По результатам выполнения задания составить отчет.
> ## Условие первой лабораторной работы (Вариант 11)
Дерево максимумов. Поиск максимума на отрезке массива. Изменение всех чисел на отрезке массива на какое-то значение.
> ## Определения и понятия
+ Дерево представляет собой набор объектов, называемых узлами. Узлы соединены ребрами. Каждый узел содержит значение или данные, и он может иметь или не иметь дочерний узел.Первый узел дерева называется корнем. Если этот корневой узел соединен с другим узлом, тогда корень является родительским узлом, а связанный с ним узел — дочерним. Лист — узел, не имеющий дочерних узлов на дереве.
+ Бинарным (двоичным) деревом называется иерархическая структура данных, в которой каждый узел имеет не более двух дочерних.
+ Дерево максимумов — это структура данных,в которой каждый узел хранит максимально значение его левого и правого дочернего узла, исключая листья, они хронят свои значения.
___
##  *Разбор алгоритмов основных функций*
Для реализации дерева максимумов будем пользоваться бинарным деревом.

___
> + Способ реализации узла дерева максимумов с помощью структуры "dm".
``` c++
struct dm
{
	int max, add, l, r;
	struct dm* left, * right;
};
```
Где 
+ max - максимальное значение на интервале
+ add - переменная, которая хронит все модификации на отрезке [l,r]
+ l и r - границы рассматриваемого отрезка
+ *left и *right - указатели на левого и правого сыновей узла
---
>+ Функция создания дерева максимумов.
``` c++
dm* build(int l, int r)
{
	dm* root = new dm;
	root->max = 0;
	root->add = 0;
	root->l = l;
	root->r = r;
	if (l < r)
	{
		root->left = build(l, (l + r) / 2);
		root->right = build((l + r) / 2 + 1, r);
	}
	else
	{
		root->left = nullptr;
		root->right = nullptr;
	}
	return root;
}
```
В данной функции мы выделяем память и создаем ,с указанными границами, узел. Придаем полям "max" и "add" нулевые значения и формируем левого и правого потомка, путем рекурсивного вызова функции с новыми границами в качестве параметров. Алгоритм закончится когда r и l будут иметь равные значения(т.е. пока не найдет элемент отрезка).
___
>+ Функция изменения отрезка на число.  
``` c++
	void modify(dm* root, int l, int r, int val)
	{
		if (root->l == l && root->r == r) root->add += val;
		else
		{
			if (l <= root->left->r) modify(root->left, l, min(r,

				root->left->r), val);

			if (r >= root->right->l) modify(root->right, max(l,

				root->right->l), r, val);

			root->max = max(root->left->max + root->left->add, root->right->max + root->right->add);
		}
	}
```
___
>+ Функция нахождения максимумов.
```c++
int findmax(dm* root, int l, int r, int sumadd)
{
	if (root->l == l && root->r == r) return sumadd + root->max;
	else
	{
		int res = -std::numeric_limits<int>::min();
		if (l <= root->left->r)
			res = max(findmax(root->left, l, min(r, root->left->r), sumadd + root->left->add), res);

		if (r >= root->right->l)
			res = max(findmax(root->right, max(l, root->right->l), r, sumadd + root->right->add), res);

		return res;
	}
}
```
Теперь рассмотрим функцию максимума для интервала. Вначале введем понятие
накопленной суммы (sumadd). Каждый раз, когда на рекурсивном спуске мы будем
проходить через какую-то вершину, то будем прибавлять к сумме значение поля add (таким
образом, мы учтем все изменения, которые совершались с данными объектами, которые
меняют все элементы, в том числе максимум). Т.е. в каждую функцию в качестве sumadd
должна передаваться сумма sumadd и поля add для узла, обрабатываемого вызываемой
функцией. При вызове функции поиска должен передаваться указатель на корень дерева, а
значение sumadd должно быть равно полю add для корня.
Если границы текущего интервала совпадают с запросом, то мы возвращаем наверх
значение max + sumadd (т.е. значение максимального элемента плюс все изменения,
которые накладывались на данный интервал). Если же интервал покрывается не полностью,
то мы будем вызывать функцию для тех его детей, которые хотя бы частично пересекаются с
интервалом и возвращать максимальное из значений, возвращенное этими функциями. Для
дерева максимумов мы будем возвращать максимум из возвращенных значений.
___

##  *Пример выполнения*
![Img1](https://github.com/iis-32170x/RPIIS/blob/Войшнис_Г/Sem2/Lab1/Images/c4.png)
___
В результате выполнения данной работы были получены следующие практические навыки:

+ изучение структуры дерево максимумов
+ умение работать с header-файлами
+ изучение базовых алгоритмов для работы со структурами типа дерево максимумов
# Спасибо за внимание!
[Для вопросов и претензий](https://www.youtube.com/watch?v=HEXWRTEbj1I)
