# Лабораторная работа №1
> ## Постановка задачи
1. Разработать библиотеку для работы со структурой данных, указанной в
индивидуальном задании, на любом императивнойм языке
программирования (Pascal, C\C++, Java, C#, Python и др.)
2. Разработать тестовую программу, которая демонстрирует
работоспособность реализованной библиотеки работы со структурой
данных.
3. Разработать систему тестов, которые продемонстрировали бы
работоспособность реализованной библиотеки. Система тестов должна
отвечать требованиям полноты, адекватности и непротиворечивости.
Система тестов должна учитывать не только корректную работу на
правильных данных, но и предусматривать корректное завершение
программы в случае некорректных данных.
4. По результатам выполнения задания составить отчет.
> ## Условие первой лабораторной работы (Вариант 11)
Дерево максимумов. Поиск максимума на отрезке массива. Изменение всех чисел на отрезке массива на какое-то значение.
___
##  *Разбор алгоритмов основных функций и понятий*
Для реализации дерева максимумов будем пользоваться бинарным деревом.
___
> + Способ реализации узла дерева максимумов с помощью структуры "dm".
``` c++
struct dm
{
	int max, add, l, r;
	struct dm* left, * right;
};
```
Где 
+ max - максимальное значение на интервале
+ add - переменная, которая хронит все модификации на отрезке [l,r]
+ l и r - границы рассматриваемого отрезка
+ *left и *right - указатели на левого и правого сыновей узла
---
>+ Функция создания дерева максимумов.
``` c++
dm* build(int l, int r)
{
	dm* root = new dm;
	root->max = 0;
	root->add = 0;
	root->l = l;
	root->r = r;
	if (l < r)
	{
		root->left = build(l, (l + r) / 2);
		root->right = build((l + r) / 2 + 1, r);
	}
	else
	{
		root->left = nullptr;
		root->right = nullptr;
	}
	return root;
}
```
В данной функции мы выделяем память и создаем ,с указанными границами, узел. Придаем полям "max" и "add" нулевые значения и формируем левого и правого потомка, путем рекурсивного вызова функции с новыми границами в качестве параметров. Алгоритм закончится когда r и l будут иметь равные значения(т.е. пока не найдет элемент отрезка).
___
>+ Функция изменения отрезка на число.  
``` c++
	void modify(dm* root, int l, int r, int val)
	{
		if (root->l == l && root->r == r) root->add += val;
		else
		{
			if (l <= root->left->r) modify(root->left, l, min(r,

				root->left->r), val);

			if (r >= root->right->l) modify(root->right, max(l,

				root->right->l), r, val);

			root->max = max(root->left->max + root->left->add, root->right->max + root->right->add);
		}
	}
```
___
>+ Функция нахождения максимумов.
```c++
int findmax(dm* root, int l, int r, int sumadd)
{
	if (root->l == l && root->r == r) return sumadd + root->max;
	else
	{
		int res = -std::numeric_limits<int>::min();
		if (l <= root->left->r)
			res = max(findmax(root->left, l, min(r, root->left->r), sumadd + root->left->add), res);

		if (r >= root->right->l)
			res = max(findmax(root->right, max(l, root->right->l), r, sumadd + root->right->add), res);

		return res;
	}
}
```
Теперь рассмотрим функцию максимума для интервала. Вначале введем понятие
накопленной суммы (sumadd). Каждый раз, когда на рекурсивном спуске мы будем
проходить через какую-то вершину, то будем прибавлять к сумме значение поля add (таким
образом, мы учтем все изменения, которые совершались с данными объектами, которые
меняют все элементы, в том числе максимум). Т.е. в каждую функцию в качестве sumadd
должна передаваться сумма sumadd и поля add для узла, обрабатываемого вызываемой
функцией. При вызове функции поиска должен передаваться указатель на корень дерева, а
значение sumadd должно быть равно полю add для корня.
Если границы текущего интервала совпадают с запросом, то мы возвращаем наверх
значение max + sumadd (т.е. значение максимального элемента плюс все изменения,
которые накладывались на данный интервал). Если же интервал покрывается не полностью,
то мы будем вызывать функцию для тех его детей, которые хотя бы частично пересекаются с
интервалом и возвращать максимальное из значений, возвращенное этими функциями. Для
дерева максимумов мы будем возвращать максимум из возвращенных значений.
___

##  *Пример выполнения*

```c++
dm* tree =build(0, 5);
modify(tree, 0, 0, -1);
modify(tree, 2, 2, 10);
modify(tree, 1, 1, -14);
modify(tree, 3, 3, -12);
modify(tree, 4, 4, 22);
int max13 = findmax(tree, 0, 4, tree->add);
```
В данном примере мы по отдельности заполням каждый элемент отрезка
и в результате получаем отрезок [-1,-14,10,-12,22] и вызываем функцию findmax для всего отрезка.

![Img1](https://github.com/iis-32170x/RPIIS/blob/Войшнис_Г/Sem2/Images/с1.png)

```c++
dm* tree =build(0, 5);
modify(tree, 0, 0, -1);
modify(tree, 2, 2, 10);
modify(tree, 1, 1, -14);
modify(tree, 3, 3, -12);
modify(tree, 4, 4, 22);
modify(tree, 0, 3, 15);
int max13 = findmax(tree, 0, 4, tree->add);
```
Добавляем изменение на отрезке [0,3] на 15. В результате получаем новый отрезок [14,1,25,3,22].

![Img2](https://github.com/iis-32170x/RPIIS/blob/Войшнис_Г/Sem2/Images/с2.png)

```c++
dm* tree =build(0, 5);
modify(tree, 0, 0, -1);
modify(tree, 2, 2, 10);
modify(tree, 1, 1, -14);
modify(tree, 3, 3, -12);
modify(tree, 4, 4, 22);
modify(tree, 0, 3, -15);
int max13 = findmax(tree, 2, 4, tree->add);
```
А теперь изменим отрезок поиска максимального элемента и сам отрезок.В резульате отрезок примет вид:[-1,-14,10,-12,22]

![Img3](https://github.com/iis-32170x/RPIIS/blob/Войшнис_Г/Sem2/Images/с3.png)

# Спасибо за внимание!
[Для вопросов и претензий](https://www.youtube.com/watch?v=HEXWRTEbj1I)
