# Расчётная работа

---
---

### Цель

Формализовать выполнение алгоритма в виде SCg-кода.

---


### Задание

Найти композицию двух неориентированных графов.

---

### Ключевые понятия

`Граф` - это топологичекая модель, которая состоит из множества вершин и множества соединяющих их рёбер. 

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D0%B3%D1%80%D0%B0%D1%84.png)


`Неориентированный граф` —  это тип графа, ребрам которого не присвоено заданное направление.

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D0%BD%D0%B5%D0%BE%D1%80%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9%D0%B3%D1%80%D0%B0%D1%84.png)


`Ориентированный граф` — граф, в котором рёбра имеют направления и обозначаются стрелками. В таком ориентированном графе можно перемещаться вдоль ребра только в указанном направлении.

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D0%BE%D1%80%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9%20%D0%B3%D1%80%D0%B0%D1%84.png)


`Псевдограф` - граф с петлями.

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%B3%D1%80%D0%B0%D1%84.png)


`Множество` — это одно из ключевых понятий математики; представляющее собой набор, совокупность каких-либо объектов — элементов этого множества.


`Композиция графов` —  является способом комбинирования двух графов G1 в G2 для создания нового графа G3. Каждая вершина G1 заменяется на копию Ga = G2, а затем, если (a1,a2) принадлежит E1, то между любыми вершинами b1 из Ga1 и b2 из Ga2 проводится ребро (дуга) (b1,b2). 

---


 ### Алгоритм решения 

1. Создаём множество неориентированных графов (в данном случае множество состоит из двух неориентированных графов `_gragh_1` и `_gragh_2`). 

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D0%B4%D0%B0%D0%BD%D0%BE.png)


2. Создаём пустой `_gragh_3`, который будет отражать результат композиции множества неориентированных графов. В него сразу переносим все вершины графа `_gragh_1`.

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D1%88%D0%B0%D0%B31.png)


4. Создаём переменную `not_checked_vertexes`, где будут храниться непосещённые вершины, и `_checked_vertexes`, где будут храниться посещённые вершины.

5. Создаём волну в произвольной вершине и добавляем её в список волн, исключая вершину из множества непосещённых вершин.

6. Пока это возможно, создаём следующую волну на смежной и непосещённой вершине, удаляя её из множества непосещённых вершин. Если волна оказалась на вершине, из которой нельзя выйти на смежную и непосещённую вершину, то мы переходим к пункту (7).

7. Если в графе остались непосещённые вершины, то переходим к пункту (8), если нет - к пункту (9).

8. Если предположить, что мы находимся на i-той волне, то

    8.1. По списку волн переходим на (i-1)-ую волну.

    8.2. Если это волна включает вершину, из которой можно перейти к смежной непосещённой вершине, то переходим к пункту (6), если нет - к пункту (8.1).

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D1%88%D0%B0%D0%B32.png)
![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D1%88%D0%B0%D0%B33.png)

9. Из графа `_graph_2` берём начальную вершину обхода (в данном случае вершина A).

10. Сравниваем с каждой вершиной графа `_graph_1`:

	10.1. Если в результате сравнение было найдено совпадение вершины второго графа с вершиной первого, то берём следующую вершину графа `_graph_2` и переходим к пункту (10)

	10.2 Если в результате сравнение не было найдено совпадение вершины второго графа с вершиной первого, то добавляем вершину графа `_gragh_2` к `_gragh_3`.

11. Если в графе `_gragh_2` остались ещё вершины, которые не сравнивались,то берём следующую такую и переходим к пункту 10.

12. Если в графе `_gragh_2` не осталось вершин, которые не сравнивались,то переходим к пункту 13.

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D1%88%D0%B0%D0%B34.png)


Результат данных действий:

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D1%88%D0%B0%D0%B35.png)

---

13. Создаём переменную `not_checked_evertexes`, где будут храниться непосещённые рёбра, и `_checked_еvertexes`, где будут храниться посещённые рёбра.

14. Создаём волну в произвольном ребре и добавляем его в список волн, исключая ребро из множества непосещённых рёбер.

15. Пока это возможно, создаём следующую волну на следующем непосещённом ребре, удаляя его из множества непосещённых рёбер.

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D1%88%D0%B0%D0%B36.png)

16. Из графа `_graph_2` берём начальное ребро обхода (в данном случаем вершина АB).

17. Сравниваем с каждым ребром графа `_graph_1`:

17.1.  Если было найдено совпадение конца ребра `_graph_1` и начала ребра `_graph_2`, то довабляем ребро в `_graph_3`, начало которого происходит из вершины `_graph_1` и конец `_graph_2` (соединяем нужные вершины). 

17.2. Если совпадений не найдено, переходим к пункту 17.

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D1%88%D0%B0%D0%B37.png)

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D1%88%D0%B0%D0%B38.png)


18. Если в графе `_gragh_2` остались ещё рёбра, которые не сравнивались,то берём следующее такое и переходим к пункту (17).

19. Если в графе `_gragh_2` не осталось рёбер, которые не сравнивались,то переходим к пункту (20).

20. Если есть ещё неориентированный граф в исходном множестве,то переходим к этому графу и переходим к пункту (4).

21. Если в исходном множестве неориентированных гграфов больше нет, переходим к пункту (22).

22. Выводим получившееся объединение множества неориентированных графов.

![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D1%80%D0%B5%D0%B7%D1%83%D0%BB%D1%8C%D1%82%D0%B0%D1%82.png)

---


### Тестовые примеры

#### Тест №1

##### Входные данные
![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D0%A2%D0%B5%D1%81%D1%821.png)


##### Выходные данные
![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D1%80%D0%B5%D0%B7%D1%83%D0%BB%D1%8C%D1%82%D0%B0%D1%821.png)
---

#### Тест №2

##### Входные данные
![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D0%A2%D0%B5%D1%81%D1%822.png)


##### Выходные данные
![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D1%80%D0%B5%D0%B7%D1%83%D0%BB%D1%8C%D1%82%D0%B0%D1%822.png)
---

#### Тест №3

##### Входные данные
![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D0%A2%D0%B5%D1%81%D1%823.png)


##### Выходные данные
![image](https://github.com/iis-32170x/RPIIS/blob/%D0%A0%D1%83%D0%BC%D1%8F%D0%BD%D1%86%D0%B5%D0%B2%D0%B0_%D0%AF/Sem2/images/%D1%80%D0%B5%D0%B7%D1%83%D0%BB%D1%8C%D1%82%D0%B0%D1%823.png)
---


### Заключение 

Научилась формализовать алгоритмы работы с графами с использованием редактора КБЕ.
