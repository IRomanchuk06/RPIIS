# Расчётная работа по дисциплине ПиОИвИС, второй семестр


## Цель:


### Условие задания 5.4.
Построить фрагмент онтологии, продемонстрировать работу программы решения теоретико-графовой задачи по нахождению компонент связности в неориентированном графе в семантической памяти.

## Ключевые понятия:
*Граф* – совокупность двух множеств — множества самих объектов и множества их парных связей.

*Неориентированный граф*  — граф, рёбра которого направления не имеют.

*Матрица инцедентности* - одна из форм представления графа, в которой указываются связи между инцидентными элементами графа (ребро(дуга) и вершина).

*Компонента связности* - набор вершин графа, между любой парой которых существует путь.

## Выполнение задания
### Фрагмент онтологии
![image](https://github.com/iis-32170x/RPIIS/assets/147256759/0e75bde5-c718-4d9c-8174-8226bd64a74f)



### Демонстрация работы программы в семантической памяти
1. Задаём граф, задаём одну начальную вершину. 
![image](https://github.com/iis-32170x/RPIIS/assets/147256759/a67765a3-f9ed-439e-8be8-ecaa1530caea)



2. Создаём переменную `_visited`, указывающую на посещённую вершину графа и переменную `_subgraph`.
![image](https://github.com/iis-32170x/RPIIS/assets/147256759/f3c82703-d9a7-4c95-a134-767666d8d831)


3. Создаём переменную `added_edges`. Добавляем рёбра, инцедентные начальной вершине, в переменную `added_edges`. Добавляем все вершины, инцедентные с добавленными ребрами, в переменную в `_visited`.
![image](https://github.com/iis-32170x/RPIIS/assets/147256759/a8129bca-622d-43c0-85f7-0986ea9ae43e)



4. Переходим к следующей вершине, которая имеет хотя бы одно, инцедентное с ней рёбро, уже добавленное в `added_edges`. Добавляем все остальные её рёбра в `added_edges` и все вершины, инцедентные с этими рёбрами в `_visited`, если они раньше не были добавлены. Если нет вершины, которая имеет хотя бы одно, инцедентное с ней рёбро, уже добавленное в `added_edge`, то создаём подграф в переменной `_subgraph` из вершин `_visited` и рёбер `added_edges` и очищаем эти переменные. Переходим к следующей вершине и считаем её как новую стартовую, добавляем её в `_visited` Добавляем рёбра, инцедентные начальной вершине, в переменную added_edges. Добавляем все вершины, инцедентные с добавленными ребрами, в переменную `_visited`.
![image](https://github.com/iis-32170x/RPIIS/assets/147256759/8395ea8e-8fff-485b-a357-307c7601f3e7)



5. Повторяем, пока не будут добавлены все вершины и рёбра и последний граф не заполнится
![image](https://github.com/iis-32170x/RPIIS/assets/147256759/2707f294-f44b-4c33-b966-23d2a4fb9d37)


6. Выводим все подграфы `_subgraph`
![image](https://github.com/iis-32170x/RPIIS/assets/147256759/17bead9b-43be-4344-ac7f-73ad3fb6a85e)


- Формализация понятий
	![Снимок экрана от 2024-06-03 11-27-32](https://github.com/iis-32170x/RPIIS/assets/147256759/867032df-5710-4273-ae8a-c928be500a2c)



## Примеры:
1.
![пример1](https://github.com/iis-32170x/RPIIS/assets/147256759/56d17e5c-c54b-411e-94ee-47a1b49ef700)

   
![пример1_результат](https://github.com/iis-32170x/RPIIS/assets/147256759/a7c8aaf4-f04d-4aee-9d3a-a32417f8be9a)

   
2.
![пример2](https://github.com/iis-32170x/RPIIS/assets/147256759/f5dae1b1-1874-48a7-8d09-26ce53f8ebe6)


![пример2_результат](https://github.com/iis-32170x/RPIIS/assets/147256759/d97b5e20-ec49-42b0-a58c-055ac1605f4a)


3. 
![пример3](https://github.com/iis-32170x/RPIIS/assets/147256759/5d2df2e8-4cf6-41d0-bf1c-688e21667288)


![пример3_результат](https://github.com/iis-32170x/RPIIS/assets/147256759/e7f9fd90-3884-44b2-a71c-953bdbeebc52)


4.
![пример4](https://github.com/iis-32170x/RPIIS/assets/147256759/8bf4faeb-a207-4557-a171-fe62609cb452)


![пример4_результат](https://github.com/iis-32170x/RPIIS/assets/147256759/b0da39c1-24c9-4a4e-8975-f946e7b68c6e)


5.
![пример5](https://github.com/iis-32170x/RPIIS/assets/147256759/ad3f6243-a89a-4b72-bba7-e8ae582cc479)


![пример5_результат](https://github.com/iis-32170x/RPIIS/assets/147256759/49370d19-695e-48f9-b389-3dc6a9365059)


# Вывод
Был построен фрагмент онтологии, продемонстрирована работа программы решения теоретико-графовой задачи по нахождению компонент связности в неориентированном графе в семантической памяти.

## Список литературы

[1] Кормен Т. Х. и др. Часть VI. Алгоритмы для работы с графами // Алгоритмы: построение и анализ = Introduction to Algorithms. – 2-е изд.. – М.: Вильямс, 2006. – С. 1296.

[2] Оре О. Теория графов. – 2-е изд.. – М.: Наука, 1980. – С. 336.

[3] Харари, Ф. Теория графов / Ф. Харари / Пер. с англ. и предисл. В.П. Козырева. Под ред. Г.П. Гаврилова. Изд. 2-е. – М.: Едиториал УРСС, 2003. – 269 с.

[4] Емеличев В. А., Мельников О. И., Сарванов В. И., Тышкевич Р. И. Лекции по теории графов. М.: Наука, 1990. 384с. (Изд.2, испр. М.: УРСС, 2009. 392 с.)

[5] Касьянов, В. Н. Графы в программировании: обработка, визуализация и применение / В. Н. Касьянов, В. А. Евстигнеева. – СПб. : БХВ-Петербург, 2003.
