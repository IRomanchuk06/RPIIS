# Отчет по расчетной работе по дисциплине ПиОИвИС
 ![image](https://github.com/iis-32170x/RPIIS/blob/%D0%9F%D1%88%D0%B5%D0%BD%D0%BE%D0%B2_%D0%95/Screens/IMG_20231218_184939_348.jpg)
## Цель моей расчётной работы:
Поподробнее познакомиться с основами теории графов, способами представления графов, базовыми алгоритмами для работы с графами.
## Условие задания 4.15(мс)
- Найти граф замыкания неориентированного графа.
- Граф задаётся матрицей смежности, данные которой читаются из консоли. 
- Вывод работы программы также выводится в консоль.
## Базовые понятия необходимые для выполнения расчётной работы
- **Матрица смежности** графа — матрица, значения элементов которой характеризуются смежностью вершин графа. При этом значению элемента матрицы присваивается количество рёбер, которые соединяют соответствующие вершины (то есть которые инцидентны обеим вершинам).
- **Неориентированный граф** - граф, в котором все ребра являются звеньями, то есть порядок двух концов ребра графа не существенен.
- **Замыкание графа** - это такой набор рёбер, который содержит все возможные пути между всеми парами вершин.
- **Граф** - совокупность двух множеств множества самих объектов, называемого множеством вершин, и множества их парных связей, называемого множеством рёбер.  
## Код программы:
```cpp
#include <iostream>
#include <vector>
using namespace std;
    class ClosureGraph {
    public:
        ClosureGraph(int a) : vertices(a), closureMatrix(a, vector<int>(a, 0)) {}
        void addEdge(int v, int w) {
            closureMatrix[v - 1][w - 1] = 1;
            closureMatrix[w - 1][v - 1] = 1;
        }
        void computeClosure() {
            for (int k = 0; k < vertices; k++) {
                for (int i = 0; i < vertices; i++) {
                    for (int j = 0; j < vertices; j++) {
                        closureMatrix[i][j] = closureMatrix[i][j] || (closureMatrix[i][k] && closureMatrix[k][j]);
                    }
                }
            }
        }
        void printClosureMatrix() {
            setlocale (LC_ALL, "RU");
            cout << "Граф замыкания :" << endl;
            for (int i = 0; i < vertices; i++) {
                for (int j = 0; j < vertices; j++) {
                    cout << closureMatrix[i][j] << " ";
                }
                cout << endl;
            }
        }
    private:
        int vertices;
        vector<vector<int>> closureMatrix;
    };
    int main() {
        setlocale(LC_ALL, "RU");
        int v, e;
        cout << "Введите количество вершин графа : ";
        cin >> v;
        cout << "Введите количество рёбер графа : ";
        cin >> e;
        ClosureGraph closureGraph(v);
        cout << "Введите пары вершин, которые нужно соединить рёбрами :" << endl;
        for (int i = 0; i < e; i++ ) {
            int v, w;
            cout << i+1 << ":"<< " ";
            cin >> v >> w;
            closureGraph.addEdge(v, w);
        }
        closureGraph.computeClosure();
        closureGraph.printClosureMatrix();
        return 0;
    }
```
## Алгоритм решения задачи
- Введём количество вершин графа.
- Введём количество рёбер графа.
- Введём пары вершин, которые нужно соединить рёбрами.
- Получаем граф замыкания через матрицуу смежности.
 ![image](
## Тесты программы
