# *Расчётная работа*
## Введение
### Цель
Изучить основы теории графов, способы представления графов, базовые алгоритмы для работы с графами.
### Задание
2.13 Найти обхват графа

Граф представляется в виде списка смежности.
### Ключевые понятия
`Граф` - математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

`Ориентированный граф` — Граф, каждому ребру которого присвоено направление.

`Список смежности` - один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

`Обхват графа` - это наименьшее число ребер, которые нужно удалить из графа, чтобы он стал несвязным.

## Алгоритм решения
Вводим граф в виде списка смежности. Производим поиск в глубину от первой вершины и следующих непроверенных. Выводим в консоль обхват в виде цикла.
## Реализация на С++
```cpp
#include <iostream>
#include <vector>
using namespace std;
class graph {
public:
    graph(int a) : ver(a), cl(a, vector<int>(a, 0)) {}
    void addEdge(int v, int w) {
        cl[v - 1][w - 1] = 1;
        cl[w - 1][v - 1] = 1;
    }
    void computecl() {
        for (int k = 0; k < ver; k++) {
            for (int i = 0; i < ver; i++) {
                for (int j = 0; j < ver; j++) {
                    cl[i][j] = cl[i][j] || (cl[i][k] && cl[k][j]);
                }
            }
        }
    }
    void printcl() {
        setlocale(LC_ALL, "RU");
        cout << "Граф замыкания :" << endl;
        for (int i = 0; i < ver; i++) {
            for (int j = 0; j < ver; j++) {
                cout << cl[i][j] << " ";
            }
            cout << endl;
        }
    }
private:
    int ver;
    vector<vector<int>> cl;
};
int main() {
    setlocale(LC_ALL, "RU");
    int v, e;
    cout << "Введите количество вершин графа : ";
    cin >> v;
    cout << "Введите количество рёбер графа : ";
    cin >> e;
    graph graph(v);
    cout << "Введите пары вершин, которые нужно соединить рёбрами :" << endl;
    for (int i = 0; i < e; i++) {
        int v, w;
        cout << i + 1 << ":" << " ";
        cin >> v >> w;
        graph.addEdge(v, w);
    }
    graph.computecl();
    graph.printcl();
    return 0;
}
    
```
## Разбор кода
- `#include <iostream>` - библиотека для ввода \ вывода
- `using namespace std` - подключение пространства имен `std`
- `#include <vector>` - библиотека векторов
- `v' - текущая вершина графа
- `lastV' - номер вершины, в которой цикл замкнулся
- `to'  - соседние рёбра
- `visited' - массив для отметки пройденых вершин
- `void DFS(vector<vector<int>> &graph, int v, vector<int> &visited, vector<int>& from, vector<int> &cycle) ` -  создание фунции поиска в глубину
- `setlocale(LC_ALL, "RU")` - подключение русскоязычного пакета
- `V' - количество вершин
- `R' - колво рёбер
- `for (int i = 0; i < R; i++)` - цикл, для ввода списка смежности
- `vector<int> visited(V)` - инициализация вектора visited
- `vector<int> cycle;` - инициализация вектора cycle
- `vector<int> from(V, -1)` - инициализация вектора from
- `int main()` - основная фунция

## Тестирование 
на скриншотах рр и рр.

## Вывод
В результате выполнения расчётной работы приобрёл следующие навыки

- изучил основы теории графов
- изучил способы представления графов
- изучил базовые алгоритмы для работы с графами
